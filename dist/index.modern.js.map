{"version":3,"file":"index.modern.js","sources":["../node_modules/elix/src/core/internal.js","../node_modules/elix/src/base/internal.js","../node_modules/elix/src/core/htmlLiterals.js","../node_modules/elix/src/core/dom.js","../node_modules/elix/src/core/AttributeMarshallingMixin.js","../node_modules/elix/src/core/ReactiveMixin.js","../node_modules/elix/src/core/ShadowTemplateMixin.js","../node_modules/elix/src/core/ReactiveElement.js","../src/components/Color.js","../src/lib/utils.js","../src/components/Colors.js","../src/components/Css.js","../src/components/Preview.js","../src/components/Header.js","../src/components/Ripple.js","../src/components/Button.js","../node_modules/elix/src/core/template.js","../node_modules/elix/src/base/DelegateInputLabelMixin.js","../node_modules/elix/src/base/FocusVisibleMixin.js","../node_modules/elix/src/base/FormElementMixin.js","../node_modules/elix/src/base/DelegateFocusMixin.js","../node_modules/elix/src/base/WrappedStandardElement.js","../node_modules/elix/src/base/Input.js","../node_modules/elix/src/base/TrackTextSelectionMixin.js","../node_modules/elix/src/base/accessibility.js","../node_modules/elix/src/base/ComposedFocusMixin.js","../node_modules/elix/src/base/CursorAPIMixin.js","../node_modules/elix/src/base/scrolling.js","../node_modules/elix/src/base/CursorInViewMixin.js","../node_modules/elix/src/base/DirectionCursorMixin.js","../node_modules/elix/src/base/ItemsAPIMixin.js","../node_modules/elix/src/base/ItemsCursorMixin.js","../node_modules/elix/src/base/content.js","../node_modules/elix/src/base/ItemsTextMixin.js","../node_modules/elix/src/base/KeyboardDirectionMixin.js","../node_modules/elix/src/base/KeyboardMixin.js","../node_modules/elix/src/base/KeyboardPagedCursorMixin.js","../node_modules/elix/src/base/constants.js","../node_modules/elix/src/base/KeyboardPrefixCursorMixin.js","../node_modules/elix/src/base/LanguageDirectionMixin.js","../node_modules/elix/src/base/SelectedTextAPIMixin.js","../node_modules/elix/src/base/SelectedValueAPIMixin.js","../node_modules/elix/src/base/SingleSelectAPIMixin.js","../node_modules/elix/src/base/SlotContentMixin.js","../node_modules/elix/src/base/SlotItemsMixin.js","../node_modules/elix/src/base/ContentItemsMixin.js","../node_modules/elix/src/base/TapCursorMixin.js","../node_modules/elix/src/base/ListBox.js","../node_modules/elix/src/base/AriaListMixin.js","../node_modules/elix/src/base/CursorSelectMixin.js","../node_modules/elix/src/base/AutoCompleteInput.js","../node_modules/elix/src/base/Hidden.js","../node_modules/elix/src/base/PopupDragSelectMixin.js","../node_modules/elix/src/base/DisabledMixin.js","../node_modules/elix/src/base/layoutPopup.js","../node_modules/elix/src/base/OpenCloseMixin.js","../node_modules/elix/src/base/AriaRoleMixin.js","../node_modules/elix/src/base/Backdrop.js","../node_modules/elix/src/base/OverlayFrame.js","../node_modules/elix/src/base/OverlayMixin.js","../node_modules/elix/src/base/Overlay.js","../node_modules/elix/src/base/PopupModalityMixin.js","../node_modules/elix/src/base/Popup.js","../node_modules/elix/src/base/PopupSource.js","../node_modules/elix/src/base/UpDownToggle.js","../node_modules/elix/src/base/PopupToggleMixin.js","../node_modules/elix/src/base/ComboBox.js","../node_modules/elix/src/base/DelegateInputSelectionMixin.js","../node_modules/elix/src/base/DelegateCursorMixin.js","../node_modules/elix/src/base/DelegateItemsMixin.js","../node_modules/elix/src/base/PopupListMixin.js","../node_modules/elix/src/base/ListComboBox.js","../node_modules/elix/src/base/AutoCompleteComboBox.js","../src/components/Combobox.js","../node_modules/elix/src/base/Menu.js","../node_modules/elix/src/base/AriaMenuMixin.js","../node_modules/elix/src/base/PopupButton.js","../node_modules/elix/src/base/DropdownList.js","../src/components/Toggle.js","../src/components/Select.js","../node_modules/elix/src/base/Option.js","../node_modules/elix/src/base/CurrentMixin.js","../node_modules/elix/src/base/SelectableMixin.js","../src/components/Option.js"],"sourcesContent":["/**\n * Collection of shared Symbol objects for internal component communication.\n *\n * The shared `Symbol` objects in this module let mixins and a component\n * internally communicate without exposing these internal properties and methods\n * in the component's public API. They also help avoid unintentional name\n * collisions, as a component developer must specifically import the `internal`\n * module and reference one of its symbols.\n *\n * To use these `Symbol` objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol. E.g.,\n * [ShadowTemplateMixin](ShadowTemplateMixin) expects a component to define\n * a property called [template](#template):\n *\n *     import { template } from 'elix/src/core/internal.js';\n *     import { templateFrom } from 'elix/src/core/htmlLiterals.js'\n *     import ShadowTemplateMixin from 'elix/src/core/ShadowTemplateMixin.js';\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       [template]() {\n *         return templateFrom.html`Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * The above use of the internal `template` member lets the mixin find the\n * component's template in a way that will not pollute the component's public\n * API or interfere with other component logic. For example, if for some reason\n * the component wants to define a separate property with the plain string name,\n * \"template\", it can do so without affecting the above property setter.\n *\n * @module internal\n */\n\n/**\n * Symbol for the default state for this element.\n */\nexport const defaultState = Symbol(\"defaultState\");\n\n/**\n * Symbol for the `delegatesFocus` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property, returning\n * true to indicate that the focus is being delegated, even in browsers that\n * don't support that natively. Mixins like [KeyboardMixin](KeyboardMixin) use\n * this to accommodate focus delegation.\n */\nexport const delegatesFocus = Symbol(\"delegatesFocus\");\n\n/**\n * Symbol for the `firstRender` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets the property to `true` during the\n * element's first `render` and `rendered` callback, then `false` in subsequent\n * callbacks.\n *\n * You can inspect this property in your own `rendered` callback handler to do\n * work like wiring up events that should only happen once.\n */\nexport const firstRender = Symbol(\"firstRender\");\n\n/**\n * Symbol for the `focusTarget` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property as either:\n * 1) the element itself, in browsers that support native focus delegation or,\n * 2) the shadow root's first focusable element.\n */\nexport const focusTarget = Symbol(\"focusTarget\");\n\n/**\n * Symbol for the `hasDynamicTemplate` property.\n *\n * If your component class does not always use the same template, define a\n * static class property getter with this symbol and have it return `true`.\n * This will disable template caching for your component.\n */\nexport const hasDynamicTemplate = Symbol(\"hasDynamicTemplate\");\n\n/**\n * Symbol for the `ids` property.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) defines a shorthand function\n * `internal.ids` that can be used to obtain a reference to a shadow element with\n * a given ID.\n *\n * Example: if component's template contains a shadow element\n * `<button id=\"foo\">`, you can use the reference `this[ids].foo` to obtain\n * the corresponding button in the component instance's shadow tree.\n * The `ids` function is simply a shorthand for `getElementById`, so\n * `this[ids].foo` is the same as `this.shadowRoot.getElementById('foo')`.\n */\nexport const ids = Symbol(\"ids\");\n\n/**\n * Symbol for access to native HTML element internals.\n */\nexport const nativeInternals = Symbol(\"nativeInternals\");\n\n/**\n * Symbol for the `raiseChangeEvents` property.\n *\n * This property is used by mixins to determine whether they should raise\n * property change events. The standard HTML pattern is to only raise such\n * events in response to direct user interactions. For a detailed discussion\n * of this point, see the Gold Standard checklist item for\n * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n *\n * The above article describes a pattern for using a flag to track whether\n * work is being performed in response to internal component activity, and\n * whether the component should therefore raise property change events.\n * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n * all Elix mixins and components. Sharing this flag ensures that internal\n * activity (e.g., a UI event listener) in one mixin can signal other mixins\n * handling affected properties to raise change events.\n *\n * All UI event listeners (and other forms of internal handlers, such as\n * timeouts and async network handlers) should set `raiseChangeEvents` to\n * `true` at the start of the event handler, then `false` at the end:\n *\n *     this.addEventListener('click', event => {\n *       this[raiseChangeEvents] = true;\n *       // Do work here, possibly setting properties, like:\n *       this.foo = 'Hello';\n *       this[raiseChangeEvents] = false;\n *     });\n *\n * Elsewhere, property setters that raise change events should only do so it\n * this property is `true`:\n *\n *     set foo(value) {\n *       // Save foo value here, do any other work.\n *       if (this[raiseChangeEvents]) {\n *         export const event = new CustomEvent('foochange');\n *         this.dispatchEvent(event);\n *       }\n *     }\n *\n * In this way, programmatic attempts to set the `foo` property will not trigger\n * the `foochange` event, but UI interactions that update that property will\n * cause those events to be raised.\n */\nexport const raiseChangeEvents = Symbol(\"raiseChangeEvents\");\n\n/**\n * Symbol for the `render` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this `internal.render` method to give\n * the component a chance to render recent changes in component state.\n */\nexport const render = Symbol(\"render\");\n\n/**\n * Symbol for the `renderChanges` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this method in response to a\n * `setState` call; you should generally not invoke this method yourself.\n */\nexport const renderChanges = Symbol(\"renderChanges\");\n\n/**\n * Symbol for the `rendered` method.\n *\n * [ReactiveMixin](ReactiveMixin) will invoke this method after your\n * element has completely finished rendering.\n *\n * If you only want to do work the first time rendering happens (for example, if\n * you want to wire up event handlers), your `internal.rendered` implementation\n * can inspect the `internal.firstRender` flag.\n */\nexport const rendered = Symbol(\"rendered\");\n\n/**\n * Symbol for the `rendering` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets this property to true during rendering,\n * at other times it will be false.\n */\nexport const rendering = Symbol(\"rendering\");\n\n/**\n * Symbol for the `setState` method.\n *\n * A component using [ReactiveMixin](ReactiveMixin) can invoke this method to\n * apply changes to the element's current state.\n */\nexport const setState = Symbol(\"setState\");\n\n/**\n * Symbol for the `shadowRoot` property.\n *\n * This property holds a reference to an element's shadow root, like\n * `this.shadowRoot`. This propery exists because `this.shadowRoot` is not\n * available for components with closed shadow roots.\n * [ShadowTemplateMixin](ShadowTemplateMixin) creates open shadow roots by\n * default, but you can opt into creating closed shadow roots; see\n * [shadowRootMode](internal#internal.shadowRootMode).\n */\nexport const shadowRoot = Symbol(\"shadowRoot\");\n\n/**\n * Symbol for the `shadowRootMode` property.\n *\n * If true (the default), then [ShadowTemplateMixin](ShadowTemplateMixin) will\n * create an open shadow root when the component is instantiated. Set this to\n * false if you want to programmatically hide component internals in a closed\n * shadow root.\n */\nexport const shadowRootMode = Symbol(\"shadowRootMode\");\n\n/**\n * Symbol for the element's current state.\n *\n * This is managed by [ReactiveMixin](ReactiveMixin).\n */\nexport const state = Symbol(\"state\");\n\n/**\n * Symbol for the `stateEffects` method.\n *\n * See [stateEffects](ReactiveMixin#stateEffects).\n */\nexport const stateEffects = Symbol(\"stateEffects\");\n\n/**\n * Symbol for the `template` method.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) uses this property to obtain a\n * component's template, which it will clone into a component's shadow root.\n */\nexport const template = Symbol(\"template\");\n","/**\n * Collection of shared Symbol objects for internal component communication.\n *\n * The shared `Symbol` objects in this module let mixins and a component\n * internally communicate without exposing these internal properties and methods\n * in the component's public API. They also help avoid unintentional name\n * collisions, as a component developer must specifically import the `internal`\n * module and reference one of its symbols.\n *\n * To use these `Symbol` objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol. E.g.,\n * [ShadowTemplateMixin](ShadowTemplateMixin) expects a component to define\n * a property called [template](#template):\n *\n *     import { template } from 'elix/src/core/internal.js';\n *     import { templateFrom } from 'elix/src/core/htmlLiterals.js'\n *     import ShadowTemplateMixin from 'elix/src/core/ShadowTemplateMixin.js';\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       [template]() {\n *         return templateFrom.html`Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * The above use of the internal `template` member lets the mixin find the\n * component's template in a way that will not pollute the component's public\n * API or interfere with other component logic. For example, if for some reason\n * the component wants to define a separate property with the plain string name,\n * \"template\", it can do so without affecting the above property setter.\n *\n * @module internal\n */\n\nimport * as coreInternal from \"../core/internal.js\";\n\n/**\n * Symbol for the `applyElementData` method.\n *\n * Components that want to be able to apply data from one element to another\n * can support this method. E.g., [DropdownList](DropdownList) uses this to\n * apply data from the selected item to the component's value part.\n */\nexport const applyElementData = Symbol(\"applyElementData\");\n\n/**\n * Symbol for the `checkSize` method.\n *\n * If defined, this method will be invoked by [ResizeMixin](ResizeMixin)\n * when an element's size may have changed. The default implementation of\n * this method compares the element's current `clientHeight` and `clientWidth`\n * properties against the last known values of those properties (saved in\n * `state.clienHeight` and `state.clientWidth`).\n *\n * Components should override this method if they contain elements that may need\n * to know about size changes as well. For example, when an [Overlay](Overlay)\n * mixin opens, it invokes this method on any content elements that define it.\n * This gives the contents a chance to resize in response to being displayed.\n */\nexport const checkSize = Symbol(\"checkSize\");\n\n/**\n * Symbol for the `closestAvailableItemIndex` method.\n *\n * This method is defined by [ItemsCursorMixin](ItemsCursorMixin). You can call\n * this if you want to find an item at a particular location, but may need to\n * account for the fact that the item at that position is not available, and\n * would like to find the closest item that is available.\n */\nexport const closestAvailableItemIndex = Symbol(\"closestAvailableItemIndex\");\n\n/**\n * Symbol for the `contentSlot` property.\n *\n * [SlotContentMixin](SlotContentMixin) uses this to identify which slot\n * element in the component's shadow tree that holds the component's content.\n * By default, this is the first slot element with no \"name\" attribute. You\n * can override this to return a different slot.\n */\nexport const contentSlot = Symbol(\"contentSlot\");\n\n/**\n * The default state for this element.\n */\nexport const defaultState = coreInternal.defaultState;\n\n/**\n * Symbol for the `defaultTabIndex` property.\n *\n * [KeyboardMixin](KeyboardMixin) uses this if it is unable to successfully\n * parse a string tabindex attribute.\n */\nexport const defaultTabIndex = Symbol(\"defaultTabIndex\");\n\n/**\n * Symbol for the `delegatesFocus` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property, returning\n * true to indicate that the focus is being delegated, even in browsers that\n * don't support that natively. Mixins like [KeyboardMixin](KeyboardMixin) use\n * this to accommodate focus delegation.\n */\nexport const delegatesFocus = coreInternal.delegatesFocus;\n\n/**\n * Symbol for the `effectEndTarget` property.\n *\n * [TransitionEffectMixin](TransitionEffectMixin) inspects this property to\n * determine which element's `transitionend` event will signal the end of a\n * transition effect.\n */\nexport const effectEndTarget = Symbol(\"effectEndTarget\");\n\n/**\n * Symbol for the `firstRender` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets the property to `true` during the\n * element's first `connectedCallback`, then `false` in subsequent callbacks.\n *\n * You can inspect this property in your own `connectedCallback` handler\n * to do work like wiring up events that should only happen once.\n */\nexport const firstRender = coreInternal.firstRender;\n\n/**\n * Symbol for the `focusTarget` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property as either:\n * 1) the element itself, in browsers that support native focus delegation or,\n * 2) the shadow root's first focusable element.\n */\nexport const focusTarget = coreInternal.focusTarget;\n\n/**\n * Symbol for the `getItemText` method.\n *\n * This method can be applied to an item to return its text.\n * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin) uses this to\n * obtain the text for each item in a list, then matches keypresses again that\n * text.\n *\n * This method takes a single parameter: the `HTMLElement` of the item from\n * which text should be extracted.\n */\nexport const getItemText = Symbol(\"getItemText\");\n\n/**\n * Symbol for the `goDown` method.\n *\n * This method is invoked when the user wants to go/navigate down.\n */\nexport const goDown = Symbol(\"goDown\");\n\n/**\n * Symbol for the `goEnd` method.\n *\n * This method is invoked when the user wants to go/navigate to the end (e.g.,\n * of a list).\n */\nexport const goEnd = Symbol(\"goEnd\");\n\n/**\n * Symbol for the `goFirst` method.\n *\n * This method is invoked when the user wants to go to the first item in a list.\n */\nexport const goFirst = Symbol(\"goFirst\");\n\n/**\n * Symbol for the `goLast` method.\n *\n * This method is invoked when the user wants to go to the last item in a list.\n */\nexport const goLast = Symbol(\"goLast\");\n\n/**\n * Symbol for the `goLeft` method.\n *\n * This method is invoked when the user wants to go/navigate left. Mixins that\n * make use of this method include\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) and\n * [SwipeDirectionMixin](SwipeDirectionMixin).\n */\nexport const goLeft = Symbol(\"goLeft\");\n\n/**\n * Symbol for the `goNext` method.\n *\n * This method is invoked when the user wants to go/navigate to the next item.\n */\nexport const goNext = Symbol(\"goNext\");\n\n/**\n * Symbol for the `goPrevious` method.\n *\n * This method is invoked when the user wants to go/navigate to the previous item.\n */\nexport const goPrevious = Symbol(\"goPrevious\");\n\n/**\n * Symbol for the `goRight` method.\n *\n * This method is invoked when the user wants to go/navigate right. Mixins\n * that make use of this method include\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) and\n * [SwipeDirectionMixin](SwipeDirectionMixin).\n */\nexport const goRight = Symbol(\"goRight\");\n\n/**\n * Symbol for the `goStart` method.\n *\n * This method is invoked when the user wants to go/navigate to the start\n * (e.g., of a list).\n */\nexport const goStart = Symbol(\"goStart\");\n\n/**\n * Symbol for the `goToItemWithPrefix` method.\n *\n * This method is invoked by\n * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin) when the user types\n * text characters.\n */\nexport const goToItemWithPrefix = Symbol(\"goToItemWithPrefix\");\n\n/**\n * Symbol for the `goUp` method.\n *\n * This method is invoked when the user wants to go/navigate up.\n */\nexport const goUp = Symbol(\"goUp\");\n\n/**\n * Symbol for the `hasDynamicTemplate` property.\n *\n * If your component class does not always use the same template, define a\n * static class property getter with this symbol and have it return `true`.\n * This will disable template caching for your component.\n */\nexport const hasDynamicTemplate = coreInternal.hasDynamicTemplate;\n\n/**\n * Symbol for the `ids` property.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) defines a shorthand function\n * `internal.ids` that can be used to obtain a reference to a shadow element with\n * a given ID.\n *\n * Example: if component's template contains a shadow element\n * `<button id=\"foo\">`, you can use the reference `this[ids].foo` to obtain\n * the corresponding button in the component instance's shadow tree.\n * The `ids` function is simply a shorthand for `getElementById`, so\n * `this[ids].foo` is the same as `this.shadowRoot.getElementById('foo')`.\n */\nexport const ids = coreInternal.ids;\n\n/**\n * Symbol for the `inputDelegate` property.\n *\n * [DelegateInputSelectionMixin](DelegateInputSelectionMixin) uses this property\n * to indicate which shadow element is the input-type element to which text\n * selection methods and properties should be delegated.\n */\nexport const inputDelegate = Symbol(\"inputDelegate\");\n\n/**\n * Symbol for the `itemsDelegate` property.\n *\n * A component using [DelegateItemsMixin](DelegateItemsMixin) uses this property\n * to indicate which one of its shadow elements is the one whose `items`\n * property will be treated as the component's own `items`.\n */\nexport const itemsDelegate = Symbol(\"itemsDelegate\");\n\n/**\n * Symbol for the `keydown` method.\n *\n * This method is invoked when an element receives a `keydown` event.\n *\n * An implementation of `internal.keydown` should return `true` if it handled\n * the event, and `false` otherwise. If `true` is returned (the event was\n * handled), `KeyboardMixin` invokes the event's `preventDefault` and\n * `stopPropagation` methods to let the browser know the event was handled.\n *\n * The convention for handling `internal.keydown` is that the last mixin\n * applied wins. That is, if an implementation of `internal.keydown` *did*\n * handle the event, it can return immediately. If it did not, it should\n * invoke `super` to let implementations further up the prototype chain have\n * their chance.\n *\n * This method takes a `KeyboardEvent` parameter that contains the event being\n * processed.\n */\nexport const keydown = Symbol(\"keydown\");\n\n/**\n * Symbol for the `matchText` method.\n *\n * [AutoCompleteInput](AutoCompleteInput) invokes this method when trying\n * to find a match for a given input string against its set of texts.\n */\nexport const matchText = Symbol(\"matchText\");\n\n/**\n * Symbol for the `mouseenter` method.\n *\n * [HoverMixin](HoverMixin) invokes this method when the user moves the\n * mouse over a component. That mixin provides a base implementation of this\n * method, but you can extend it to do additional work on `mouseenter`.\n *\n * This method takes a `MouseEvent` parameter that contains the event being\n * processed.\n */\nexport const mouseenter = Symbol(\"mouseenter\");\n\n/**\n * Symbol for the `mouseleave` method.\n *\n * [HoverMixin](HoverMixin) invokes this method when the user moves off a\n * component. That mixin provides a base implementation of this method, but\n * you can extend it to do additional work on `mouseleave`.\n *\n * This method takes a `MouseEvent` parameter that contains the event being\n * processed.\n */\nexport const mouseleave = Symbol(\"mouseleave\");\n\n/**\n * Symbol for access to native HTML element internals.\n */\nexport const nativeInternals = coreInternal.nativeInternals;\n\n/**\n * Symbol for the `raiseChangeEvents` property.\n *\n * This property is used by mixins to determine whether they should raise\n * property change events. The standard HTML pattern is to only raise such\n * events in response to direct user interactions. For a detailed discussion\n * of this point, see the Gold Standard checklist item for\n * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n *\n * The above article describes a pattern for using a flag to track whether\n * work is being performed in response to internal component activity, and\n * whether the component should therefore raise property change events.\n * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n * all Elix mixins and components. Sharing this flag ensures that internal\n * activity (e.g., a UI event listener) in one mixin can signal other mixins\n * handling affected properties to raise change events.\n *\n * All UI event listeners (and other forms of internal handlers, such as\n * timeouts and async network handlers) should set `raiseChangeEvents` to\n * `true` at the start of the event handler, then `false` at the end:\n *\n *     this.addEventListener('click', event => {\n *       this[raiseChangeEvents] = true;\n *       // Do work here, possibly setting properties, like:\n *       this.foo = 'Hello';\n *       this[raiseChangeEvents] = false;\n *     });\n *\n * Elsewhere, property setters that raise change events should only do so it\n * this property is `true`:\n *\n *     set foo(value) {\n *       // Save foo value here, do any other work.\n *       if (this[raiseChangeEvents]) {\n *         export const event = new CustomEvent('foochange');\n *         this.dispatchEvent(event);\n *       }\n *     }\n *\n * In this way, programmatic attempts to set the `foo` property will not trigger\n * the `foochange` event, but UI interactions that update that property will\n * cause those events to be raised.\n */\nexport const raiseChangeEvents = coreInternal.raiseChangeEvents;\n\n/**\n * Symbol for the `render` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this `internal.render` method to give\n * the component a chance to render recent changes in component state.\n */\nexport const render = coreInternal.render;\n\n/**\n * Symbol for the `renderChanges` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this method in response to a\n * `setState` call; you should generally not invoke this method yourself.\n */\nexport const renderChanges = coreInternal.renderChanges;\n\n/**\n * Symbol for the `renderDataToElement` method.\n *\n * [DataItemsMixin](DataItemsMixin) invokes this method to render data to an\n * element being used as an item in a list.\n */\nexport const renderDataToElement = Symbol(\"renderDataToElement\");\n\n/**\n * Symbol for the `rendered` method.\n *\n * [ReactiveMixin](ReactiveMixin) will invoke this method after your\n * element has completely finished rendering.\n */\nexport const rendered = coreInternal.rendered;\n\n/**\n * Symbol for the `rendering` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets this property to true during rendering,\n * at other times it will be false.\n */\nexport const rendering = coreInternal.rendering;\n\n/**\n * Symbol for the `scrollTarget` property.\n *\n * This property indicates which element in a component's shadow subtree\n * should be scrolled. [CursorInViewMixin](CursorInViewMixin) can use\n * this property to determine which element should be scrolled to keep the\n * selected item in view.\n */\nexport const scrollTarget = Symbol(\"scrollTarget\");\n\n/**\n * Symbol for the `setState` method.\n *\n * A component using [ReactiveMixin](ReactiveMixin) can invoke this method to\n * apply changes to the element's current state.\n */\nexport const setState = coreInternal.setState;\n\n/**\n * Symbol for the `shadowRoot` property.\n *\n * This property holds a reference to an element's shadow root, like\n * `this.shadowRoot`. This propery exists because `this.shadowRoot` is not\n * available for components with closed shadow roots.\n * [ShadowTemplateMixin](ShadowTemplateMixin) creates open shadow roots by\n * default, but you can opt into creating closed shadow roots; see\n * [shadowRootMode](internal#internal.shadowRootMode).\n */\nexport const shadowRoot = coreInternal.shadowRoot;\n\n/**\n * Symbol for the `shadowRootMode` property.\n *\n * If true (the default), then [ShadowTemplateMixin](ShadowTemplateMixin) will\n * create an open shadow root when the component is instantiated. Set this to\n * false if you want to programmatically hide component internals in a closed\n * shadow root.\n */\nexport const shadowRootMode = coreInternal.shadowRootMode;\n\n/**\n * Symbol for the `startEffect` method.\n *\n * A component using [TransitionEffectMixin](TransitionEffectMixin) can invoke\n * this method to trigger the application of a named, asynchronous CSS\n * transition effect.\n *\n * This method takes a single `string` parameter giving the name of the effect\n * to start.\n */\nexport const startEffect = Symbol(\"startEffect\");\n\n/**\n * The element's current state.\n *\n * This is managed by [ReactiveMixin](ReactiveMixin).\n */\nexport const state = coreInternal.state;\n\nexport const stateEffects = coreInternal.stateEffects;\n\n/**\n * Symbol for the `swipeDown` method.\n *\n * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when\n * the user finishes a gesture to swipe down.\n */\nexport const swipeDown = Symbol(\"swipeDown\");\n\n/**\n * Symbol for the `swipeDownComplete` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe down has completed.\n */\nexport const swipeDownComplete = Symbol(\"swipeDownComplete\");\n\n/**\n * Symbol for the `swipeLeft` method.\n *\n * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user\n * finishes a gesture to swipe left.\n */\nexport const swipeLeft = Symbol(\"swipeLeft\");\n\n/**\n * Symbol for the `swipeLeftTransitionEnd` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe left has completed.\n */\nexport const swipeLeftTransitionEnd = Symbol(\"swipeLeftTransitionEnd\");\n\n/**\n * Symbol for the `swipeRight` method.\n *\n * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user\n * finishes a gesture to swipe right.\n */\nexport const swipeRight = Symbol(\"swipeRight\");\n\n/**\n * Symbol for the `swipeRightTransitionEnd` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe right has completed.\n */\nexport const swipeRightTransitionEnd = Symbol(\"swipeRightTransitionEnd\");\n\n/**\n * Symbol for the `swipeUp` method.\n *\n * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when\n * the user finishes a gesture to swipe up.\n */\nexport const swipeUp = Symbol(\"swipeUp\");\n\n/**\n * Symbol for the `swipeUpComplete` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe up has completed.\n */\nexport const swipeUpComplete = Symbol(\"swipeUpComplete\");\n\n/**\n * Symbol for the `swipeStart` method.\n *\n * [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when a swipe\n * is starting, passing in the starting (x, y) client coordinate.\n */\nexport const swipeStart = Symbol(\"swipeStart\");\n\n/**\n * Symbol for the `swipeTarget` property.\n *\n * By default, the swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) assume that the element the user\n * is swiping the top-level element. In some cases (e.g., [Drawer](Drawer)),\n * the component wants to let the user swipe a shadow element. In such cases,\n * this property should return the element that should be swiped.\n *\n * The swipe target's `offsetWidth` is used by the mixin to calculate the\n * `state.swipeFraction` member when the user drags their finger. The\n * `swipeFraction` is the distance the user has dragged in the current drag\n * operation over that `offsetWidth`.\n */\nexport const swipeTarget = Symbol(\"swipeTarget\");\n\n/**\n * Symbol for the `tap` method.\n *\n * This method is invoked when an element receives an operation that should\n * be interpreted as a tap. [TapCursorMixin](TapCursorMixin)\n * invokes this when the element receives a `mousedown` event, for example.\n */\nexport const tap = Symbol(\"tap\");\n\n/**\n * Symbol for the `template` method.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) uses this property to obtain a\n * component's template, which it will clone into a component's shadow root.\n */\nexport const template = coreInternal.template;\n\n/**\n * Symbol for the `toggleSelectedFlag` method.\n *\n * [ItemsMultiSelectMixin](ItemsMultiSelectMixin) exposes this method to let\n * other mixins like [MultiSelectAPIMixin](MultiSelectAPIMixin) toggle the\n * selected state of an individual item.\n */\nexport const toggleSelectedFlag = Symbol(\"toggleSelectedFlag\");\n\n// Expose internals as a global when debugging.\nconst elixdebug = new URLSearchParams(location.search).get(\"elixdebug\");\nif (elixdebug === \"true\") {\n  /** @type {any} */ (window).elix = {\n    internal: {\n      checkSize,\n      closestAvailableItemIndex,\n      contentSlot,\n      defaultState,\n      defaultTabIndex,\n      delegatesFocus,\n      effectEndTarget,\n      firstRender,\n      focusTarget,\n      getItemText,\n      goDown,\n      goEnd,\n      goFirst,\n      goLast,\n      goLeft,\n      goNext,\n      goPrevious,\n      goRight,\n      goStart,\n      goToItemWithPrefix,\n      goUp,\n      hasDynamicTemplate,\n      ids,\n      inputDelegate,\n      itemsDelegate,\n      keydown,\n      mouseenter,\n      mouseleave,\n      nativeInternals,\n      event,\n      raiseChangeEvents,\n      render,\n      renderChanges,\n      renderDataToElement,\n      rendered,\n      rendering,\n      scrollTarget,\n      setState,\n      shadowRoot,\n      shadowRootMode,\n      startEffect,\n      state,\n      stateEffects,\n      swipeDown,\n      swipeDownComplete,\n      swipeLeft,\n      swipeLeftTransitionEnd,\n      swipeRight,\n      swipeRightTransitionEnd,\n      swipeUp,\n      swipeUpComplete,\n      swipeStart,\n      swipeTarget,\n      tap,\n      template,\n      toggleSelectedFlag,\n    },\n  };\n}\n","/**\n * JavaScript template literals for constructing DOM nodes from HTML\n *\n * @module html\n */\n\n/**\n * A JavaScript template string literal that returns an HTML document fragment.\n *\n * Example:\n *\n *     const fragment = fragmentFrom.html`Hello, <em>world</em>.`\n *\n * returns a `DocumentFragment` whose `innerHTML` is `Hello, <em>world</em>.`\n *\n * This function is called `html` so that it can be easily used with HTML\n * syntax-highlighting extensions for various popular code editors.\n *\n * See also [templateFrom.html](template#html), which returns a similar result but\n * as an HTMLTemplateElement.\n *\n * @param {TemplateStringsArray} strings - the strings passed to the JavaScript template\n * literal\n * @param {string[]} substitutions - the variable values passed to the\n * JavaScript template literal\n * @returns {DocumentFragment}\n */\nexport const fragmentFrom = {\n  html(strings, ...substitutions) {\n    return templateFrom.html(strings, ...substitutions).content;\n  },\n};\n\n/**\n * A JavaScript template string literal that returns an HTML template.\n *\n * Example:\n *\n *     const myTemplate = templateFrom.html`Hello, <em>world</em>.`\n *\n * returns an `HTMLTemplateElement` whose `innerHTML` is `Hello, <em>world</em>.`\n *\n * This function is called `html` so that it can be easily used with HTML\n * syntax-highlighting extensions for various popular code editors.\n *\n * See also [html](html), a helper which returns a similar result but as an\n * DocumentFragment.\n *\n * @param {TemplateStringsArray} strings - the strings passed to the JavaScript template\n * literal\n * @param {string[]} substitutions - the variable values passed to the\n * JavaScript template literal\n * @returns {HTMLTemplateElement}\n */\nexport const templateFrom = {\n  html(strings, ...substitutions) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = String.raw(strings, ...substitutions);\n    return template;\n  },\n};\n","import { focusTarget, nativeInternals } from \"./internal.js\";\n\n/**\n * Miscellaneous DOM helpers for web components\n *\n * @module dom\n */\n\nconst mousedownListenerKey = Symbol(\"mousedownListener\");\n\n/**\n * Given a string value for a named boolean attribute, return `true` if the\n * value is either: a) the empty string, or b) a case-insensitive match for the\n * name.\n *\n * This is native HTML behavior; see the MDN documentation on [boolean\n * attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#Boolean_Attributes)\n * for the reasoning.\n *\n * Given a null value, this return `false`.\n * Given a boolean value, this return the value as is.\n *\n * @param {string} name\n * @param {string|boolean|null} value\n */\nexport function booleanAttributeValue(name, value) {\n  return typeof value === \"boolean\"\n    ? value\n    : typeof value === \"string\"\n    ? value === \"\" || name.toLowerCase() === value.toLowerCase()\n    : false;\n}\n\n/**\n * Return the closest focusable node that's either the node itself (if it's\n * focusable), or the closest focusable ancestor in the *composed* tree.\n *\n * If no focusable node is found, this returns null.\n *\n * @param {Node} node\n * @returns {HTMLElement|null}\n */\nexport function closestFocusableNode(node) {\n  for (const current of selfAndComposedAncestors(node)) {\n    // If the current element defines a focusTarget (e.g., via\n    // DelegateFocusMixin), use that, otherwise use the element itself.\n    const target = current[focusTarget] || current;\n    // We want an element that has a tabIndex of 0 or more. We ignore disabled\n    // elements, and slot elements (which oddly have a tabIndex of 0).\n    /** @type {any} */ const cast = target;\n    const focusable =\n      target instanceof HTMLElement &&\n      target.tabIndex >= 0 &&\n      !cast.disabled &&\n      !(target instanceof HTMLSlotElement);\n    if (focusable) {\n      return target;\n    }\n  }\n  return null;\n}\n\n/**\n * Return the ancestors of the given node in the composed tree.\n *\n * In the composed tree, the ancestor of a node assigned to a slot is that slot,\n * not the node's DOM ancestor. The ancestor of a shadow root is its host.\n *\n * @param {Node} node\n * @returns {Iterable<Node>}\n */\nexport function* composedAncestors(node) {\n  /** @type {Node|null} */\n  let current = node;\n  while (true) {\n    current =\n      current instanceof HTMLElement && current.assignedSlot\n        ? current.assignedSlot\n        : current instanceof ShadowRoot\n        ? current.host\n        : current.parentNode;\n    if (current) {\n      yield current;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Returns true if the first node contains the second, even if the second node\n * is in a shadow tree.\n *\n * The standard Node.contains() function does not account for Shadow DOM, and\n * returns false if the supplied target node is sitting inside a shadow tree\n * within the container.\n *\n * @param {Node} container - The container to search within.\n * @param {Node} target - The node that may be inside the container.\n * @returns {boolean} - True if the container contains the target node.\n */\nexport function deepContains(container, target) {\n  /** @type {any} */\n  let current = target;\n  while (current) {\n    const parent = current.assignedSlot || current.parentNode || current.host;\n    if (parent === container) {\n      return true;\n    }\n    current = parent;\n  }\n  return false;\n}\n\n/**\n * Return the first focusable element in the composed tree below the given root.\n * The composed tree includes nodes assigned to slots.\n *\n * This heuristic considers only the document order of the elements below the\n * root and whether a given element is focusable. It currently does not respect\n * the tab sort order defined by tabindex values greater than zero.\n *\n * @param {Node} root - the root of the tree in which to search\n * @returns {HTMLElement|null} - the first focusable element, or null if none\n * was found\n */\nexport function firstFocusableElement(root) {\n  // CSS selectors for focusable elements from\n  // https://stackoverflow.com/a/30753870/76472\n  const focusableQuery =\n    'a[href],area[href],button:not([disabled]),details,iframe,input:not([disabled]),select:not([disabled]),textarea:not([disabled]),[contentEditable=\"true\"],[tabindex]';\n  // Walk the tree looking for nodes that match the above selectors.\n  const walker = walkComposedTree(\n    root,\n    (/** @type {Node} */ node) =>\n      node instanceof HTMLElement &&\n      node.matches(focusableQuery) &&\n      node.tabIndex >= 0\n  );\n  // We only actually need the first matching value.\n  const { value } = walker.next();\n  // value, if defined, will always be an HTMLElement, but we do the following\n  // check to pass static type checking.\n  return value instanceof HTMLElement ? value : null;\n}\n\n/**\n * Trap any `mousedown` events on the `origin` element and prevent the default\n * behavior from setting the focus on that element. Instead, put the focus on\n * the `target` element (or, if the `target` is not focusable, on the target's\n * closest focusable ancestor).\n *\n * If this method is called again with the same `origin` element, the old\n * forwarding is overridden, and focus will now go to the new `target` element.\n *\n * If the `target` parameter is `null`, focus handling will be removed from the\n * indicated `origin`.\n *\n * @param {HTMLElement} origin\n * @param {HTMLElement|null} target\n */\nexport function forwardFocus(origin, target) {\n  if (origin[mousedownListenerKey]) {\n    // Origin was previously forwarding focus, probably to a different target.\n    // Remove the previous event listener.\n    origin.removeEventListener(\"mousedown\", origin[mousedownListenerKey]);\n  }\n  if (target) {\n    origin[mousedownListenerKey] = (/** @type {MouseEvent} */ event) => {\n      // Only process events for the main (usually left) button.\n      if (event.button !== 0) {\n        return;\n      }\n      // What element wants the focus?\n      const desiredTarget = target[focusTarget] || target;\n      // What ancestor can actually take the focus?\n      const focusableTarget = closestFocusableNode(desiredTarget);\n      if (focusableTarget) {\n        focusableTarget.focus();\n        event.preventDefault();\n      }\n    };\n    origin.addEventListener(\"mousedown\", origin[mousedownListenerKey]);\n  }\n}\n\n/**\n * Search a list element for the item that contains the specified target.\n *\n * When dealing with UI events (e.g., mouse clicks) that may occur in\n * subelements inside a list item, you can use this routine to obtain the\n * containing list item.\n *\n * @param {NodeList|Node[]} items - A list element containing a set of items\n * @param {Node} target - A target element that may or may not be an item in the\n * list.\n * @returns {number} - The index of the list child that is or contains the\n * indicated target node. Returns -1 if not found.\n */\nexport function indexOfItemContainingTarget(items, target) {\n  return Array.prototype.findIndex.call(\n    items,\n    (/** @type Node */ item) => item === target || deepContains(item, target)\n  );\n}\n\n/**\n * Return true if the event came from within the node (or from the node itself);\n * false otherwise.\n *\n * @param {Node} node - The node to consider in relation to the event\n * @param {Event} event - The event which may have been raised within/by the\n * node\n * @returns {boolean} - True if the event was raised within or by the node\n */\nexport function ownEvent(node, event) {\n  /** @type {any} */\n  const cast = event;\n  const eventSource = cast.composedPath()[0];\n  return node === eventSource || deepContains(node, eventSource);\n}\n\n/**\n * Returns the set that includes the given node and all of its ancestors in the\n * composed tree. See [composedAncestors](#composedAncestors) for details on the\n * latter.\n *\n * @param {Node} node\n * @returns {Iterable<Node>}\n */\nexport function* selfAndComposedAncestors(node) {\n  if (node) {\n    yield node;\n    yield* composedAncestors(node);\n  }\n}\n\n/**\n * Set an internal state for browsers that support the `:state` selector, as\n * well as an attribute of the same name to permit state-based styling on older\n * browsers.\n *\n * When all browsers support that, we'd like to deprecate use of attributes.\n *\n * @param {Element} element\n * @param {string} name\n * @param {boolean} value\n */\nexport function setInternalState(element, name, value) {\n  element.toggleAttribute(name, value);\n  if (element[nativeInternals] && element[nativeInternals].states) {\n    element[nativeInternals].states.toggle(name, value);\n  }\n}\n\n/** @type {IndexedObject<boolean>} */\nexport const standardBooleanAttributes = {\n  checked: true,\n  defer: true,\n  disabled: true,\n  hidden: true,\n  ismap: true,\n  multiple: true,\n  noresize: true,\n  readonly: true,\n  selected: true,\n};\n\n/**\n * Adds or removes the element's `childNodes` as necessary to match the nodes\n * indicated in the `childNodes` parameter.\n *\n * This operation is useful in cases where you maintain your own set of nodes\n * which should be rendered as the children of some element. When you insert or\n * remove nodes in that set, you can invoke this function to efficiently apply\n * the new set as a delta to the existing children. Only the items in the set\n * that have actually changed will be added or removed.\n *\n * @param {Element} element - the element to update\n * @param {(NodeList|Node[])} childNodes - the set of nodes to apply\n */\nexport function updateChildNodes(element, childNodes) {\n  // If the childNodes parameter is the actual childNodes of an element, then as\n  // we append those nodes to the indicated target element, they'll get removed\n  // from the original set. To keep the list stable, we make a copy.\n  const copy = [...childNodes];\n\n  const oldLength = element.childNodes.length;\n  const newLength = copy.length;\n  const length = Math.max(oldLength, newLength);\n  for (let i = 0; i < length; i++) {\n    const oldChild = element.childNodes[i];\n    const newChild = copy[i];\n    if (i >= oldLength) {\n      // Add new item not in old set.\n      element.append(newChild);\n    } else if (i >= newLength) {\n      // Remove old item past end of new set.\n      element.removeChild(element.childNodes[newLength]);\n    } else if (oldChild !== newChild) {\n      if (copy.indexOf(oldChild, i) >= i) {\n        // Old node comes later in final set. Insert the new node rather than\n        // replacing it so that we don't detach the old node only to have to\n        // reattach it later.\n        element.insertBefore(newChild, oldChild);\n      } else {\n        // Replace old item with new item.\n        element.replaceChild(newChild, oldChild);\n      }\n    }\n  }\n}\n\n/**\n * Walk the composed tree at the root for elements that pass the given filter.\n *\n * Note: the jsDoc types required for the filter function are too complex for\n * the current jsDoc parser to support strong type-checking.\n *\n * @private\n * @param {Node} node\n * @param {function} filter\n * @returns {IterableIterator<Node>}\n */\nfunction* walkComposedTree(node, filter) {\n  if (filter(node)) {\n    yield node;\n  }\n  let children;\n  if (node instanceof HTMLElement && node.shadowRoot) {\n    // Walk the shadow instead of the light DOM.\n    children = node.shadowRoot.children;\n  } else {\n    const assignedNodes =\n      node instanceof HTMLSlotElement\n        ? node.assignedNodes({ flatten: true })\n        : [];\n    children =\n      assignedNodes.length > 0\n        ? // Walk light DOM nodes assigned to this slot.\n          assignedNodes\n        : // Walk light DOM children.\n          node.childNodes;\n  }\n  if (children) {\n    for (let i = 0; i < children.length; i++) {\n      yield* walkComposedTree(children[i], filter);\n    }\n  }\n}\n","import { booleanAttributeValue, standardBooleanAttributes } from \"./dom.js\";\nimport { rendering } from \"./internal.js\";\n\n// Memoized maps of attribute to property names and vice versa.\n// We initialize this with the special case of the tabindex (lowercase \"i\")\n// attribute, which is mapped to the tabIndex (capital \"I\") property.\n/** @type {IndexedObject<string>} */\nconst attributeToPropertyNames = {\n  tabindex: \"tabIndex\",\n};\n/** @type {IndexedObject<string>} */\nconst propertyNamesToAttributes = {\n  tabIndex: \"tabindex\",\n};\n\n/**\n * Sets properties when the corresponding attributes change\n *\n * If your component exposes a setter for a property, it's generally a good\n * idea to let devs using your component be able to set that property in HTML\n * via an element attribute. You can code that yourself by writing an\n * `attributeChangedCallback`, or you can use this mixin to get a degree of\n * automatic support.\n *\n * This mixin implements an `attributeChangedCallback` that will attempt to\n * convert a change in an element attribute into a call to the corresponding\n * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n * respects that convention, automatically mapping the hyphenated attribute\n * name to the corresponding camelCase property name.\n *\n * Example: You define a component using this mixin:\n *\n *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n *       get fooBar() { return this._fooBar; }\n *       set fooBar(value) { this._fooBar = value; }\n *     }\n *\n * If someone then instantiates your component in HTML:\n *\n *     <my-element foo-bar=\"Hello\"></my-element>\n *\n * Then, after the element has been upgraded, the `fooBar` setter will\n * automatically be invoked with the initial value \"Hello\".\n *\n * Attributes can only have string values. If you'd like to convert string\n * attributes to other types (numbers, booleans), you must implement parsing\n * yourself.\n *\n * @module AttributeMarshallingMixin\n * @param {Constructor<CustomElement>} Base\n */\nexport default function AttributeMarshallingMixin(Base) {\n  // The class prototype added by the mixin.\n  class AttributeMarshalling extends Base {\n    /**\n     * Handle a change to the attribute with the given name.\n     *\n     * @ignore\n     * @param {string} attributeName\n     * @param {string} oldValue\n     * @param {string} newValue\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(attributeName, oldValue, newValue);\n      }\n\n      // Sometimes this callback is invoked when there's not actually any\n      // change, in which we skip invoking the property setter.\n      //\n      // We also skip setting properties if we're rendering. A component may\n      // want to reflect property values to attributes during rendering, but\n      // such attribute changes shouldn't trigger property updates.\n      if (newValue !== oldValue && !this[rendering]) {\n        const propertyName = attributeToPropertyName(attributeName);\n        // If the attribute name corresponds to a property name, set the property.\n        if (propertyName in this) {\n          // Parse standard boolean attributes.\n          const parsed = standardBooleanAttributes[attributeName]\n            ? booleanAttributeValue(attributeName, newValue)\n            : newValue;\n          this[propertyName] = parsed;\n        }\n      }\n    }\n\n    // Because maintaining the mapping of attributes to properties is tedious,\n    // this provides a default implementation for `observedAttributes` that\n    // assumes that your component will want to expose all public properties in\n    // your component's API as properties.\n    //\n    // You can override this default implementation of `observedAttributes`. For\n    // example, if you have a system that can statically analyze which\n    // properties are available to your component, you could hand-author or\n    // programmatically generate a definition for `observedAttributes` that\n    // avoids the minor run-time performance cost of inspecting the component\n    // prototype to determine your component's public properties.\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n  }\n\n  return AttributeMarshalling;\n}\n\n/**\n * Return the custom attributes for the given class.\n *\n * E.g., if the supplied class defines a `fooBar` property, then the resulting\n * array of attribute names will include the \"foo-bar\" attribute.\n *\n * @private\n * @param {Constructor<HTMLElement>} classFn\n * @returns {string[]}\n */\nfunction attributesForClass(classFn) {\n  // We treat the HTMLElement base class as if it has no attributes, since we\n  // don't want to receive attributeChangedCallback for it (or anything further\n  // up the protoype chain).\n  if (classFn === HTMLElement) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n\n  // See if parent class defines observedAttributes manually.\n  let baseAttributes = baseClass.observedAttributes;\n  if (!baseAttributes) {\n    // Calculate parent class attributes ourselves.\n    baseAttributes = attributesForClass(baseClass);\n  }\n\n  // Get the properties for this particular class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter((propertyName) => {\n    const descriptor = Object.getOwnPropertyDescriptor(\n      classFn.prototype,\n      propertyName\n    );\n    return descriptor && typeof descriptor.set === \"function\";\n  });\n\n  // Map the property names to attribute names.\n  const attributes = setterNames.map((setterName) =>\n    propertyNameToAttribute(setterName)\n  );\n\n  // Merge the attribute for this class and its base class.\n  const diff = attributes.filter(\n    (attribute) => baseAttributes.indexOf(attribute) < 0\n  );\n  const result = baseAttributes.concat(diff);\n\n  return result;\n}\n\n/**\n * Convert hyphenated foo-bar attribute name to camel case fooBar property name.\n *\n * @private\n * @param {string} attributeName\n */\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hyphenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hyphenRegEx, (match) =>\n      match[1].toUpperCase()\n    );\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\n/**\n * Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\n *\n * @private\n * @param {string} propertyName\n */\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, \"-$1\").toLowerCase();\n    propertyNamesToAttributes[propertyName] = attribute;\n  }\n  return attribute;\n}\n","import {\n  defaultState,\n  firstRender,\n  raiseChangeEvents,\n  render,\n  renderChanges,\n  rendered,\n  rendering,\n  setState,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\n/** @type {any} */\nconst stateKey = Symbol(\"state\");\n/** @type {any} */\nconst raiseChangeEventsInNextRenderKey = Symbol(\n  \"raiseChangeEventsInNextRender\"\n);\n// Tracks total set of changes made to elements since their last render.\n/** @type {any} */\nconst changedSinceLastRenderKey = Symbol(\"changedSinceLastRender\");\n\n/**\n * Manages component state and renders changes in state\n *\n * This is modeled after React/Preact's state management, and is adapted for\n * use with web components. Applying this mixin to a component will give it\n * FRP behavior comparable to React's.\n *\n * This model is very basic. It's key aspects are:\n * * an immutable `state` property updated via `setState` calls.\n * * a `render` method that will be invoked asynchronously when state changes.\n *\n * @module ReactiveMixin\n * @param {Constructor<CustomElement>} Base\n */\nexport default function ReactiveMixin(Base) {\n  class Reactive extends Base {\n    constructor() {\n      super();\n\n      // Components can inspect `firstRender` during rendering to do special\n      // work the first time (like wire up event handlers). Until the first\n      // render actually happens, we set that flag to be undefined so we have a\n      // way of distinguishing between a component that has never rendered and\n      // one that is being rendered for the nth time.\n      this[firstRender] = undefined;\n\n      // We want to support the standard HTML pattern of only raising events in\n      // response to direct user interactions. For a detailed discussion of this\n      // point, see the Gold Standard checklist item for [Propery Change\n      // Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n      //\n      // To support this pattern, we define a flag indicating whether change\n      // events should be raised. By default, we want the flag to be false. In\n      // UI event handlers, a component can temporarily set the flag to true. If\n      // a setState call is made while the flag is true, then that fact will be\n      // remembered and passed the subsequent render/rendered methods. That will\n      // let the methods know whether they should raise property change events.\n      this[raiseChangeEvents] = false;\n\n      // Maintain a change log of all fields which have changed since the\n      // component was last rendered.\n      this[changedSinceLastRenderKey] = null;\n\n      // Set the initial state from the default state defined by the component\n      // and its mixins/base classes.\n      this[setState](this[defaultState]);\n    }\n\n    // When the component is attached to the document (or upgraded), we will\n    // generally render the component for the first time. That operation will\n    // include rendering of the default state and any state changes that\n    // happened between constructor time and this connectedCallback.\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      // Render the component.\n      //\n      // If the component was forced to render before this point, and the state\n      // hasn't changed, this call will be a no-op.\n      this[renderChanges]();\n    }\n\n    /**\n     * The default state for the component. This can be extended by mixins and\n     * classes to provide additional default state.\n     *\n     * @type {PlainObject}\n     */\n    // @ts-ignore\n    get [defaultState]() {\n      // Defer to base implementation if defined.\n      return super[defaultState] || {};\n    }\n\n    /**\n     * Render the indicated changes in state to the DOM.\n     *\n     * The default implementation of this method does nothing. Override this\n     * method in your component to update your component's host element and\n     * any shadow elements to reflect the component's new state. See the\n     * [rendering example](ReactiveMixin#rendering).\n     *\n     * Be sure to call `super` in your method implementation so that your\n     * component's base classes and mixins have a chance to perform their own\n     * render work.\n     *\n     * @param {ChangedFlags} changed - dictionary of flags indicating which state\n     * members have changed since the last render\n     */\n    [render](changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n    }\n\n    /**\n     * Render any pending component changes to the DOM.\n     *\n     * This method does nothing if the state has not changed since the last\n     * render call.\n     *\n     * ReactiveMixin will invoke this method following a `setState` call;\n     * you should not need to invoke this method yourself.\n     *\n     * This method invokes the internal `render` method, then invokes the\n     * `rendered` method.\n     */\n    [renderChanges]() {\n      if (this[firstRender] === undefined) {\n        // First render.\n        this[firstRender] = true;\n      }\n\n      // Get the log of which fields have changed since the last render.\n      const changed = this[changedSinceLastRenderKey];\n\n      // We only render if this is the first render, or state has changed since\n      // the last render.\n      if (this[firstRender] || changed) {\n        // If at least one of the[setState] calls was made in response\n        // to user interaction or some other component-internal event, set the\n        // raiseChangeEvents flag so that render/rendered methods know whether\n        // to raise property change events. See the comments in the component\n        // constructor where we initialize this flag for details.\n        const saveRaiseChangeEvents = this[raiseChangeEvents];\n        this[raiseChangeEvents] = this[raiseChangeEventsInNextRenderKey];\n\n        // We set a flag to indicate that rendering is happening. The component\n        // may use this to avoid triggering other updates during the render.\n        this[rendering] = true;\n\n        // Invoke any internal render implementations.\n        this[render](changed);\n\n        this[rendering] = false;\n\n        // Since we've now rendered all changes, clear the change log. If other\n        // async render calls are queued up behind this call, they'll see an\n        // empty change log, and so skip unnecessary render work.\n        this[changedSinceLastRenderKey] = null;\n\n        // Let the component know it was rendered.\n        this[rendered](changed);\n\n        // We've now rendered for the first time.\n        this[firstRender] = false;\n\n        // Restore state of event flags.\n        this[raiseChangeEvents] = saveRaiseChangeEvents;\n        this[raiseChangeEventsInNextRenderKey] = saveRaiseChangeEvents;\n      }\n    }\n\n    /**\n     * Perform any work that must happen after state changes have been rendered\n     * to the DOM.\n     *\n     * The default implementation of this method does nothing. Override this\n     * method in your component to perform work that requires the component to\n     * be fully rendered, such as setting focus on a shadow element or\n     * inspecting the computed style of an element. If such work should result\n     * in a change in component state, you can safely call `setState` during the\n     * `rendered` method.\n     *\n     * Be sure to call `super` in your method implementation so that your\n     * component's base classes and mixins have a chance to perform their own\n     * post-render work.\n     *\n     * @param {ChangedFlags} changed\n     */\n    [rendered](changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n    }\n\n    /**\n     * Update the component's state by merging the specified changes on\n     * top of the existing state. If the component is connected to the document,\n     * and the new state has changed, this returns a promise to asynchronously\n     * render the component. Otherwise, this returns a resolved promise.\n     *\n     * @param {PlainObject} changes - the changes to apply to the element's state\n     * @returns {Promise} - resolves when the new state has been rendered\n     */\n    async [setState](changes) {\n      // There's no good reason to have a render method update state.\n      if (this[rendering]) {\n        /* eslint-disable no-console */\n        console.warn(\n          `${this.constructor.name} called [setState] during rendering, which you should avoid.\\nSee https://elix.org/documentation/ReactiveMixin.`\n        );\n      }\n\n      // Apply the changes to a copy of the component's current state to produce\n      // a new, updated state and a dictionary of flags indicating which fields\n      // actually changed.\n      const { state, changed } = copyStateWithChanges(this, changes);\n\n      // We only need to apply the changes to the component state if: a) the\n      // current state is undefined (this is the first time setState has been\n      // called), or b) the supplied changes parameter actually contains\n      // substantive changes.\n      if (this[stateKey] && Object.keys(changed).length === 0) {\n        // No need to update state.\n        return;\n      }\n\n      // Freeze the new state so it's immutable. This prevents accidental\n      // attempts to set state without going through setState.\n      Object.freeze(state);\n\n      // Set this as the component's new state.\n      this[stateKey] = state;\n\n      // If setState was called with the raiseChangeEvents flag set, record that\n      // fact for use in rendering. See the comments in the component\n      // constructor for details.\n      if (this[raiseChangeEvents]) {\n        this[raiseChangeEventsInNextRenderKey] = true;\n      }\n\n      // Look to see whether the component is already set up to render.\n      const willRender =\n        this[firstRender] === undefined ||\n        this[changedSinceLastRenderKey] !== null;\n\n      // Add this round of changed fields to the complete log of fields that\n      // have changed since the component was last rendered.\n      this[changedSinceLastRenderKey] = Object.assign(\n        this[changedSinceLastRenderKey] || {},\n        changed\n      );\n\n      // We only need to queue a render if we're in the document and a render\n      // operation hasn't already been queued for this component. If we're not\n      // in the document yet, when the component is eventually added to the\n      // document, the connectedCallback will ensure we render at that point.\n      const needsRender = this.isConnected && !willRender;\n      if (needsRender) {\n        // Yield with promise timing. This lets any *synchronous* setState calls\n        // that happen after this current setState call complete first. Their\n        // effects on the state will be batched up, and accumulate in the change\n        // log stored under this[changedSinceLastRenderKey].\n        await Promise.resolve();\n\n        // Now that the above promise has resolved, render the component. By the\n        // time this line is reached, the complete log of batched changes can be\n        // applied in a single render call.\n        this[renderChanges]();\n      }\n    }\n\n    /**\n     * The component's current state.\n     *\n     * The returned state object is immutable. To update it, invoke\n     * `internal.setState`.\n     *\n     * It's extremely useful to be able to inspect component state while\n     * debugging. If you append `?elixdebug=true` to a page's URL, then\n     * ReactiveMixin will conditionally expose a public `state` property that\n     * returns the component's state. You can then access the state in your\n     * browser's debug console.\n     *\n     * @type {PlainObject}\n     */\n    get [state]() {\n      return this[stateKey];\n    }\n\n    /**\n     * Ask the component whether a state with a set of recently-changed fields\n     * implies that additional second-order changes should be applied to that\n     * state to make it consistent.\n     *\n     * This method is invoked during a call to `internal.setState` to give all\n     * of a component's mixins and classes a chance to respond to changes in\n     * state. If one mixin/class updates state that it controls, another\n     * mixin/class may want to respond by updating some other state member that\n     * *it* controls.\n     *\n     * This method should return a dictionary of changes that should be applied\n     * to the state. If the dictionary object is not empty, the\n     * `internal.setState` method will apply the changes to the state, and\n     * invoke this `stateEffects` method again to determine whether there are\n     * any third-order effects that should be applied. This process repeats\n     * until all mixins/classes report that they have no additional changes to\n     * make.\n     *\n     * See an example of how `ReactiveMixin` invokes the `stateEffects` to\n     * [ensure state consistency](ReactiveMixin#ensuring-state-consistency).\n     *\n     * @param {PlainObject} state - a proposal for a new state\n     * @param {ChangedFlags} changed - the set of fields changed in this\n     * latest proposal for the new state\n     * @returns {PlainObject}\n     */\n    [stateEffects](state, changed) {\n      return super[stateEffects] ? super[stateEffects](state, changed) : {};\n    }\n  }\n\n  // Expose state when debugging; see note for `[state]` getter.\n  const elixdebug = new URLSearchParams(location.search).get(\"elixdebug\");\n  if (elixdebug === \"true\") {\n    Object.defineProperty(Reactive.prototype, \"state\", {\n      get() {\n        return this[state];\n      },\n    });\n  }\n\n  return Reactive;\n}\n\n/**\n * Create a copy of the component's state with the indicated changes applied.\n * Ask the component whether the new state implies any second-order effects. If\n * so, apply those and loop again until the state has stabilized. Return the new\n * state and a dictionary of flags indicating which fields were actually\n * changed.\n *\n * @private\n * @param {Element} element\n * @param {PlainObject} changes\n */\nexport function copyStateWithChanges(element, changes) {\n  // Start with a copy of the current state.\n  /** @type {PlainObject} */\n  const state = Object.assign({}, element[stateKey]);\n  /** @type {ChangedFlags} */\n  const changed = {};\n  // Take the supplied changes as the first round of effects.\n  let effects = changes;\n  // Loop until there are no effects to apply.\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    // See whether the effects actually changed anything in state.\n    const changedByEffects = fieldsChanged(state, effects);\n    if (Object.keys(changedByEffects).length === 0) {\n      // No more effects to apply; we're done.\n      break;\n    }\n    // Apply the effects.\n    Object.assign(state, effects);\n    Object.assign(changed, changedByEffects);\n    // Ask the component if there are any second- (or third-, etc.) order\n    // effects that should be applied.\n    effects = element[stateEffects](state, changedByEffects);\n  }\n  return { state, changed };\n}\n\n/**\n * Return true if the two values are equal.\n *\n * @private\n * @param {any} value1\n * @param {any} value2\n * @returns {boolean}\n */\nfunction equal(value1, value2) {\n  if (value1 instanceof Date && value2 instanceof Date) {\n    return value1.getTime() === value2.getTime();\n  }\n  return value1 === value2;\n}\n\n/**\n * Return a dictionary of flags indicating which of the indicated changes to the\n * state are actually substantive changes.\n *\n * @private\n * @param {PlainObject} state\n * @param {PlainObject} changes\n */\nfunction fieldsChanged(state, changes) {\n  /** @type {ChangedFlags} */\n  const changed = {};\n  for (const field in changes) {\n    if (!equal(changes[field], state[field])) {\n      changed[field] = true;\n    }\n  }\n  return changed;\n}\n","import {\n  delegatesFocus,\n  hasDynamicTemplate,\n  ids,\n  render,\n  shadowRoot,\n  shadowRootMode,\n  template,\n} from \"./internal.js\";\n\n// A cache of processed templates, indexed by element class.\nconst classTemplateMap = new Map();\n\n// A Proxy that maps shadow element IDs to shadow elements.\n// This will be return as the element's `this[ids]` property;\n// see comments in that property below.\n/** @type {any} */\nconst shadowIdProxyKey = Symbol(\"shadowIdProxy\");\n\n// A reference stored on the shadow element proxy target to get to the actual\n// element. We use a Symbol here instead of a string name to avoid naming\n// conflicts with the element's internal shadow element IDs.\nconst proxyElementKey = Symbol(\"proxyElement\");\n\n// A handler used for the shadow element ID proxy.\nconst shadowIdProxyHandler = {\n  get(target, id) {\n    // From this proxy, obtain a reference to the original component.\n    const element = target[proxyElementKey];\n\n    // Get a reference to the component's open or closed shadow root.\n    const root = element[shadowRoot];\n\n    // Look for a shadow element with the indicated ID.\n    return root && typeof id === \"string\" ? root.getElementById(id) : null;\n  },\n};\n\n/**\n * Stamps a template into a component's Shadow DOM when instantiated\n *\n * To use this mixin, define a `template` method that returns a string or HTML\n * `<template>` element:\n *\n *     import { createElement, replace, transmute } from 'elix/src/template.js';\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       get [template]() {\n *         return templateFrom.html`Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` method, this\n * mixin has no effect.\n *\n * This adds a member on the component called `this[ids]` that can be used to\n * reference shadow elements with IDs. E.g., if component's shadow contains an\n * element `<button id=\"foo\">`, then this mixin will create a member\n * `this[ids].foo` that points to that button.\n *\n * @module ShadowTemplateMixin\n * @param {Constructor<HTMLElement>} Base\n */\nexport default function ShadowTemplateMixin(Base) {\n  // The class prototype added by the mixin.\n  class ShadowTemplate extends Base {\n    /**\n     * A convenient shortcut for looking up an element by ID in the component's\n     * Shadow DOM subtree.\n     *\n     * Example: if component's template contains a shadow element `<button\n     * id=\"foo\">`, you can use the reference `this[ids].foo` to obtain\n     * the corresponding button in the component instance's shadow tree. The\n     * `ids` property is simply a shorthand for `getElementById`, so\n     * `this[ids].foo` is the same as\n     * `this[shadowRoot].getElementById('foo')`.\n     *\n     * @type {object} - a dictionary mapping shadow element IDs to elements\n     */\n    get [ids]() {\n      if (!this[shadowIdProxyKey]) {\n        // Construct a proxy that maps to getElementById.\n        const target = {\n          // Give the proxy a means of refering to this element via the target.\n          [proxyElementKey]: this,\n        };\n        this[shadowIdProxyKey] = new Proxy(target, shadowIdProxyHandler);\n      }\n      return this[shadowIdProxyKey];\n    }\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      // We populate the shadow root if the component doesn't have a shadow;\n      // i.e., the first time the component is rendered. For this check, we use\n      // an internal reference we maintain for the shadow root; see below.\n      if (!this[shadowRoot]) {\n        // If this type of element defines a template, prepare it for use.\n        const template = getTemplate(this);\n\n        if (template) {\n          // Stamp the template into a new shadow root.\n          const root = this.attachShadow({\n            delegatesFocus: this[delegatesFocus],\n            mode: this[shadowRootMode],\n          });\n          const clone = document.importNode(template.content, true);\n          root.append(clone);\n\n          // After this call, we won't be able to rely on being able to access\n          // the shadow root via `this.shadowRoot`, because the component may\n          // have asked for a closed shadow root. We save a reference to the\n          // shadow root now so that the component always has a consistent means\n          // to reference its own shadow root.\n          this[shadowRoot] = root;\n        } else {\n          // No template. Set shadow root to null (instead of undefined) so we\n          // won't try to render shadow on next render.\n          this[shadowRoot] = null;\n        }\n      }\n    }\n\n    /**\n     * @type {ShadowRootMode}\n     * @default \"open\"\n     */\n    get [shadowRootMode]() {\n      return \"open\";\n    }\n  }\n\n  return ShadowTemplate;\n}\n\n/**\n * Return the template for the element being instantiated.\n *\n * If this is the first time we're creating this type of element, or the\n * component has indicated that its template is dynamic (and should be retrieved\n * each time), ask the component class for the template and cache the result.\n * Otherwise, immediately return the cached template.\n *\n * @private\n * @param {HTMLElement} element\n * @returns {HTMLTemplateElement}\n */\nfunction getTemplate(element) {\n  let t = element[hasDynamicTemplate]\n    ? undefined // Always retrieve template\n    : classTemplateMap.get(element.constructor); // See if we've cached it\n  if (t === undefined) {\n    // Ask the component for its template.\n    t = element[template];\n    // A component using this mixin isn't required to supply a template --\n    // if they don't, they simply won't end up with a shadow root.\n    if (t) {\n      // But if the component does supply a template, it needs to be an\n      // HTMLTemplateElement instance.\n      if (!(t instanceof HTMLTemplateElement)) {\n        throw `Warning: the [template] property for ${element.constructor.name} must return an HTMLTemplateElement.`;\n      }\n    }\n    if (!element[hasDynamicTemplate]) {\n      // Store prepared template for next creation of same type of element.\n      // If the component didn't define a template, store null so that we skip\n      // the template retrieval next time.\n      classTemplateMap.set(element.constructor, t || null);\n    }\n  }\n  return t;\n}\n","import AttributeMarshallingMixin from \"./AttributeMarshallingMixin.js\";\nimport ReactiveMixin from \"./ReactiveMixin.js\";\nimport ShadowTemplateMixin from \"./ShadowTemplateMixin.js\";\n\n/**\n * General-purpose base for writing components in functional-reactive style\n *\n * This base class lets you create web components in a functional-reactive\n * programming (FRP) style. It simply bundles a small set of mixins:\n *\n *     const ReactiveElement =\n *       AttributeMarshallingMixin(\n *       ReactiveMixin(\n *       ShadowTemplateMixin(\n *         HTMLElement\n *       )))));\n *\n * `ReactiveElement` is provided as a convenience. You can achieve the same\n * result by applying the mixins yourself to `HTMLElement`.\n *\n * @inherits HTMLElement\n * @mixes AttributeMarshallingMixin\n * @mixes ReactiveMixin\n * @mixes ShadowTemplateMixin\n */\nconst ReactiveElement = AttributeMarshallingMixin(\n  ReactiveMixin(ShadowTemplateMixin(HTMLElement))\n);\n\nexport default ReactiveElement;\n","import {\n  defaultState,\n  ids,\n  render,\n  setState,\n  state,\n  template,\n  raiseChangeEvents\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\nimport * as utils from '../lib/utils';\n\nexport default class WorkletColor extends ReactiveElement {\n\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      prop: null,\n      value: null\n    });\n  }\n\n  get prop() {\n    return this[state].prop;\n  }\n  set prop(prop) {\n    this[setState]({\n      prop: prop,\n    });\n  }\n\n  get value() {\n    return this[state].value;\n  }\n  set value(value) {\n    this[setState]({\n      value: value,\n    });\n  }\n\n  [render](changed) {\n    super[render](changed);\n    if (changed.prop && changed.value) {\n      const pickerEl = this[ids].picker;\n      const colorEl = this[ids].color;\n      const nameEl = this[ids].name;\n      const valueEl = this[ids].value;\n      pickerEl.setAttribute('value', this[state].value);\n      pickerEl.setAttribute('name', this[state].prop);\n      // nameEl.textContent = this[state].prop.replace(/(--sds-g-color-)(\\w+-)/g,'');\n      nameEl.textContent = this[state].prop;\n      valueEl.textContent = this[state].value;\n\n      // Set color styles\n      colorEl.style.setProperty('background-color', this[state].value);\n      this._checkContrast(colorEl, this[state].value);\n\n      // Update based on color picker\n      pickerEl.addEventListener(\"change\", (e) => {\n        const nameProp = pickerEl.getAttribute('name');\n        this[raiseChangeEvents] = true;\n        this[setState]({\n          value: e.target.value,\n        });\n        this[raiseChangeEvents] = false;\n        document.documentElement.style.setProperty(nameProp, e.target.value);\n        colorEl.style.setProperty('background-color', e.target.value);\n        valueEl.textContent = e.target.value;\n        this._checkContrast(colorEl, e.target.value);\n      });\n      pickerEl.select();\n    }\n  }\n\n  _checkContrast(el, value) {\n    if (utils.getContrast(value) === 'black') {\n      el.style.setProperty('color', 'rgba(0,0,0,0.8)');\n    } else {\n      el.style.setProperty('color', 'rgba(255,255,255,0.8)');\n    }\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <div>\n        <label id=\"prop\">\n          <input type=\"color\" id=\"picker\" name=\"\" value=\"#fff\">\n        </label>\n        <div id=\"color\">\n          <p id=\"name\"></p>\n          <p id=\"value\"></p>\n        </div>\n      </div>\n      <style>\n        div {\n          display: flex;\n          flex-direction: column;\n          position: relative;\n        }\n        div:hover #color {\n          transform: scale(1.05);\n          box-shadow: 0 8px 24px rgba(53,71,90,.2);\n          z-index: 1;\n          border-radius: 4px;\n          background-clip: border-box;\n        }\n        div:hover #prop,\n        div:hover #name {\n          visibility: visible;\n          opacity: 1;\n        }\n        div:hover #name {\n          transform: translate3d(-50%,-110%,0);\n        }\n        div:hover #value {\n          transform: translateY(-10px);\n        }\n        #color {\n          display: flex;\n          height: var(--columnSize);\n          width: var(--columnSize);\n          justify-content: center;\n          align-content: center;\n          align-items: center;\n          transition: transform .2s cubic-bezier(0.23, 1, 0.32, 1), box-shadow .2s cubic-bezier(0.23, 1, 0.32, 1);\n        }\n        #prop {\n          position: absolute;\n          bottom: 1rem;\n          left: 50%;\n          transform: translateX(-50%);\n          z-index: 2;\n          transition: visibility .2s ease, opacity .2s ease;\n          visibility: hidden;\n          opacity: 0;\n        }\n        #name {\n          margin: 0;\n          font-size: 0.75rem;\n          position: absolute;\n          top: 0;\n          left: 50%;\n          transform: translate3d(-50%,-80%,0);\n          background: var(--sds-g-color-neutral-base-1);\n          color: var(--sds-g-color-neutral-base-contrast-3);\n          padding: 2px 6px;\n          border-radius: 3px;\n          box-shadow: 0 3px 12px rgba(53,71,90,.2);\n          visibility: hidden;\n          white-space: nowrap;\n          opacity: 0;\n          transition: visibility .2s ease, opacity .2s ease, transform .35s cubic-bezier(0.23, 1, 0.32, 1);\n        }\n        #name:before {\n          width: 0.5rem;\n          height: 0.5rem;\n          position: absolute;\n          transform: rotate(45deg);\n          content: \"\";\n          background-color: var(--sds-g-color-neutral-base-1);\n          z-index: -1;\n          bottom: -0.25rem;\n          left: 50%;\n          margin-left: -0.25rem;\n        }\n        #value {\n          font-size: 0.875rem;\n          font-weight: bold;\n          -webkit-font-smoothing: antialiased;\n          -moz-osx-font-smoothing: grayscale;\n          transition: transform .25s cubic-bezier(0.23, 1, 0.32, 1);\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define('worklet-color', WorkletColor);","const getContrast = (c) => {\n  c = c.replace(\"#\", \"\");\n  var r = parseInt(c.substr(0, 2), 16);\n  var g = parseInt(c.substr(2, 2), 16);\n  var b = parseInt(c.substr(4, 2), 16);\n  var yiq = (r * 299 + g * 587 + b * 114) / 1000;\n  return yiq >= 128 ? \"black\" : \"white\";\n};\n\nconst rgbToHex = (a) => {\n  a = a.replace(/[^\\d,]/g, \"\").split(\",\");\n  return (\n    \"#\" +\n    ((1 << 24) + (+a[0] << 16) + (+a[1] << 8) + +a[2]).toString(16).slice(1)\n  );\n};\n\nexport { getContrast, rgbToHex };\n","import {\n  defaultState,\n  ids,\n  render,\n  state,\n  template,\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\nimport * as utils from \"../lib/utils\";\n\nexport default class WorkletColors extends ReactiveElement {\n  constructor() {\n    super();\n    this._getProps();\n  }\n\n  _getProps() {\n    const targetNode = document.documentElement.computedStyleMap();\n    targetNode.forEach((el, prop, arr) => {\n      const value = getComputedStyle(document.documentElement).getPropertyValue(\n        prop\n      );\n      this[state].props.push({ prop, value: utils.rgbToHex(value) });\n    });\n  }\n\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      props: [],\n      hooks: null,\n    });\n  }\n\n  [render](changed) {\n    super[render](changed);\n    if (changed.props) {\n      const { props } = this[state];\n      const results = this[ids].results;\n      const hooks = props.filter((props) => /(^--.+)/.test(props.prop));\n      for (let hook of hooks) {\n        results.insertAdjacentHTML(\n          \"afterbegin\",\n          `<worklet-color prop=${hook.prop} value=${hook.value}></worklet-color>`\n        );\n      }\n    }\n  }\n  get [template]() {\n    return templateFrom.html`\n      <div id=\"results\"></div>\n      <style>\n        div {\n          display: grid;\n          grid-template-columns: repeat(8, minmax(100px, 150px));\n          margin: 1rem 0;\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"worklet-colors\", WorkletColors);\n","import {\n  defaultState,\n  ids,\n  render,\n  setState,\n  state,\n  template\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletCss extends ReactiveElement {\n  constructor() {\n    super();\n    this._getProps(props => {\n      this[setState]({\n        css: props.replace(/(;)/g, ';\\n')\n      })\n    });\n  }\n\n  _getProps(cb) {\n    const targetNode = document.documentElement;\n    const observerOptions = { attributes: true }\n    const observer = new MutationObserver(callback);\n    observer.observe(targetNode, observerOptions);\n\n    function callback(mutationList, observer) {\n      mutationList.forEach((mutation) => {\n        switch(mutation.type) {\n          case 'attributes':\n            if (mutation.attributeName === 'style') {\n              if (typeof cb === \"function\") cb(targetNode.style.cssText);\n            }\n            break;\n        }\n      });\n    }\n  }\n\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      css: ''\n    });\n  }\n\n  [render](changed) {\n    super[render](changed);\n    if (changed.css) {\n      const textarea = this[ids].css;\n      textarea.innerHTML = `:root {\\n /* SDS overrides below */\\n ${this[state].css}}`;\n    }\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <sds-button variant=\"neutral\">Copy CSS</sds-button>\n      <textarea id=\"css\"></textarea>\n      <style>\n        textarea {\n          background: var(--sds-g-color-neutral-base-1);\n          box-sizing: border-box;\n          height: 250px;\n          width: 100%;\n          padding: 1rem;\n          border: 0;\n          border-radius: 6px;\n          resize: vertical;\n          margin: 1rem 0;\n          min-height: 100px;\n          height: auto;\n        }\n        ::part(button) {\n          position: absolute;\n          top: 10px;\n          right: 50px;\n          z-index: 3;\n          font-size: 0.75rem;\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define('worklet-css', WorkletCss);","import { defaultState, template } from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletPreview extends ReactiveElement {\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      component: null,\n    });\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <div id=\"toolbar\">\n        <label for=\"component-select\">Select a component:</label>\n        <sds-select name=\"components\" id=\"component-select\">\n          <div value=\"accordion\">Accordion</div>\n          <div value=\"badge\">Badge</div>\n          <div value=\"breadcrumb\">Breadcrumb</div>\n          <div value=\"button\">Button</div>\n          <div value=\"card\">Card</div>\n          <div value=\"combobox\">Combobox</div>\n          <div value=\"dialog\">Dialog</div>\n          <div value=\"icon\">Icon</div>\n          <div value=\"input-checkbox\">Input Checkbox</div>\n          <div value=\"input-date\">Input Date</div>\n          <div value=\"input-file\">Input File</div>\n          <div value=\"input-text\">Input Text</div>\n          <div value=\"input-radio\">Input Radio</div>\n          <div value=\"input-range\">Input Range</div>\n          <div value=\"menu\">Menu</div>\n          <div value=\"summary-detail\">Summary Detail</div>\n          <div value=\"listbox\">Listbox</div>\n          <div value=\"tabset\">Tabset</div>\n        </sds-select>\n      </div>\n      <div id=\"preview\">\n        <sds-button>Button</sds-button>\n        <sds-button variant=\"neutral\">Button</sds-button>\n        <sds-button variant=\"brand\">Button</sds-button>\n      </div>\n      <div id=\"component-props\">\n        <h4>Styling Hooks Available</h4>\n        <p><strong>Global</strong></p>\n        <ul>\n          <li><code>--sds-g-color-neutral-base-1</code></li>\n          <li><code>--sds-g-color-neutral-base-contrast-1</code></li>\n          <li><code>--sds-g-color-brand-base-contrast-2</code></li>\n          <li><code>--sds-g-color-brand-base-contrast-3</code></li>\n          <li><code>--sds-g-color-brand-inverse-contrast-4</code></li>\n        </ul>\n        <p><strong>Shared</strong></p>\n        <ul>\n          <li><code>--sds-s-button-color-background</code></li>\n          <li><code>--sds-s-button-text-color</code></li>\n        </ul>\n        <p><strong>Local</strong></p>\n        <ul>\n          <li><code>--sds-c-button-color-background</code></li>\n          <li><code>--sds-c-button-text-color</code></li>\n        </ul>\n      </div>\n      <style>\n        :host {\n          font-size: 0.75rem;\n        }\n        #toolbar {\n          border-top-left-radius: 6px;\n          border-top-right-radius: 6px;\n          background: var(--sds-g-color-neutral-base-1);\n          border-bottom: 1px solid var(--sds-g-color-neutral-base-3);\n          padding: 0.5rem;\n          margin-top: 1rem;\n        }\n        label {\n          color: var(--sds-g-color-neutral-base-contrast-2);\n        }\n        #preview {\n          background: white;\n          padding: 2rem;\n          position: sticky;\n          top: var(--headerHeight);\n        }\n        #component-props {\n          background: var(--sds-g-color-neutral-base-1);\n          border-top: 1px solid var(--sds-g-color-neutral-base-3);\n          padding: 0 0.5rem;\n          border-bottom-left-radius: 6px;\n          border-bottom-right-radius: 6px;\n          max-height: 300px;\n          overflow-y: auto;\n        }\n        h4 {\n          color: var(--sds-g-color-neutral-base-contrast-2);\n        }\n        p {\n          margin: 0;\n        }\n        code {\n          font-size: 1rem;\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"worklet-preview\", WorkletPreview);\n","import {\n  defaultState,\n  render,\n  ids,\n  setState,\n  state,\n  template,\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletHeader extends ReactiveElement {\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      page: null,\n      nav: null,\n    });\n  }\n  get page() {\n    return this[state].page;\n  }\n  set page(page) {\n    this[setState]({\n      page: page,\n    });\n  }\n\n  [render](changed) {\n    super[render](changed);\n  }\n  get [template]() {\n    return templateFrom.html`\n      <header>\n        <h1>Styling Hooks Worklets and APIs</h1>\n        <span>→</span>\n        <sds-select id=\"nav\" selectedItem=${this[state].page}>\n          <div value=\"api\">CSS Properties and Values API</div>\n          <div value=\"paint\">CSS Painting API</div>\n          <div value=\"layout\">CSS Layout API</div>\n          <div value=\"animation\">Animation API</div>\n        </sds-select>\n        <a rel=\"github\" href=\"https://github.com/brandonferrua/test-houdini-hooks\">\n          <svg version=\"1.1\" viewBox=\"0 0 33 32\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n          <defs>\n            <polygon id=\"a\" points=\"8.1315e-20 -3.5527e-15 8.1315e-20 31.775 32.579 31.775 32.579 3.5527e-15\"/>\n          </defs>\n          <g fill-rule=\"evenodd\">\n          <mask id=\"b\" fill=\"white\"><use xlink:href=\"#a\"/></mask>\n          <path d=\"m16.289-3.5527e-15c-8.995 0-16.289 7.293-16.289 16.291 0 7.196 4.667 13.301 11.141 15.456 0.815 0.149 1.112-0.354 1.112-0.786 0-0.386-0.014-1.411-0.022-2.77-4.531 0.984-5.487-2.184-5.487-2.184-0.741-1.882-1.809-2.382-1.809-2.382-1.479-1.011 0.112-0.991 0.112-0.991 1.635 0.116 2.495 1.679 2.495 1.679 1.453 2.489 3.812 1.77 4.741 1.354 0.148-1.053 0.568-1.771 1.034-2.178-3.617-0.411-7.42-1.809-7.42-8.051 0-1.778 0.635-3.232 1.677-4.371-0.168-0.412-0.727-2.068 0.159-4.311 0 0 1.368-0.438 4.48 1.67 1.299-0.362 2.693-0.542 4.078-0.549 1.383 7e-3 2.777 0.187 4.078 0.549 3.11-2.108 4.475-1.67 4.475-1.67 0.889 2.243 0.33 3.899 0.162 4.311 1.044 1.139 1.675 2.593 1.675 4.371 0 6.258-3.809 7.635-7.438 8.038 0.585 0.503 1.106 1.497 1.106 3.017 0 2.177-0.02 3.934-0.02 4.468 0 0.436 0.293 0.943 1.12 0.784 6.467-2.159 11.131-8.26 11.131-15.454 0-8.998-7.294-16.291-16.291-16.291\" mask=\"url(#b)\"/>\n          </g>\n          </svg>\n        </a>\n      </header>\n      <style>\n        header {\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          display: flex;\n          height: var(--headerHeight);\n          align-items: center;\n          z-index: 2;\n          background: var(--sds-g-color-neutral-base-1);\n          padding: 0 1rem;\n        }\n        h1 {\n          font-size: 0.75rem;\n        }\n        span {\n          padding: 0 0.5rem;\n        }\n        [rel=\"github\"] {\n          margin-left: auto;\n          width: 20px;\n          fill: var(--sds-g-color-brand-base-contrast-2);\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"worklet-header-bar\", WorkletHeader);\n","import { ids, render, template } from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletRipple extends ReactiveElement {\n  [render](changed) {\n    super[render](changed);\n    const canvas = this[ids].canvas;\n    let start = performance.now();\n    let x, y;\n    canvas.addEventListener(\"click\", (e) => {\n      canvas.setAttribute(\"animating\", true);\n      [x, y] = [e.offsetX, e.offsetY];\n      start = performance.now();\n      requestAnimationFrame(function raf(now) {\n        const count = Math.floor(now - start);\n        canvas.style.cssText = `--ripple-x: ${x}; --ripple-y: ${y}; --animation-tick: ${count}; `;\n        if (count > 1000) {\n          canvas.removeAttribute(\"animating\");\n          canvas.style.cssText = `--animation-tick: 0`;\n          return;\n        }\n        requestAnimationFrame(raf);\n      });\n    });\n  }\n  get [template]() {\n    return templateFrom.html`\n      <div id=\"canvas\"></div>\n      <style>\n        :host {\n          display: block;\n          width: 100%;\n          height: 100%;\n          position: relative;\n        }\n        ::part(button) {\n          background-image: paint(ripple);\n        }\n        #canvas {\n          width: 100%;\n          height: 100%;\n          background-color: var(--sds-g-color-brand-base-contrast-2);\n          display: flex;\n          justify-content: space-around;\n          align-items: center;\n          color: white;\n          text-align: center;\n          cursor: pointer;\n\n          /* Required for animation by the worklet */\n          --ripple-x: 0;\n          --ripple-y: 0;\n          --ripple-color: var(--sds-g-color-brand-inverse-contrast-2);\n          --animation-tick: 0;\n        }\n        #canvas[animating=\"true\"] {\n          background-image: paint(ripple);\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"worklet-ripple\", WorkletRipple);\n","import { template } from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class SdsButton extends ReactiveElement {\n  get [template]() {\n    return templateFrom.html`\n      <button part=\"button\">\n        <slot name=\"start\"></slot>\n        <slot></slot>\n        <slot name=\"end\"></slot>\n      </button>\n      <style>\n        @import url('/src/components/Button.css');\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"sds-button\", SdsButton);\n","/**\n * Helpers for dynamically creating and patching component templates.\n *\n * The [ShadowTemplateMixin](ShadowTemplateMixin) lets you define a component\n * template that will be used to popuplate the shadow subtree of new component\n * instances. These helpers, especially the [html](#html) function, are intended\n * to simplify the creation of such templates.\n *\n * In particular, these helpers can be useful in [patching\n * templates](customizing#template-patching) inherited from a base class.\n *\n * Some of these functions take _descriptors_ that can either be a class, a tag\n * name, or an HTML template. These are generally used to fill specific roles in\n * an element's template; see [element roles](customizing#element-part-types).\n *\n * @module template\n */\n\nimport { templateFrom } from \"./htmlLiterals.js\";\n\n// Used by registerCustomElement.\nconst mapBaseTagToCount = new Map();\n\n/**\n * Create an element from a role descriptor (a component class constructor or\n * an HTML tag name).\n *\n * If the descriptor is an HTML template, and the resulting document fragment\n * contains a single top-level node, that node is returned directly (instead of\n * the fragment).\n *\n * @param {PartDescriptor} descriptor - the descriptor that will be used to\n * create the element\n * @returns {Element} the new element\n */\nexport function createElement(descriptor) {\n  if (typeof descriptor === \"function\") {\n    // Instantiable component class constructor\n    let element;\n    try {\n      element = new descriptor();\n    } catch (e) {\n      if (e.name === \"TypeError\") {\n        // Most likely this error results from the fact that the indicated\n        // component class hasn't been registered. Register it now with a random\n        // name and try again.\n        registerCustomElement(descriptor);\n        element = new descriptor();\n      } else {\n        // The exception was for some other reason.\n        throw e;\n      }\n    }\n    return element;\n    // @ts-ignore\n  } else {\n    // String tag name: e.g., 'div'\n    return document.createElement(descriptor);\n  }\n}\n\nexport function html(strings, ...substitutions) {\n  /* eslint-disable no-console */\n  console.warn(\n    `The template.html helper has moved to htmlLiterals.js, and is now called \\`templateFrom.html\\`. Please update your imports.`\n  );\n  return templateFrom.html(strings, ...substitutions);\n}\n\n/**\n * Register the indicated constructor as a custom element class.\n *\n * This function generates a suitable string tag for the class. If the\n * constructor is a named function (which is typical for hand-authored code),\n * the function's `name` will be used as the base for the tag. If the\n * constructor is an anonymous function (which often happens in\n * generated/minified code), the tag base will be \"custom-element\".\n *\n * In either case, this function adds a uniquifying number to the end of the\n * base to produce a complete tag.\n *\n * @private\n * @param {Constructor<HTMLElement>} classFn\n */\nfunction registerCustomElement(classFn) {\n  let baseTag;\n  // HTML places more restrictions on the first character in a tag than\n  // JavaScript places on the first character of a class name. We apply this\n  // more restrictive condition to the class names we'll convert to tags. Class\n  // names that fail this check -- often generated class names -- will result in\n  // a base tag name of \"custom-element\".\n  const classNameRegex = /^[A-Za-z][A-Za-z0-9_$]*$/;\n  const classNameMatch = classFn.name && classFn.name.match(classNameRegex);\n  if (classNameMatch) {\n    // Given the class name `FooBar`, calculate the base tag name `foo-bar`.\n    const className = classNameMatch[0];\n    const uppercaseRegEx = /([A-Z])/g;\n    const hyphenated = className.replace(\n      uppercaseRegEx,\n      (match, letter, offset) => (offset > 0 ? `-${letter}` : letter)\n    );\n    baseTag = hyphenated.toLowerCase();\n  } else {\n    baseTag = \"custom-element\";\n  }\n  // Add a uniquifying number to the end of the tag until we find a tag\n  // that hasn't been registered yet.\n  let count = mapBaseTagToCount.get(baseTag) || 0;\n  let tag;\n  for (; ; count++) {\n    tag = `${baseTag}-${count}`;\n    if (!customElements.get(tag)) {\n      // Not in use.\n      break;\n    }\n  }\n  // Register with the generated tag.\n  customElements.define(tag, /** @type {any} */ classFn);\n  // Bump number and remember it. If we see the same base tag again later, we'll\n  // start counting at that number in our search for a uniquifying number.\n  mapBaseTagToCount.set(baseTag, count + 1);\n}\n\n/**\n * Replace an original node in a tree or document fragment with the indicated\n * replacement node. The attributes, classes, styles, and child nodes of the\n * original node will be moved to the replacement.\n *\n * @param {Node} original - an existing node to be replaced\n * @param {Node} replacement - the node to replace the existing node with\n * @returns {Node} the updated replacement node\n */\nexport function replace(original, replacement) {\n  const parent = original.parentNode;\n  if (!parent) {\n    throw \"An element must have a parent before it can be substituted.\";\n  }\n  if (\n    (original instanceof HTMLElement || original instanceof SVGElement) &&\n    (replacement instanceof HTMLElement || replacement instanceof SVGElement)\n  ) {\n    // Merge attributes from original to replacement, letting replacement win\n    // conflicts. Handle classes and styles separately (below).\n    Array.prototype.forEach.call(original.attributes, (\n      /** @type {Attr} */ attribute\n    ) => {\n      if (\n        !replacement.getAttribute(attribute.name) &&\n        attribute.name !== \"class\" &&\n        attribute.name !== \"style\"\n      ) {\n        replacement.setAttribute(attribute.name, attribute.value);\n      }\n    });\n    // Copy classes/styles from original to replacement, letting replacement win\n    // conflicts.\n    Array.prototype.forEach.call(original.classList, (\n      /** @type {string} */ className\n    ) => {\n      replacement.classList.add(className);\n    });\n    Array.prototype.forEach.call(original.style, (\n      /** @type {number} */ key\n    ) => {\n      if (!replacement.style[key]) {\n        replacement.style[key] = original.style[key];\n      }\n    });\n  }\n  // Copy over children.\n  // @ts-ignore\n  replacement.append(...original.childNodes);\n\n  parent.replaceChild(replacement, original);\n  return replacement;\n}\n\n/**\n * Replace a node with a new element, transferring all attributes, classes,\n * styles, and child nodes from the original(s) to the replacement(s).\n *\n * The descriptor used for the replacements can be a 1) component class\n * constructor, 2) an HTML tag name, or 3) an HTML template. For #1 and #2, if\n * the existing elements that match the selector are already of the desired\n * class/tag name, the replacement operation is skipped.\n *\n * @param {Element} original - the node to replace\n * @param {PartDescriptor} descriptor - the descriptor used to generate the\n * replacement element\n * @returns {Element} the replacement node(s)\n */\nexport function transmute(original, descriptor) {\n  if (\n    (typeof descriptor === \"function\" && original.constructor === descriptor) ||\n    (typeof descriptor === \"string\" &&\n      original instanceof Element &&\n      original.localName === descriptor)\n  ) {\n    // Already correct type of element, no transmutation necessary.\n    return original;\n  } else {\n    // Transmute the single node.\n    const replacement = createElement(descriptor);\n    replace(original, replacement);\n    return replacement;\n  }\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  firstRender,\n  inputDelegate,\n  raiseChangeEvents,\n  render,\n  rendered,\n  setState,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\n/**\n * Delegates its ARIA label property to an inner input-type element.\n *\n * This helps ensure that elements built around an inner input element provide a\n * proper accessible label for assistive technologies like screen readers.\n *\n * You can identify which inner input element selection should be delegated to\n * by defining an `internal.inputDelegate` property and returning the desired\n * inner input.\n *\n * @module DelegateInputLabelMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function DelegateInputLabelMixin(Base) {\n  // The class prototype added by the mixin.\n  class DelegateInputLabel extends Base {\n    // Forward any ARIA label to the input element.\n    get ariaLabel() {\n      return this[state].ariaLabel;\n    }\n    set ariaLabel(ariaLabel) {\n      if (!this[state].removingAriaAttribute) {\n        this[setState]({\n          ariaLabel: String(ariaLabel),\n        });\n      }\n    }\n\n    // Forward ARIA labelledby as an aria-label to the input element.\n    // Note the lowercase \"b\" in the name, necessary to support the actual\n    // attribute name \"aria-labelledby\", which has no hyphen before the \"by\".\n    get ariaLabelledby() {\n      return this[state].ariaLabelledby;\n    }\n    set ariaLabelledby(ariaLabelledby) {\n      if (!this[state].removingAriaAttribute) {\n        this[setState]({\n          ariaLabelledby: String(ariaLabelledby),\n        });\n      }\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        ariaLabel: null,\n        ariaLabelledby: null,\n        inputLabel: null,\n        removingAriaAttribute: false,\n      });\n    }\n\n    [render](changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      if (this[firstRender]) {\n        // Refresh the input label on focus. This refresh appears to happen fast\n        // enough that the screen reader will announce the refreshed label.\n        this.addEventListener(\"focus\", () => {\n          this[raiseChangeEvents] = true;\n          const inputLabel = refreshInputLabel(this, this[state]);\n          this[setState]({ inputLabel });\n          this[raiseChangeEvents] = false;\n        });\n      }\n\n      // Apply the latest input label to the input delegate.\n      if (changed.inputLabel) {\n        const { inputLabel } = this[state];\n        if (inputLabel) {\n          this[inputDelegate].setAttribute(\"aria-label\", inputLabel);\n        } else {\n          this[inputDelegate].removeAttribute(\"aria-label\");\n        }\n      }\n    }\n\n    [rendered](changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (this[firstRender]) {\n        // Refresh the label on first render. This is not guaranteed to pick up\n        // labels defined by another element, as that element (or elements) may\n        // not be in the DOM yet. For that reason, we'll also refresh the label\n        // on focus. The reason to do it now is to handle the common cases where\n        // the element defining the label does exist so that accessibility\n        // testing tools can confirm that the input delegate does have a label.\n        // Because this refresh can entail multiple searches of the tree, we\n        // defer the refresh to idle time.\n        // @ts-ignore\n        const idleCallback = window.requestIdleCallback || setTimeout;\n        idleCallback(() => {\n          const inputLabel = refreshInputLabel(this, this[state]);\n          this[setState]({ inputLabel });\n        });\n      }\n\n      // Once we've obtained an aria-label or aria-labelledby from the host, we\n      // remove those attirbutes so that the labels don't get announced twice.\n      // We use a flag to distinguish between us removing our own ARIA\n      // attributes (which should not update state), and someone removing\n      // those attributes from the outside (which should update state).\n      const { ariaLabel, ariaLabelledby } = this[state];\n      if (changed.ariaLabel && !this[state].removingAriaAttribute) {\n        if (this.getAttribute(\"aria-label\")) {\n          this.setAttribute(\"delegated-label\", ariaLabel);\n          this[setState]({ removingAriaAttribute: true });\n          this.removeAttribute(\"aria-label\");\n        }\n      }\n      if (changed.ariaLabelledby && !this[state].removingAriaAttribute) {\n        if (this.getAttribute(\"aria-labelledby\")) {\n          this.setAttribute(\"delegated-labelledby\", ariaLabelledby);\n          this[setState]({ removingAriaAttribute: true });\n          this.removeAttribute(\"aria-labelledby\");\n        }\n      }\n\n      if (changed.removingAriaAttribute && this[state].removingAriaAttribute) {\n        // We've done whatever removal we needed, and can now reset our flag.\n        this[setState]({ removingAriaAttribute: false });\n      }\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // If the ariaLabel changes, we can update our inputLabel state\n      // immediately. Among other things, this facilitates scenarios where we\n      // have nested elements using DelegateInputLabelMixin: the outermost\n      // element can use whatever label approach it wants, the inner elements\n      // will all use ariaLabel.\n      //\n      // We also update the label if we're focused, using ariaLabelledby, and\n      // the selectedText changes. One pattern with select-like elements is to\n      // have them include their own ID in the IDs specified by aria-labelledby.\n      // This can incorporate the element's own `selectedText` in the announced\n      // label. That `selectedText` can change while the element has focus, in\n      // which case we'll refresh.\n      if (\n        (changed.ariaLabel && state.ariaLabel) ||\n        (changed.selectedText &&\n          state.ariaLabelledby &&\n          this.matches(\":focus-within\"))\n      ) {\n        const inputLabel = refreshInputLabel(this, state);\n        Object.assign(effects, { inputLabel });\n      }\n\n      return effects;\n    }\n  }\n\n  return DelegateInputLabel;\n}\n\n// Given an element that is being used as a label, extract its label text.\nfunction getLabelFromElement(element) {\n  // We use innerText here instead of textContent because we want the rendered\n  // text. If, e.g., a text node includes a span with `display: none`,\n  // textContent would include that hidden text, but innerText would leave it\n  // out -- which is what we want here.\n  if (\"selectedText\" in element) {\n    // Element (most likely Elix) with selectedText property\n    return element.selectedText;\n  } else if (\"value\" in element && \"options\" in element) {\n    // select or select-like element\n    const value = element.value;\n    const option = element.options.find((option) => option.value === value);\n    return option ? option.innerText : \"\";\n  } else if (\"value\" in element) {\n    // Other input element\n    return element.value;\n  } else {\n    // Other\n    return element.innerText;\n  }\n}\n\n/**\n * Calculate an appropriate label for the component's delegated input element.\n * When the element gets the focus, we refresh its label. This is done because\n * three of the labeling strategies (`aria-labelledby` attribute, `for`\n * attribute, and wrapping `label`) reference other elements in the tree -- and\n * the contents of those elements can change dynamically.\n *\n * @private\n * @param {HTMLElement} element\n * @param {PlainObject} state\n */\nfunction refreshInputLabel(element, state) {\n  const { ariaLabel, ariaLabelledby } = state;\n  /** @type {any} */ const rootNode = element.isConnected\n    ? element.getRootNode()\n    : null;\n  let inputLabel = null;\n\n  // Prefer aria-labelledby over aria-label, per\n  // https://developers.google.com/web/fundamentals/accessibility/semantics-aria/aria-labels-and-relationships.\n  // After that, we prefer a `label` element with a `for` attribute, and finally\n  // a wrapping `label` element.\n  //\n  // There do not appear to be consistent cross-browser rules for handling\n  // multiple forms of label assignment on the same component. E.g., if you\n  // place an element in a wrapping label *and* point a `label` element at that\n  // element with a `for` attribute, as of August 2020 Chrome and Firefox will\n  // announce both, but Safari will only announce the `for` label.\n  //\n  // Since people are probably not relying upon specific results for multiple\n  // forms of label assignment, we don't attempt to construct a combined label\n  // in those cases.\n  if (ariaLabelledby && rootNode) {\n    // Collect labels from elements with the indicated IDs.\n    const ids = ariaLabelledby.split(\" \");\n    const labels = ids.map((id) => {\n      const elementWithId = rootNode.getElementById(id);\n      // Get a label from the indicated element.\n      // Special case: if the element is providing its own label, we return its\n      // current `selectedText` state.\n      const label = !elementWithId\n        ? \"\"\n        : elementWithId === element && state.value !== null\n        ? state.selectedText\n        : getLabelFromElement(elementWithId);\n      return label;\n    });\n    inputLabel = labels.join(\" \");\n  } else if (ariaLabel) {\n    // Use ariaLabel property as input label.\n    inputLabel = ariaLabel;\n  } else if (rootNode) {\n    const id = element.id;\n    if (id) {\n      // Look for labelling element with `for` attribute.\n      const elementWithFor = rootNode.querySelector(`[for=\"${id}\"]`);\n      if (elementWithFor instanceof HTMLElement) {\n        // Obtain label from wrapping label element.\n        inputLabel = getLabelFromElement(elementWithFor);\n      }\n    }\n    if (inputLabel === null) {\n      // Last option is to look for closest wrapping label element.\n      const labelElement = element.closest(\"label\");\n      if (labelElement) {\n        inputLabel = getLabelFromElement(labelElement);\n      }\n    }\n  }\n\n  if (inputLabel) {\n    inputLabel = inputLabel.trim();\n  }\n\n  return inputLabel;\n}\n","import { deepContains } from \"../core/dom.js\";\nimport { fragmentFrom, templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { defaultState, render, setState, state, template } from \"./internal.js\";\n\n// We consider the keyboard to be active if the window has received a keydown\n// event since the last mousedown event.\nlet keyboardActive = false;\n\n/** @type {any} */\nconst focusVisibleChangedListenerKey = Symbol(\"focusVisibleChangedListener\");\n\n/**\n * Shows a focus indication if and only if the keyboard is active.\n *\n * The keyboard is considered to be active if a keyboard event has occurred\n * since the last mousedown event.\n *\n * This is loosely modeled after the proposed\n * [focus-visible](https://github.com/WICG/focus-visible) feature for CSS.\n *\n * @module FocusVisibleMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function FocusVisibleMixin(Base) {\n  // The class prototype added by the mixin.\n  return class FocusVisible extends Base {\n    constructor() {\n      // @ts-ignore\n      super();\n\n      // We listen to focusin/focusout instead of focus/blur because components\n      // like Menu want to handle focus visiblity for the items they contain,\n      // and those contained items can get the focus. Using focusin/focusout\n      // lets us know whether this element *or any element it contains* has the\n      // focus.\n      //\n      // Focus events are problematic in that they can occur during rendering:\n      // if an element with the focus is updated so that its tabindex is\n      // removed, it will lose focus. Since these focus handlers need to set\n      // state, this could lead to setting state during rendering, which is bad.\n      // To avoid this problem, we use promise timing to defer the setting of\n      // state.\n      this.addEventListener(\"focusout\", (event) => {\n        Promise.resolve().then(() => {\n          // What has the focus now?\n          /** @type {any} */ const cast = event;\n          const newFocusedElement =\n            cast.relatedTarget || document.activeElement;\n          const isFocusedElement = this === newFocusedElement;\n          const containsFocus = deepContains(this, newFocusedElement);\n          const lostFocus = !isFocusedElement && !containsFocus;\n          if (lostFocus) {\n            this[setState]({\n              focusVisible: false,\n            });\n            // No longer need to listen for changes in focus visibility.\n            document.removeEventListener(\n              \"focusvisiblechange\",\n              this[focusVisibleChangedListenerKey]\n            );\n            this[focusVisibleChangedListenerKey] = null;\n          }\n        });\n      });\n      this.addEventListener(\"focusin\", () => {\n        Promise.resolve().then(() => {\n          if (this[state].focusVisible !== keyboardActive) {\n            // Show the element as focused if the keyboard has been used.\n            this[setState]({\n              focusVisible: keyboardActive,\n            });\n          }\n          if (!this[focusVisibleChangedListenerKey]) {\n            // Listen to subsequent changes in focus visibility.\n            this[focusVisibleChangedListenerKey] = () => refreshFocus(this);\n            document.addEventListener(\n              \"focusvisiblechange\",\n              this[focusVisibleChangedListenerKey]\n            );\n          }\n        });\n      });\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        focusVisible: false,\n      });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      // Suppress the component's normal `outline` style unless we know the\n      // focus should be visible.\n      if (changed.focusVisible) {\n        const { focusVisible } = this[state];\n        this.toggleAttribute(\"focus-visible\", focusVisible);\n      }\n    }\n\n    get [template]() {\n      const result = super[template] || templateFrom.html``;\n      result.content.append(fragmentFrom.html`\n        <style>\n          :host {\n            outline: none;\n          }\n\n          :host([focus-visible]:focus-within) {\n            outline-color: Highlight; /* Firefox */\n            outline-color: -webkit-focus-ring-color; /* All other browsers */\n            outline-style: auto;\n          }\n        </style>\n      `);\n      return result;\n    }\n  };\n}\n\nfunction refreshFocus(/** @type {ReactiveElement} */ element) {\n  element[setState]({\n    focusVisible: keyboardActive,\n  });\n}\n\nfunction updateKeyboardActive(/** @type {boolean} */ newKeyboardActive) {\n  if (keyboardActive !== newKeyboardActive) {\n    keyboardActive = newKeyboardActive;\n    const oldEvent = new CustomEvent(\"focus-visible-changed\", {\n      detail: {\n        focusVisible: keyboardActive,\n      },\n    });\n    document.dispatchEvent(oldEvent);\n    const event = new CustomEvent(\"focusvisiblechange\", {\n      detail: {\n        focusVisible: keyboardActive,\n      },\n    });\n    document.dispatchEvent(event);\n  }\n}\n\n// Listen for top-level keydown and mousedown events.\n// Use capture phase so we detect events even if they're handled.\nwindow.addEventListener(\n  \"keydown\",\n  () => {\n    updateKeyboardActive(true);\n  },\n  { capture: true }\n);\n\nwindow.addEventListener(\n  \"mousedown\",\n  () => {\n    updateKeyboardActive(false);\n  },\n  { capture: true }\n);\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  nativeInternals,\n  render,\n  rendered,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Allows a component to participate in HTML form submission.\n *\n * The mixin expects the component to define a `value` property of type\n * `string`.\n *\n * @module FormElementMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function FormElementMixin(Base) {\n  // The class prototype added by the mixin.\n  class FormElement extends Base {\n    constructor() {\n      super();\n      /** @type {any} */ const cast = this;\n      if (!this[nativeInternals] && cast.attachInternals) {\n        this[nativeInternals] = cast.attachInternals();\n      }\n    }\n\n    checkValidity() {\n      return this[nativeInternals].checkValidity();\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        name: \"\",\n        validationMessage: \"\",\n        valid: true,\n      });\n    }\n\n    // Uncomment for debugging only\n    get internals() {\n      return this[nativeInternals];\n    }\n\n    static get formAssociated() {\n      return true;\n    }\n\n    /**\n     * The ID of the `form` element with which this element is associated,\n     * or `null` if the element is not associated with any form. This is provided\n     * for consistency with the native HTML\n     * [form](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#form)\n     * property.\n     *\n     * @type {string}\n     */\n    get form() {\n      return this[nativeInternals].form;\n    }\n\n    /**\n     * The name of the form field that will be filled with this element's\n     * `value`. This is an analogue of the standard HTML\n     * [name](https://developer.mozilla.org/en-US/docs/Web/API/Element/name)\n     * property.\n     *\n     * @type {string}\n     */\n    get name() {\n      return this[state] ? this[state].name : \"\";\n    }\n    set name(name) {\n      const s = String(name);\n      if (\"name\" in Base.prototype) {\n        super.name = s;\n      }\n      this[setState]({\n        name: s,\n      });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      // Reflect name property to attribute so form will pick it up.\n      if (changed.name) {\n        const { name } = this[state];\n        if (name) {\n          this.setAttribute(\"name\", name);\n        } else {\n          this.removeAttribute(\"name\");\n        }\n      }\n\n      if (this[nativeInternals] && this[nativeInternals].setValidity) {\n        // Reflect validity state to internals.\n        if (changed.valid || changed.validationMessage) {\n          const { valid, validationMessage } = this[state];\n          if (valid) {\n            this[nativeInternals].setValidity({});\n          } else {\n            this[nativeInternals].setValidity(\n              {\n                customError: true,\n              },\n              validationMessage\n            );\n          }\n        }\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n      if (changed.value) {\n        if (this[nativeInternals]) {\n          this[nativeInternals].setFormValue(this[state].value, this[state]);\n        }\n      }\n    }\n\n    reportValidity() {\n      return this[nativeInternals].reportValidity();\n    }\n\n    /**\n     * The \"type\" of the form field, provided for consistency with the\n     * native HTML\n     * [type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#type)\n     * property.\n     *\n     * If a base class provides a `type` property, that will be returned. (If\n     * this mixin is applied to a class defined by WrappedStandardElement, this\n     * will return the `type` of the inner standard element.) Otherwise, the\n     * default value of this property will be the same as the HTML tag name\n     * registered for the custom element.\n     *\n     * @type {string}\n     */\n    get type() {\n      // Defer to base class value.\n      return super.type || this.localName;\n    }\n\n    get validationMessage() {\n      return this[state].validationMessage;\n    }\n\n    get validity() {\n      return this[nativeInternals].validity;\n    }\n\n    get willValidate() {\n      return this[nativeInternals].willValidate;\n    }\n  }\n\n  return FormElement;\n}\n","import { firstFocusableElement } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { delegatesFocus, focusTarget, shadowRoot } from \"./internal.js\";\n\n/**\n * Delegates a component's focus to its first focusable shadow element.\n *\n * This mixin serves as a polyfill for the standard `delegatesFocus` shadow root\n * property. As of June 2020, that property is still only natively supported in\n * Chrome. The Chrome delegatesFocus implementation has some subtle issues;\n * until additional implementations are available, it's hard to know whether the\n * issues are with the definition of delegatesFocus, with Chrome's\n * implementation, or with Elix component code. Accordingly, for the time being\n * this polyfill is used even on Chrome.\n *\n * @module DelegateFocusMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function DelegateFocusMixin(Base) {\n  // The class prototype added by the mixin.\n  class DelegateFocus extends Base {\n    /**\n     * Returns true if the component is delegating its focus.\n     *\n     * A component using `DelegateFocusMixin` will always have this property be\n     * true unless a class takes measures to override it.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    get [delegatesFocus]() {\n      return true;\n    }\n\n    /**\n     * If someone tries to put the focus on us, delegate the focus to the first\n     * focusable element in the composed tree below our shadow root.\n     *\n     * @ignore\n     * @param {FocusOptions=} focusOptions\n     */\n    focus(focusOptions) {\n      // On browsers that support delegatesFocus natively, we should just be\n      // able to let the browser handle the focus method. However, we hit a bug\n      // in June 2020 where the native focus method in Chrome did not always\n      // produce the expected results if delegatesFocus is set.\n      //\n      // Specific bug: a PopupButton would like to delegates focus to its source\n      // button. Tabbing to a PopupButton focused on the source button as\n      // expected. Moreover, programmatically setting focus on the button also\n      // worked. However, when a PopupButton's popup was closed with the Escape\n      // key, OverlayMixin attemped to set programmatically focus to the\n      // PopupButton. This did *not* work as expecte, and focus ended up on the\n      // body. Until we have a second native implementation to compare against,\n      // it's difficult to determine whether this is a bug in the definition of\n      // delegatesFocus, Chrome's implementation, or our code.\n\n      // /** @type {any} */ const cast = this[shadowRoot];\n      // if (cast.delegatesFocus) {\n      //   // Native support for delegatesFocus, so don't need to do anything.\n      //   super.focus(focusOptions);\n      //   return;\n      // }\n      const focusElement = this[focusTarget];\n      if (focusElement) {\n        focusElement.focus(focusOptions);\n      }\n    }\n\n    get [focusTarget]() {\n      // HACK: The commented-out code lets us rely on the browser to indicate\n      // which element should be focused on in browsers that don't support\n      // native delegatesFocus. However, this code creates subtle focus problems\n      // in components like AutoCompleteListBox: if the user clicks the toggle\n      // button, the focus won't be placed on the top-level AutoCompleteComboBox\n      // as expected; that element will be returned as the focus target, but if\n      // it doesn't have a non-negative tabindex, forwardFocus won't think it's\n      // focusable. A more correct solution would be for all components that are\n      // focusable to give themselves a tabIndex of 0 by default or define a new\n      // public `focusable` that components could use to indicate that they're\n      // focusable. Until we have time to fully explore that, we workaround the\n      // bug by providing the polyfill behavior even in browsers that have\n      // delegatesFocus.\n\n      // /** @type {any} */ const cast = this[shadowRoot];\n      // return cast.delegatesFocus\n      //   ? this\n      //   : firstFocusableElement(this[shadowRoot]);\n      return firstFocusableElement(this[shadowRoot]);\n    }\n  }\n\n  return DelegateFocus;\n}\n","import { setInternalState, standardBooleanAttributes } from \"../core/dom.js\";\nimport { templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport DelegateFocusMixin from \"./DelegateFocusMixin.js\";\nimport {\n  defaultState,\n  defaultTabIndex,\n  firstRender,\n  ids,\n  nativeInternals,\n  render,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  template,\n} from \"./internal.js\";\n\nconst extendsKey = Symbol(\"extends\");\n\nconst delegatedPropertySettersKey = Symbol(\"delegatedPropertySetters\");\n\n/* True if a standard element is focusable by default. */\n/** @type {IndexedObject<boolean>} */\nconst focusableByDefault = {\n  a: true,\n  area: true,\n  button: true,\n  details: true,\n  iframe: true,\n  input: true,\n  select: true,\n  textarea: true,\n};\n\n/*\n * A set of events which, if fired by the inner standard element, should be\n * re-raised by the custom element.\n *\n * These are events which are spec'ed to NOT get retargetted across a Shadow DOM\n * boundary, organized by which element(s) raise the events. To properly\n * simulate these, we will need to listen for the real events, then re-raise a\n * simulation of the original event. For more information, see\n * https://www.w3.org/TR/shadow-dom/#h-events-that-are-not-leaked-into-ancestor-trees.\n *\n * It appears that we do *not* need to re-raise the non-bubbling \"focus\" and\n * \"blur\" events. These appear to be automatically re-raised as expected -- but\n * it's not clear why that happens.\n *\n * The list below is reasonably complete. It omits elements that cannot be\n * wrapped (see class notes above). Also, we haven't actually tried wrapping\n * every element in this list; some of the more obscure ones might not actually\n * work as expected, but it was easier to include them for completeness than\n * to actually verify whether or not the element can be wrapped.\n */\n/** @type {IndexedObject<string[]>} */\nconst reraiseEvents = {\n  address: [\"scroll\"],\n  blockquote: [\"scroll\"],\n  caption: [\"scroll\"],\n  center: [\"scroll\"],\n  dd: [\"scroll\"],\n  dir: [\"scroll\"],\n  div: [\"scroll\"],\n  dl: [\"scroll\"],\n  dt: [\"scroll\"],\n  fieldset: [\"scroll\"],\n  form: [\"reset\", \"scroll\"],\n  frame: [\"load\"],\n  h1: [\"scroll\"],\n  h2: [\"scroll\"],\n  h3: [\"scroll\"],\n  h4: [\"scroll\"],\n  h5: [\"scroll\"],\n  h6: [\"scroll\"],\n  iframe: [\"load\"],\n  img: [\"abort\", \"error\", \"load\"],\n  input: [\"abort\", \"change\", \"error\", \"select\", \"load\"],\n  li: [\"scroll\"],\n  link: [\"load\"],\n  menu: [\"scroll\"],\n  object: [\"error\", \"scroll\"],\n  ol: [\"scroll\"],\n  p: [\"scroll\"],\n  script: [\"error\", \"load\"],\n  select: [\"change\", \"scroll\"],\n  tbody: [\"scroll\"],\n  tfoot: [\"scroll\"],\n  thead: [\"scroll\"],\n  textarea: [\"change\", \"select\", \"scroll\"],\n};\n\n/*\n * Mouse events that should be disabled if the inner component is disabled.\n */\nconst mouseEventNames = [\n  \"click\",\n  \"dblclick\",\n  \"mousedown\",\n  \"mouseenter\",\n  \"mouseleave\",\n  \"mousemove\",\n  \"mouseout\",\n  \"mouseover\",\n  \"mouseup\",\n  \"wheel\",\n];\n\n// Keep track of which re-raised events should bubble.\n/** @type {IndexedObject<boolean>} */\nconst eventBubbles = {\n  abort: true,\n  change: true,\n  reset: true,\n};\n\n// Elements which are display: block by default.\n// Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements\nconst blockElements = [\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"blockquote\",\n  \"canvas\",\n  \"dd\",\n  \"div\",\n  \"dl\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"header\",\n  \"hgroup\",\n  \"hr\",\n  \"li\",\n  \"main\",\n  \"nav\",\n  \"noscript\",\n  \"ol\",\n  \"output\",\n  \"p\",\n  \"pre\",\n  \"section\",\n  \"table\",\n  \"tfoot\",\n  \"ul\",\n  \"video\",\n];\n\n// Standard attributes that don't have corresponding properties.\n// These need to be delegated from the wrapper to the inner element.\nconst attributesWithoutProperties = [\n  \"accept-charset\",\n  \"autoplay\",\n  \"buffered\",\n  \"challenge\",\n  \"codebase\",\n  \"colspan\",\n  \"contenteditable\",\n  \"controls\",\n  \"crossorigin\",\n  \"datetime\",\n  \"dirname\",\n  \"for\",\n  \"formaction\",\n  \"http-equiv\",\n  \"icon\",\n  \"ismap\",\n  \"itemprop\",\n  \"keytype\",\n  \"language\",\n  \"loop\",\n  \"manifest\",\n  \"maxlength\",\n  \"minlength\",\n  \"muted\",\n  \"novalidate\",\n  \"preload\",\n  \"radiogroup\",\n  \"readonly\",\n  \"referrerpolicy\",\n  \"rowspan\",\n  \"scoped\",\n  \"usemap\",\n];\n\nconst Base = DelegateFocusMixin(ReactiveElement);\n\n/**\n * Wraps a standard HTML element so it can be extended\n *\n * The typical way to use this class is via its static `wrap` method.\n *\n * @inherits ReactiveElement\n * @mixes DelegateFocusMixin\n * @part inner - the inner standard HTML element\n */\nclass WrappedStandardElement extends Base {\n  constructor() {\n    super();\n    /** @type {any} */ const cast = this;\n    if (!this[nativeInternals] && cast.attachInternals) {\n      this[nativeInternals] = cast.attachInternals();\n    }\n  }\n\n  /**\n   *\n   * Wrapped standard elements need to forward some attributes to the inner\n   * element in cases where the attribute does not have a corresponding\n   * property. These attributes include those prefixed with \"aria-\", and some\n   * unusual standard attributes like contenteditable. To handle those, this\n   * class defines its own attributeChangedCallback.\n   *\n   * @ignore\n   * @param {string} name\n   * @param {string} oldValue\n   * @param {string} newValue\n   */\n  attributeChangedCallback(name, oldValue, newValue) {\n    const forwardAttribute = attributesWithoutProperties.indexOf(name) >= 0;\n    if (forwardAttribute) {\n      const innerAttributes = Object.assign({}, this[state].innerAttributes, {\n        [name]: newValue,\n      });\n      this[setState]({ innerAttributes });\n    } else {\n      // Rely on the base attributeChangedCallback provided by\n      // AttributeMarshallingMixin.\n      super.attributeChangedCallback(name, oldValue, newValue);\n    }\n  }\n\n  // Delegate method defined by HTMLElement.\n  blur() {\n    this.inner.blur();\n  }\n\n  // One HTMLElement we *don't* delegate is `click`. Generally speaking, a click\n  // on the outer wrapper should behave the same as a click on the inner\n  // element. Also, we want to ensure outside event listeners get a click event\n  // when the click method is invoked. But a click on the inner element will\n  // raise a click event that won't be re-raised by default across the shadow\n  // boundary. The precise behavior seems to be slightly different in Safari\n  // than other browsers, but it seems safer to not delegate click.\n  //\n  // click() {}\n\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      innerAttributes: {},\n    });\n  }\n\n  get [defaultTabIndex]() {\n    return focusableByDefault[this.extends] ? 0 : -1;\n  }\n\n  /**\n   * The tag name of the standard HTML element extended by this class.\n   *\n   * @returns {string}\n   */\n  get extends() {\n    return this.constructor[extendsKey];\n  }\n\n  /**\n   * Returns a reference to the inner standard HTML element.\n   *\n   * @type {HTMLElement}\n   */\n  get inner() {\n    /** @type {any} */\n    const result = this[ids] && this[ids].inner;\n    if (!result) {\n      /* eslint-disable no-console */\n      console.warn(\n        \"Attempted to get an inner standard element before it was instantiated.\"\n      );\n    }\n    return result;\n  }\n\n  static get observedAttributes() {\n    // For our custom attributeChangedCallback to work, we need to observe\n    // the attributes we want to forward.\n    // @ts-ignore\n    return [...super.observedAttributes, ...attributesWithoutProperties];\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n\n    const inner = this.inner;\n    if (this[firstRender]) {\n      // Listen for any events raised by the inner element which will not\n      // automatically be retargetted across the Shadow DOM boundary, and\n      // re-raise those events when they happen.\n      const eventNames = reraiseEvents[this.extends] || [];\n      eventNames.forEach((eventName) => {\n        inner.addEventListener(eventName, () => {\n          const event = new Event(eventName, {\n            bubbles: eventBubbles[eventName] || false,\n          });\n          this.dispatchEvent(event);\n        });\n      });\n\n      // If inner element can be disabled, then listen to mouse events on the\n      // *outer* element and absorb them if the inner element is disabled.\n      // Without this, a mouse event like a click on the inner disabled element\n      // would be treated as a click on the outer element. Someone listening to\n      // clicks on the outer element would get a click event, even though the\n      // overall element is supposed to be disabled.\n      if (\"disabled\" in inner) {\n        mouseEventNames.forEach((eventName) => {\n          this.addEventListener(eventName, (event) => {\n            if (/** @type {any} */ (inner).disabled) {\n              event.stopImmediatePropagation();\n            }\n          });\n        });\n      }\n    }\n\n    if (changed.tabIndex) {\n      inner.tabIndex = this[state].tabIndex;\n    }\n\n    if (changed.innerAttributes) {\n      // Forward attributes to the inner element.\n      // See notes at attributeChangedCallback.\n      const { innerAttributes } = this[state];\n      for (const name in innerAttributes) {\n        applyAttribute(inner, name, innerAttributes[name]);\n      }\n    }\n\n    // Forward delegated properties to the inner element.\n    this.constructor[delegatedPropertySettersKey].forEach((property) => {\n      if (changed[property]) {\n        const value = this[state][property];\n\n        // Inner selection properties needed to be handled specially.\n        // See TrackTextSelectionMixin.\n        const specialCase =\n          (property === \"selectionEnd\" || property === \"selectionStart\") &&\n          value === null;\n        if (!specialCase) {\n          inner[property] = value;\n        }\n      }\n    });\n  }\n\n  [rendered](/** @type {ChangedFlags} */ changed) {\n    super[rendered](changed);\n\n    // Apply disabled state.\n    if (changed.disabled) {\n      const { disabled } = this[state];\n      if (disabled !== undefined) {\n        setInternalState(this, \"disabled\", disabled);\n      }\n    }\n  }\n\n  /**\n   * The template copied into the shadow tree of new instances of this element.\n   *\n   * The default value of this property is a template that includes an instance\n   * the standard element being wrapped, with a `<slot>` element inside that\n   * to pick up the element's light DOM content. For example, if you wrap an\n   * `<a>` element, then the default template will look like:\n   *\n   *     <template>\n   *       <style>\n   *       :host {\n   *         display: inline-block;\n   *       }\n   *       </style>\n   *       <a id=\"inner\">\n   *         <slot></slot>\n   *       </a>\n   *     </template>\n   *\n   * The `display` styling applied to the host will be `block` for elements that\n   * are block elements by default, and `inline-block` (not `inline`) for other\n   * elements.\n   *\n   * If you'd like the template to include other elements, then override this\n   * property and return a template of your own. The template should include an\n   * instance of the standard HTML element you are wrapping, and the ID of that\n   * element should be \"inner\".\n   *\n   * @type {(string|HTMLTemplateElement)}\n   */\n  get [template]() {\n    const display = blockElements.includes(this.extends)\n      ? \"block\"\n      : \"inline-block\";\n    const tag = this.extends;\n    return templateFrom.html`\n      <style>\n        :host {\n          display: ${display}\n        }\n        \n        [part~=\"inner\"] {\n          box-sizing: border-box;\n          height: 100%;\n          width: 100%;\n        }\n      </style>\n      <${tag} id=\"inner\" part=\"inner ${tag}\">\n        <slot></slot>\n      </${tag}>\n    `;\n  }\n\n  /**\n   * Creates a class that wraps a standard HTML element.\n   *\n   * Note that the resulting class is a subclass of WrappedStandardElement, not\n   * the standard class being wrapped. E.g., if you call\n   * `WrappedStandardElement.wrap('a')`, you will get a class whose shadow tree\n   * will include an anchor element, but the class will *not* inherit from\n   * HTMLAnchorElement.\n   *\n   * @static\n   * @param {string} extendsTag - the standard HTML element tag to extend\n   */\n  static wrap(extendsTag) {\n    // Create the new class.\n    /** @type {Constructor<WrappedStandardElement>} */\n    class Wrapped extends WrappedStandardElement {}\n\n    // Indicate which tag it wraps.\n    /** @type {any} */ (Wrapped)[extendsKey] = extendsTag;\n\n    // Create getter/setters that delegate to the wrapped element.\n    const element = document.createElement(extendsTag);\n    defineDelegates(Wrapped, Object.getPrototypeOf(element));\n\n    return Wrapped;\n  }\n}\n\n/**\n * Update the given attribute on an element.\n *\n * Passing a non-null `value` acts like a call to `setAttribute(name, value)`.\n * If the supplied `value` is nullish, this acts like a call to\n * `removeAttribute(name)`.\n *\n * @private\n * @param {HTMLElement} element\n * @param {string} name\n * @param {string} value\n */\nexport function applyAttribute(element, name, value) {\n  if (standardBooleanAttributes[name]) {\n    // Boolean attribute\n    if (typeof value === \"string\") {\n      element.setAttribute(name, \"\");\n    } else if (value === null) {\n      element.removeAttribute(name);\n    }\n  } else {\n    // Regular string-valued attribute\n    if (value != null) {\n      element.setAttribute(name, value.toString());\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n}\n\n/**\n * Create a delegate for the method or property identified by the descriptor.\n *\n * @private\n * @param {string} name\n * @param {PropertyDescriptor} descriptor\n */\nfunction createDelegate(name, descriptor) {\n  if (typeof descriptor.value === \"function\") {\n    if (name !== \"constructor\") {\n      return createMethodDelegate(name, descriptor);\n    }\n  } else if (\n    typeof descriptor.get === \"function\" ||\n    typeof descriptor.set === \"function\"\n  ) {\n    return createPropertyDelegate(name, descriptor);\n  }\n  return null;\n}\n\n/**\n * Create a delegate for the method identified by the descriptor.\n *\n * @private\n * @param {string} name\n * @param {PropertyDescriptor} descriptor\n */\nfunction createMethodDelegate(name, descriptor) {\n  const value = function (/** @type {any[]} */ ...args) {\n    // @ts-ignore\n    this.inner[name](...args);\n  };\n  const delegate = {\n    configurable: descriptor.configurable,\n    enumerable: descriptor.enumerable,\n    value,\n    writable: descriptor.writable,\n  };\n  return delegate;\n}\n\n/**\n * Create a delegate for the property identified by the descriptor.\n *\n * @private\n * @param {string} name\n * @param {PropertyDescriptor} descriptor\n */\nfunction createPropertyDelegate(name, descriptor) {\n  /** @type {PlainObject} */\n  const delegate = {\n    configurable: descriptor.configurable,\n    enumerable: descriptor.enumerable,\n  };\n  if (descriptor.get) {\n    delegate.get = function () {\n      return getInnerProperty(/** @type {any} */ (this), name);\n    };\n  }\n  if (descriptor.set) {\n    delegate.set = function (/** @type {any} */ value) {\n      setInnerProperty(/** @type {any} */ (this), name, value);\n    };\n  }\n  if (descriptor.writable) {\n    delegate.writable = descriptor.writable;\n  }\n  return delegate;\n}\n\n/**\n * Define delegates for the given class for each property/method on the\n * indicated prototype.\n *\n * @private\n * @param {Constructor<Object>} cls\n * @param {Object} prototype\n */\nfunction defineDelegates(cls, prototype) {\n  const names = Object.getOwnPropertyNames(prototype);\n  cls[delegatedPropertySettersKey] = [];\n  names.forEach((name) => {\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);\n    if (!descriptor) {\n      return;\n    }\n    const delegate = createDelegate(name, descriptor);\n    if (delegate) {\n      Object.defineProperty(cls.prototype, name, delegate);\n      if (delegate.set) {\n        cls[delegatedPropertySettersKey].push(name);\n      }\n    }\n  });\n}\n\n/**\n * Return the value of the named property on the inner standard element.\n *\n * @private\n * @param {ReactiveElement} element\n * @param {string} name\n */\nfunction getInnerProperty(element, name) {\n  // If we haven't rendered yet, use internal state value. Once we've\n  // rendered, we get the value from the wrapped element itself. Return our\n  // concept of the current property value from state. If the property hasn't\n  // been defined, however, get the current value of the property from the\n  // inner element.\n  //\n  // This is intended to support cases like an anchor element. If someone sets\n  // `href` on a wrapped anchor, we'll know the value of `href` from state,\n  // but we won't know the value of href-dependent calculated properties like\n  // `protocol`. Using two sources of truth (state and the inner element)\n  // seems fragile, but it's unclear how else to handle this without\n  // reimplementing all HTML property interactions ourselves.\n  //\n  // This arrangement also means that, if an inner element property can change\n  // in response to user interaction (e.g., an input element's value changes\n  // as the user types), the component must listen to suitable events on the\n  // inner element and update its state accordingly.\n  const value = element[state][name];\n  return value || (element[shadowRoot] && element.inner[name]);\n}\n\n/**\n * Set the named property on the inner standard element.\n *\n * @private\n * @param {ReactiveElement} element\n * @param {string} name\n * @param {any} value\n */\nfunction setInnerProperty(element, name, value) {\n  // We normally don't check an existing state value before calling[setState],\n  // relying instead on[setState] to do that check for us. However, we have\n  // dangers in this particular component of creating infinite loops.\n  //\n  // E.g., setting the tabindex attibute will call attributeChangedCallback,\n  // which will set the tabIndex property, which will want to set state, which\n  // will cause a render, which will try to reflect the current value of the\n  // tabIndex property to the tabindex attribute, causing a loop.\n  //\n  // To avoid this, we check the existing value before updating our state.\n  if (element[state][name] !== value) {\n    element[setState]({ [name]: value });\n  }\n}\n\nexport default WrappedStandardElement;\n","import { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport DelegateInputLabelMixin from \"./DelegateInputLabelMixin.js\";\nimport FocusVisibleMixin from \"./FocusVisibleMixin.js\";\nimport FormElementMixin from \"./FormElementMixin.js\";\nimport {\n  defaultState,\n  firstRender,\n  ids,\n  inputDelegate,\n  raiseChangeEvents,\n  render,\n  setState,\n  template,\n} from \"./internal.js\";\nimport TrackTextSelectionMixin from \"./TrackTextSelectionMixin.js\";\nimport WrappedStandardElement from \"./WrappedStandardElement.js\";\n\nconst Base = DelegateInputLabelMixin(\n  FocusVisibleMixin(\n    FormElementMixin(\n      TrackTextSelectionMixin(WrappedStandardElement.wrap(\"input\"))\n    )\n  )\n);\n\n/**\n * Base class for custom input elements\n *\n * `Input` wraps a standard HTML `input` element, allowing for custom styling\n * and behavior while ensuring standard keyboard and focus behavior.\n *\n * @inherits WrappedStandardElement\n * @mixes DelegateInputLabelMixin\n * @mixes FocusVisibleMixin\n * @mixes FormElementMixin\n * @mixes TrackTextSelectionMixin\n * @part input - the inner standard HTML input\n */\nclass Input extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      valueCopy: \"\",\n    });\n  }\n\n  get [inputDelegate]() {\n    return this.inner;\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n    if (this[firstRender]) {\n      // The following jsDoc comment doesn't directly apply to the statement which\n      // follows, but is placed there because the comment has to go somewhere to\n      // be visible to jsDoc, and the statement is at tangentially related.\n      /**\n       * Raised when the user changes the element's text content.\n       *\n       * This is the standard `input` event; the component does not do any work to\n       * raise it. It is documented here to let people know it is available to\n       * detect when the user edits the content.\n       *\n       * @event input\n       */\n      this[ids].inner.addEventListener(\"input\", () => {\n        this[raiseChangeEvents] = true;\n        /** @type {any} */\n        const inner = this[ids].inner;\n        this.value = inner.value;\n        // Setting value implies updating selection state as well.\n        this[setState]({\n          selectionEnd: inner.selectionEnd,\n          selectionStart: inner.selectionStart,\n        });\n        this[raiseChangeEvents] = false;\n      });\n    }\n  }\n\n  get [template]() {\n    const result = super[template];\n    result.content.append(fragmentFrom.html`\n      <style>\n        [part~=\"input\"] {\n          font: inherit;\n          outline: none;\n          text-align: inherit;\n        }\n      </style>\n    `);\n    return result;\n  }\n\n  get value() {\n    return super.value;\n  }\n  set value(value) {\n    const s = String(value);\n    super.value = s;\n    this[setState]({ valueCopy: s });\n  }\n}\n\nexport default Input;\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  firstRender,\n  raiseChangeEvents,\n  render,\n  setState\n} from \"./internal.js\";\n\n/**\n * Track the selection state of an inner input-like element\n *\n * This mixin is an adjunct to [WrappedStandardElement](WrappedStandardElement),\n * intended to be used with a wrapped input or textarea. The inner input or\n * textarea will have selection properties `selectionStart` and `selectionEnd`\n * that we would like to track as state members. Doing so is challenging,\n * because the browser provides no standard event tracking a change in\n * selection.\n *\n * To compensate, this mixin listens to keyboard or mouse activity within the\n * inner element that might affect selection, then refreshes the host\n * component's selection state as appropriate.\n *\n * @module TrackTextSelectionMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function TrackTextSelectionMixin(Base) {\n  // The class prototype added by the mixin.\n  class TrackTextSelection extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        selectionEnd: 0,\n        selectionStart: 0,\n      });\n    }\n\n    [render](changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      if (this[firstRender]) {\n        // The user can manually update the selection with the keyboard or\n        // mouse. We listen to keydown and mousedown events, wait for the\n        // browser to perform its default action, and then refresh the selection\n        // state in case it changed.\n        const refreshListener = (() => {\n          // HACK:  If we check too quickly, the default action won't have\n          // happened. We wait for an arbitrary amount of time that seems to\n          // work, although this feels gross.\n          const delay = 10; // milliseconds\n          setTimeout(() => {\n            this[raiseChangeEvents] = true;\n            refreshSelectionState(this);\n            this[raiseChangeEvents] = false;\n          }, delay);\n        }).bind(this);\n        this.addEventListener(\"keydown\", refreshListener);\n        this.addEventListener(\"mousedown\", refreshListener);\n        this.addEventListener(\"touchend\", refreshListener);\n      }\n    }\n  }\n\n  return TrackTextSelection;\n}\n\n// Refresh our selection state values from the inner component's current\n// selection properties.\nfunction refreshSelectionState(element) {\n  const inner = element.inner;\n  const { selectionEnd, selectionStart } = inner;\n  element[setState]({\n    selectionEnd,\n    selectionStart,\n  });\n}\n","/**\n * Helpers related to universal accessibility\n *\n * Universal accessibility is a core goal of the Elix project. These helpers are\n * used by mixins like [AriaListMixin](AriaListMixin) and\n * [AriaMenuMixin](AriaMenuMixin) to support accessibility via ARIA.\n *\n * @module accessibility\n */\n\n// Used by ensureId\nconst generatedIdKey = Symbol(\"generatedId\");\nlet generatedIdCount = 0;\n\n/**\n * A dictionary mapping built-in HTML elements to their default ARIA role.\n *\n * Example: `defaultAriaRole.ol` returns \"list\", since the default ARIA role\n * for an `ol` (ordered list) element is \"list\".\n */\nexport const defaultAriaRole = {\n  a: \"link\",\n  article: \"region\",\n  button: \"button\",\n  h1: \"sectionhead\",\n  h2: \"sectionhead\",\n  h3: \"sectionhead\",\n  h4: \"sectionhead\",\n  h5: \"sectionhead\",\n  h6: \"sectionhead\",\n  hr: \"sectionhead\",\n  iframe: \"region\",\n  link: \"link\",\n  menu: \"menu\",\n  ol: \"list\",\n  option: \"option\",\n  output: \"liveregion\",\n  progress: \"progressbar\",\n  select: \"select\",\n  table: \"table\",\n  td: \"td\",\n  textarea: \"textbox\",\n  th: \"th\",\n  ul: \"list\",\n};\n\n/**\n * If the given element already has an ID, return it. If not, generate a\n * previously unused ID and return that.\n *\n * @param {Element} element\n * @returns {string}\n */\nexport function ensureId(element) {\n  let id = element.id || element[generatedIdKey];\n  if (!id) {\n    id = `_id${generatedIdCount++}`;\n    // Remember that we generated an ID for this element.\n    element[generatedIdKey] = id;\n  }\n  return id;\n}\n","import { closestFocusableNode } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { defaultState, firstRender, render, state } from \"./internal.js\";\n\n// Quick detection of whether we'll need to handle focus.\n// As of February 2019, we don't need to handle this in Chrome, perhaps because\n// they already support delegatesFocus (which handles related focus issues).\nconst focusTest = document.createElement(\"div\");\nfocusTest.attachShadow({ mode: \"open\", delegatesFocus: true });\n/** @type {any} */\nconst focusTestShadowRoot = focusTest.shadowRoot;\nconst nativeDelegatesFocus = focusTestShadowRoot.delegatesFocus;\n\n/**\n * Normalizes focus treatment for custom elements with Shadow DOM\n *\n * This mixin exists because the default behavior for mousedown should set the\n * focus to the closest ancestor of the clicked element that can take the focus.\n * As of Nov 2018, Chrome and Safari don't handle this as expected when the\n * clicked element is reassigned across more than one slot to end up inside a\n * focusable element. In such cases, the focus will end up on the body. Firefox\n * exhibits the behavior we want. See\n * https://github.com/w3c/webcomponents/issues/773.\n *\n * This mixin normalizes behavior to provide what Firefox does. When the user\n * mouses down inside anywhere inside the component's light DOM or Shadow DOM,\n * we walk up the composed tree to find the first element that can take the\n * focus and put the focus on it.\n *\n * @module ComposedFocusMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function ComposedFocusMixin(Base) {\n  // The class prototype added by the mixin.\n  class ComposedFocus extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        composeFocus: !nativeDelegatesFocus,\n      });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n      if (this[firstRender]) {\n        this.addEventListener(\"mousedown\", (event) => {\n          if (!this[state].composeFocus) {\n            return;\n          }\n          // Only process events for the main (usually left) button.\n          if (event.button !== 0) {\n            return;\n          }\n          if (event.target instanceof Element) {\n            const target = closestFocusableNode(event.target);\n            if (target) {\n              target.focus();\n              event.preventDefault();\n            }\n          }\n        });\n      }\n    }\n  }\n\n  return ComposedFocus;\n}\n","import { booleanAttributeValue } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  goFirst,\n  goLast,\n  goNext,\n  goPrevious,\n  raiseChangeEvents,\n  rendered,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Exposes a public API for navigating a cursor over a set of items\n *\n * This mixin expects a component to provide an `items` Array of all elements in\n * the list. This mixin also expects the component to apply\n * [ItemsCursorMixin](ItemsCursorMixin) or otherwise define a compatible\n * `currentIndex` state and other state members for navigating the current item.\n *\n * Given the above, this mixin exposes a consistent public API for reading and\n * manipulating the cursor.\n *\n * @module CursorAPIMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function CursorAPIMixin(Base) {\n  // The class prototype added by the mixin.\n  class CursorAPI extends Base {\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"current-index\") {\n        this.currentIndex = Number(newValue);\n      } else if (name === \"current-item-required\") {\n        const value = booleanAttributeValue(name, newValue);\n        if (this.currentItemRequired !== value) {\n          this.currentItemRequired = value;\n        }\n      } else if (name === \"cursor-operations-wrap\") {\n        const value = booleanAttributeValue(name, newValue);\n        if (this.cursorOperationsWrap !== value) {\n          this.cursorOperationsWrap = value;\n        }\n      } else {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n    }\n\n    /**\n     * The index of the current item, or -1 if no item is current.\n     *\n     * @type {number}\n     */\n    get currentIndex() {\n      const { items, currentIndex } = this[state];\n      return items && items.length > 0 ? currentIndex : -1;\n    }\n    set currentIndex(currentIndex) {\n      if (!isNaN(currentIndex)) {\n        this[setState]({ currentIndex });\n      }\n    }\n\n    /**\n     * The current item, or null if no item is current.\n     *\n     * @type {Element}\n     */\n    get currentItem() {\n      const { items, currentIndex } = this[state];\n      return items && items[currentIndex];\n    }\n    set currentItem(currentItem) {\n      const { items } = this[state];\n      if (!items) {\n        return;\n      }\n      const currentIndex = items.indexOf(currentItem);\n      this[setState]({ currentIndex });\n    }\n\n    /**\n     * True if the list should always have a current item (if it has items).\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get currentItemRequired() {\n      return this[state].currentItemRequired;\n    }\n    set currentItemRequired(currentItemRequired) {\n      this[setState]({ currentItemRequired });\n    }\n\n    /**\n     * True if cursor operations wrap from last to first, and vice versa.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get cursorOperationsWrap() {\n      return this[state].cursorOperationsWrap;\n    }\n    set cursorOperationsWrap(cursorOperationsWrap) {\n      this[setState]({ cursorOperationsWrap });\n    }\n\n    /**\n     * Moves to the first item in the list.\n     *\n     * @returns {Boolean} True if the current item changed, false if not.\n     */\n    goFirst() {\n      if (super.goFirst) {\n        super.goFirst();\n      }\n      return this[goFirst]();\n    }\n\n    /**\n     * Move to the last item in the list.\n     *\n     * @returns {Boolean} True if the current item changed\n     */\n    goLast() {\n      if (super.goLast) {\n        super.goLast();\n      }\n      return this[goLast]();\n    }\n\n    /**\n     * Move to the next item in the list.\n     *\n     * If the list has no current item, the first item will become current.\n     *\n     * @returns {Boolean} True if the current item changed\n     */\n    goNext() {\n      if (super.goNext) {\n        super.goNext();\n      }\n      return this[goNext]();\n    }\n\n    /**\n     * Moves to the previous item in the list.\n     *\n     * If the list has no current item, the last item will become current.\n     *\n     * @returns {Boolean} True if the current item changed\n     */\n    goPrevious() {\n      if (super.goPrevious) {\n        super.goPrevious();\n      }\n      return this[goPrevious]();\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n      if (changed.currentIndex && this[raiseChangeEvents]) {\n        const { currentIndex } = this[state];\n        const oldEvent = new CustomEvent(\"current-index-changed\", {\n          bubbles: true,\n          detail: { currentIndex },\n        });\n        this.dispatchEvent(oldEvent);\n        /**\n         * Raised when the `currentIndex` property changes.\n         *\n         * @event currentindexchanged\n         */\n        const event = new CustomEvent(\"currentindexchange\", {\n          bubbles: true,\n          detail: { currentIndex },\n        });\n        this.dispatchEvent(event);\n      }\n    }\n  }\n\n  return CursorAPI;\n}\n","import { selfAndComposedAncestors } from \"../core/dom.js\";\nimport { shadowRoot } from \"./internal.js\";\n\n/**\n * Utilities for working with scrolling.\n *\n * @module defaultScrollTarget\n */\n\n/**\n * Returns true if the given target or any of its ancestors can be scrolled\n * in the indicated direction.\n *\n * This is used, e.g., by gesture event handlers to predict if the default\n * behavior for a given event is likely to result in scrolling.\n *\n * @param {EventTarget} target\n * @param {'horizontal'|'vertical'} orientation\n * @param {boolean} downOrRight\n */\nexport function canScrollInDirection(target, orientation, downOrRight) {\n  if (!(target instanceof Node)) {\n    return false;\n  }\n  for (const ancestor of selfAndComposedAncestors(target)) {\n    if (ancestor instanceof HTMLElement) {\n      const style = getComputedStyle(ancestor);\n      const vertical = orientation === \"vertical\";\n      const scrollAxisMatch =\n        (vertical &&\n          (style.overflowY === \"scroll\" || style.overflowY === \"auto\")) ||\n        (!vertical &&\n          (style.overflowX === \"scroll\" || style.overflowX === \"auto\"));\n      if (scrollAxisMatch) {\n        // Found an ancestor that can potentially scroll in this orientation.\n        const scrollEdge = vertical ? \"scrollTop\" : \"scrollLeft\";\n        if (!downOrRight && ancestor[scrollEdge] > 0) {\n          // Target has room to scroll up or left.\n          return true;\n        }\n        const scrollLength = vertical ? \"scrollHeight\" : \"scrollWidth\";\n        const clientLength = vertical ? \"clientHeight\" : \"clientWidth\";\n        const scrollMax = ancestor[scrollLength] - ancestor[clientLength];\n        if (downOrRight && ancestor[scrollEdge] < scrollMax) {\n          // Target has room to scroll down or right.\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * This helper returns a guess as to what portion of the given element can be\n * scrolled. This is used by [CursorInViewMixin](CursorInViewMixin) to\n * provide a default implementation of [scrollTarget].\n *\n * If the element has a shadow root containing a default (unnamed) slot, this\n * returns the first ancestor of that slot that has either `overflow-x` or\n * `overflow-y` styled as `auto` or `scroll`. If the element has no default\n * slot, or no scrolling ancestor is found, the element itself is returned.\n *\n * @param {Element} element – the component to examine for a scrolling\n * element\n * @returns {Element}\n */\nexport function defaultScrollTarget(element) {\n  const root = element[shadowRoot];\n  const slot = root && root.querySelector(\"slot:not([name])\");\n  const scrollingParent =\n    slot &&\n    slot.parentNode instanceof Element &&\n    getScrollableElement(slot.parentNode);\n  return scrollingParent || element;\n}\n\n/**\n * Return true if the given element can be scrolled.\n *\n * @private\n * @param {HTMLElement} element\n */\nfunction isElementScrollable(element) {\n  const style = getComputedStyle(element);\n  const overflowX = style.overflowX;\n  const overflowY = style.overflowY;\n  return (\n    overflowX === \"scroll\" ||\n    overflowX === \"auto\" ||\n    overflowY === \"scroll\" ||\n    overflowY === \"auto\"\n  );\n}\n\n/**\n * If the given element can be scrolled, return that. If not, return the closest\n * ancestor that can be scrolled. If no such ancestor is found, return null.\n *\n * @param {Element} node\n * @returns {Element|null}\n */\nexport function getScrollableElement(node) {\n  for (const ancestor of selfAndComposedAncestors(node)) {\n    if (ancestor instanceof HTMLElement && isElementScrollable(ancestor)) {\n      return ancestor;\n    }\n  }\n  return null;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { rendered, scrollTarget, state } from \"./internal.js\";\nimport { defaultScrollTarget } from \"./scrolling.js\";\n\n/**\n * Scrolls to ensure the current item is visible\n *\n * When the current item in a list-like component changes, the current item\n * should be brought into view so that the user can confirm their selection.\n *\n * This mixin expects an `items` collection, such as that provided by\n * [ContentItemsMixin](ContentItemsMixin). It also expects a\n * `state.currentItem` member indicating which item is current. You\n * can supply that yourself, or use\n * [ItemsCursorMixin](ItemsCursorMixin).\n *\n * @module CursorInViewMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function CursorInViewMixin(Base) {\n  // The class prototype added by the mixin.\n  class CursorInView extends Base {\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (changed.currentItem) {\n        this.scrollCurrentItemIntoView();\n      }\n    }\n\n    /**\n     * Scroll the current item completely into view, minimizing the degree of\n     * scrolling performed.\n     *\n     * Blink has a `scrollIntoViewIfNeeded()` function that does something\n     * similar, but unfortunately it's non-standard, and in any event often ends\n     * up scrolling more than is absolutely necessary.\n     *\n     * This scrolls the containing element defined by the `scrollTarget`\n     * property. By default, it will scroll the element itself.\n     */\n    scrollCurrentItemIntoView() {\n      if (super.scrollCurrentItemIntoView) {\n        super.scrollCurrentItemIntoView();\n      }\n\n      const { currentItem, items } = this[state];\n      if (!currentItem || !items) {\n        return;\n      }\n\n      // Determine the bounds of the scroll target and item. We use\n      // getBoundingClientRect instead of .offsetTop, etc., because the latter\n      // round values, and we want to handle fractional values.\n      const scrollTargetRect = this[scrollTarget].getBoundingClientRect();\n      const itemRect = currentItem.getBoundingClientRect();\n\n      // Determine how far the item is outside the viewport.\n      const bottomDelta = itemRect.bottom - scrollTargetRect.bottom;\n      const leftDelta = itemRect.left - scrollTargetRect.left;\n      const rightDelta = itemRect.right - scrollTargetRect.right;\n      const topDelta = itemRect.top - scrollTargetRect.top;\n\n      // Scroll the target as necessary to bring the item into view.\n      // If an `orientation` state member is defined, only scroll along that\n      // axis. Otherwise, assume the orientation is \"both\".\n      const orientation = this[state].orientation || \"both\";\n      if (orientation === \"horizontal\" || orientation === \"both\") {\n        if (rightDelta > 0) {\n          this[scrollTarget].scrollLeft += rightDelta; // Scroll right\n        } else if (leftDelta < 0) {\n          this[scrollTarget].scrollLeft += Math.ceil(leftDelta); // Scroll left\n        }\n      }\n      if (orientation === \"vertical\" || orientation === \"both\") {\n        if (bottomDelta > 0) {\n          this[scrollTarget].scrollTop += bottomDelta; // Scroll down\n        } else if (topDelta < 0) {\n          this[scrollTarget].scrollTop += Math.ceil(topDelta); // Scroll up\n        }\n      }\n    }\n\n    /**\n     * The element that should be scrolled to get the selected item into view.\n     *\n     * By default, this uses the [defaultScrollTarget](defaultScrollTarget)\n     * helper to find the most likely candidate for scrolling. You can override\n     * this property to directly identify which element should be scrolled.\n     *\n     * See also [scrollTarget](internal#internal.scrollTarget).\n     */\n    get [scrollTarget]() {\n      const base = super[scrollTarget];\n      /** @type {any} */\n      const element = this;\n      return base || defaultScrollTarget(element);\n    }\n  }\n\n  return CursorInView;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  goDown,\n  goEnd,\n  goFirst,\n  goLast,\n  goLeft,\n  goNext,\n  goPrevious,\n  goRight,\n  goStart,\n  goUp,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\n/**\n * Maps direction semantics to cursor semantics.\n *\n * This turns a movement in a direction (go left, go right) into a cursor\n * operation (go previous, go next).\n *\n * This mixin can be used in conjunction with\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) (which maps keyboard events\n * to directions) and a mixin that handles cursor operations like\n * [ItemsCursorMixin](ItemsCursorMixin).\n *\n * @module DirectionCursorMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function DirectionCursorMixin(Base) {\n  // The class prototype added by the mixin.\n  class DirectionCursor extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        canGoDown: null,\n        canGoLeft: null,\n        canGoRight: null,\n        canGoUp: null,\n      });\n    }\n\n    /**\n     * Interprets `goDown` to mean \"move to the next item\".\n     */\n    [goDown]() {\n      if (super[goDown]) {\n        super[goDown]();\n      }\n      return this[goNext]();\n    }\n\n    /**\n     * Interprets `goEnd` to mean \"move to the last item\".\n     */\n    [goEnd]() {\n      if (super[goEnd]) {\n        super[goEnd]();\n      }\n      return this[goLast]();\n    }\n\n    /**\n     * Interprets `goLeft` to mean \"move to the previous item\".\n     *\n     * If the element has a `rightToLeft` property and it is true, then this\n     * moves to the _next_ item.\n     */\n    [goLeft]() {\n      if (super[goLeft]) {\n        super[goLeft]();\n      }\n      return this[state] && this[state].rightToLeft\n        ? this[goNext]()\n        : this[goPrevious]();\n    }\n\n    /**\n     * Interprets `goRight` to mean \"move to the next item\".\n     *\n     * If the element has a `rightToLeft` property and it is true, then this\n     * moves to the _previous_ item.\n     */\n    [goRight]() {\n      if (super[goRight]) {\n        super[goRight]();\n      }\n      return this[state] && this[state].rightToLeft\n        ? this[goPrevious]()\n        : this[goNext]();\n    }\n\n    /**\n     * Interprets `goStart` to mean \"move to the first item\".\n     */\n    [goStart]() {\n      if (super[goStart]) {\n        super[goStart]();\n      }\n      return this[goFirst]();\n    }\n\n    /**\n     * Interprets `goUp` to mean \"move to the previous item\".\n     */\n    [goUp]() {\n      if (super[goUp]) {\n        super[goUp]();\n      }\n      return this[goPrevious]();\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // Update computed state members to track whether we can go\n      // down/left/right/up.\n      if (\n        changed.canGoNext ||\n        changed.canGoPrevious ||\n        changed.languageDirection ||\n        changed.orientation ||\n        changed.rightToLeft\n      ) {\n        const { canGoNext, canGoPrevious, orientation, rightToLeft } = state;\n        const horizontal =\n          orientation === \"horizontal\" || orientation === \"both\";\n        const vertical = orientation === \"vertical\" || orientation === \"both\";\n        const canGoDown = vertical && canGoNext;\n        const canGoLeft = !horizontal\n          ? false\n          : rightToLeft\n          ? canGoNext\n          : canGoPrevious;\n        const canGoRight = !horizontal\n          ? false\n          : rightToLeft\n          ? canGoPrevious\n          : canGoNext;\n        const canGoUp = vertical && canGoPrevious;\n        Object.assign(effects, {\n          canGoDown,\n          canGoLeft,\n          canGoRight,\n          canGoUp,\n        });\n      }\n\n      return effects;\n    }\n  }\n\n  return DirectionCursor;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { firstRender, raiseChangeEvents, rendered, state } from \"./internal.js\";\n\n/**\n * Exposes a public API for the set of items in a list-like element\n *\n * @module ItemsAPIMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function ItemsAPIMixin(Base) {\n  // The class prototype added by the mixin.\n  class ItemsAPI extends Base {\n    /**\n     * The current set of items drawn from the element's current state.\n     *\n     * @type {ListItemElement[]} the element's current items\n     */\n    get items() {\n      return this[state] ? this[state].items : null;\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      // Raise items-changed if items changed after the initial render. We'll\n      // see changed.items on initial render, and raiseChangeEvents will be true\n      // if we're using SlotContentMixin, but we don't want to actually raise\n      // the event then because the items didn't change in response to user\n      // activity.\n      if (!this[firstRender] && changed.items && this[raiseChangeEvents]) {\n        const oldEvent = new CustomEvent(\"items-changed\", {\n          bubbles: true,\n        });\n        this.dispatchEvent(oldEvent);\n        /**\n         * Raised when the `items` property changes.\n         *\n         * @event itemschange\n         */\n        const event = new CustomEvent(\"itemschange\", {\n          bubbles: true,\n        });\n        this.dispatchEvent(event);\n      }\n    }\n  }\n\n  return ItemsAPI;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  closestAvailableItemIndex,\n  defaultState,\n  goFirst,\n  goLast,\n  goNext,\n  goPrevious,\n  setState,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\n/**\n * Tracks and navigates the current item in a set of items\n *\n * @module ItemsCursorMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function ItemsCursorMixin(Base) {\n  // The class prototype added by the mixin.\n  class ItemsCursor extends Base {\n    /**\n     * Look for an item which is available in the given state..\n     *\n     * The `options` parameter can accept options for:\n     *\n     * * `direction`: 1 to move forward, -1 to move backward\n     * * `index`: the index to start at, defaults to `state.currentIndex`\n     * * `wrap`: whether to wrap around the ends of the `items` array, defaults\n     *   to `state.cursorOperationsWrap`.\n     *\n     * If an available item was found, this returns its index. If no item was\n     * found, this returns -1.\n     *\n     * @param {PlainObject} state\n     * @param {PlainObject} options\n     * @returns {number}\n     */\n    [closestAvailableItemIndex](state, options = {}) {\n      const direction = options.direction !== undefined ? options.direction : 1;\n      const index =\n        options.index !== undefined ? options.index : state.currentIndex;\n      const wrap =\n        options.wrap !== undefined ? options.wrap : state.cursorOperationsWrap;\n\n      const { items } = state;\n      const count = items ? items.length : 0;\n\n      if (count === 0) {\n        // No items\n        return -1;\n      }\n\n      if (wrap) {\n        // Search with wrapping.\n\n        // Modulus taking into account negative numbers.\n        let i = ((index % count) + count) % count;\n        const end = (((i - direction) % count) + count) % count;\n        while (i !== end) {\n          const available = state.availableItemFlags\n            ? state.availableItemFlags[i]\n            : true;\n          if (available) {\n            return i;\n          }\n          // See modulus note above.\n          i = (((i + direction) % count) + count) % count;\n        }\n      } else {\n        // Search without wrapping.\n        for (let i = index; i >= 0 && i < count; i += direction) {\n          const available = state.availableItemFlags\n            ? state.availableItemFlags[i]\n            : true;\n          if (available) {\n            return i;\n          }\n        }\n      }\n\n      return -1; // No item found\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        currentIndex: -1,\n        desiredCurrentIndex: null,\n        currentItem: null,\n        currentItemRequired: false,\n        cursorOperationsWrap: false,\n      });\n    }\n\n    /**\n     * Move to the first item in the set.\n     *\n     * @protected\n     * @returns {Boolean} True if the current item changed, false if not.\n     */\n    [goFirst]() {\n      if (super[goFirst]) {\n        super[goFirst]();\n      }\n      return moveToIndex(this, 0, 1);\n    }\n\n    /**\n     * Move to the last item in the set.\n     *\n     * @protected\n     * @returns {Boolean} True if the current item changed, false if not.\n     */\n    [goLast]() {\n      if (super[goLast]) {\n        super[goLast]();\n      }\n      return moveToIndex(this, this[state].items.length - 1, -1);\n    }\n\n    /**\n     * Move to the next item in the set.\n     *\n     * If no item is current, move to the first item.\n     *\n     * @protected\n     * @returns {Boolean} True if the current item changed, false if not.\n     */\n    [goNext]() {\n      if (super[goNext]) {\n        super[goNext]();\n      }\n      const { currentIndex, items } = this[state];\n      const start = currentIndex < 0 && items ? 0 : currentIndex + 1;\n      return moveToIndex(this, start, 1);\n    }\n\n    /**\n     * Move to the previous item in the set.\n     *\n     * If no item is current, move to the last item.\n     *\n     * @protected\n     * @returns {Boolean} True if the current item changed, false if not.\n     */\n    [goPrevious]() {\n      if (super[goPrevious]) {\n        super[goPrevious]();\n      }\n      const { currentIndex, items } = this[state];\n      const start =\n        currentIndex < 0 && items ? items.length - 1 : currentIndex - 1;\n      return moveToIndex(this, start, -1);\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // Ensure currentIndex is valid.\n      if (\n        changed.availableItemFlags ||\n        changed.items ||\n        changed.currentIndex ||\n        changed.currentItemRequired\n      ) {\n        const {\n          currentIndex,\n          desiredCurrentIndex,\n          currentItem,\n          currentItemRequired,\n          items,\n        } = state;\n\n        const count = items ? items.length : 0;\n\n        // Determine the desired index: the one we want irrespective of whether\n        // we have items or their availability.\n        // Assume we'll stick with the same desired index we already have.\n        let newDesiredIndex = desiredCurrentIndex;\n        if (\n          changed.items &&\n          !changed.currentIndex &&\n          currentItem &&\n          count > 0 &&\n          items[currentIndex] !== currentItem\n        ) {\n          // The items changed, and the item at the cursor is no longer the\n          // same. See if we can find that item again in the list of items.\n          const newItemIndex = items.indexOf(currentItem);\n          if (newItemIndex >= 0) {\n            // Found the item again; try to use its index.\n            newDesiredIndex = newItemIndex;\n          }\n        } else if (\n          changed.currentIndex &&\n          ((currentIndex < 0 && currentItem !== null) ||\n            (currentIndex >= 0 &&\n              (count === 0 || items[currentIndex] !== currentItem)) ||\n            desiredCurrentIndex === null)\n        ) {\n          // Someone explicitly moved the cursor, which trumps any previously\n          // desired index.\n          newDesiredIndex = currentIndex;\n        }\n\n        // If an item is required and there's no selection, we'll implicitly try\n        // to get the first available item.\n        if (currentItemRequired && newDesiredIndex < 0) {\n          newDesiredIndex = 0;\n        }\n\n        // Now that we know what index we want, see how close we can get to it.\n        let newIndex;\n        if (newDesiredIndex < 0) {\n          // All negative indices are equivalent to -1.\n          newDesiredIndex = -1;\n          newIndex = -1;\n        } else if (count === 0) {\n          // No items yet.\n          newIndex = -1;\n        } else {\n          // See how close we can get to the desired index.\n          // First clamp index to existing array bounds.\n          newIndex = Math.max(Math.min(count - 1, newDesiredIndex), 0);\n          // Look for an available item going forward.\n          newIndex = this[closestAvailableItemIndex](state, {\n            direction: 1,\n            index: newIndex,\n            wrap: false,\n          });\n          if (newIndex < 0) {\n            // Next best: look for an available item going backward.\n            newIndex = this[closestAvailableItemIndex](state, {\n              direction: -1,\n              index: newIndex - 1,\n              wrap: false,\n            });\n          }\n        }\n\n        const newItem = (items && items[newIndex]) || null;\n        Object.assign(effects, {\n          currentIndex: newIndex,\n          desiredCurrentIndex: newDesiredIndex,\n          currentItem: newItem,\n        });\n      }\n\n      return effects;\n    }\n  }\n\n  return ItemsCursor;\n}\n\n/**\n * Update currentIndex and return true if it changed.\n *\n * @private\n * @param {Element} element\n * @param {number} index\n * @param {number} direction\n */\nfunction moveToIndex(element, index, direction) {\n  const newIndex = element[closestAvailableItemIndex](element[state], {\n    direction,\n    index,\n  });\n  if (newIndex < 0) {\n    // Couldn't find an item to move to.\n    return false;\n  }\n  // Normally we don't check to see if state is going to change before setting\n  // state, but the methods defined by this mixin want to be able to return true\n  // if the index is actually going to change.\n  const changed = element[state].currentIndex !== newIndex;\n  if (changed) {\n    element[setState]({\n      currentIndex: newIndex,\n    });\n  }\n  return changed;\n}\n","/**\n * Helpers for working with element content.\n *\n * @module content\n */\n\n// These are tags for elements that can appear in the document body, but do not\n// seem to have any user-visible manifestation.\n// See https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst auxiliarycustomTags = [\n  \"applet\", // deprecated\n  \"basefont\", // deprecated\n  \"embed\",\n  \"font\", // deprecated\n  \"frame\", // deprecated\n  \"frameset\", // deprecated\n  \"isindex\", // deprecated\n  \"keygen\", // deprecated\n  \"link\",\n  \"multicol\", // deprecated\n  \"nextid\", // deprecated\n  \"noscript\",\n  \"object\",\n  \"param\",\n  \"script\",\n  \"style\",\n  \"template\",\n  \"noembed\", // deprecated\n];\n\n/**\n * Use a heuristic to extract text from the given item.\n *\n * This looks, in order, at: the `aria-label` attribute, the `alt` attribute,\n * `innerText`, or `textContent`.\n *\n * This function is used as the default implementation of the\n * [getItemText](internal#getItemText) function in several mixins.\n *\n * @param {Element} element\n * @returns {string}\n */\nexport function getDefaultText(element) {\n  return (\n    element.getAttribute(\"aria-label\") ||\n    element.getAttribute(\"alt\") ||\n    /** @type {any} */ (element).innerText ||\n    element.textContent ||\n    \"\"\n  );\n}\n\n/**\n * Return true if the given node is likely to be useful as component content.\n *\n * This will be `true` for nodes that are: a) instances of `Element`\n * (`HTMLElement` or `SVGElement`), and b) not on a blacklist of normally\n * invisible elements (such as `style` or `script`). Among other things, this\n * returns `false` for Text nodes.\n *\n * This is used by [ContentItemsMixin](ContentItemsMixin) to filter out nodes\n * which are unlikely to be interesting as list items. This is intended to\n * satisfy the Gold Standard checklist criteria [Auxiliary\n * Content](https://github.com/webcomponents/gold-standard/wiki/Auxiliary-Content),\n * so that a component does not inadvertently treat `<style>` and other invisible\n * items as element content.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isSubstantiveElement(node) {\n  return (\n    node instanceof Element &&\n    (!node.localName || auxiliarycustomTags.indexOf(node.localName) < 0)\n  );\n}\n\n/**\n * Return a set of Elements which are likely to be useful as component content.\n *\n * Given a `NodeList` or array of objects, this will return only those array\n * members that are: a) instances of `Element` (`HTMLElement` or `SVGElement`),\n * and b) not on a blacklist of normally invisible elements (such as `style` or\n * `script`). Among other things, this filters out Text nodes.\n *\n * @param {(NodeList|Node[])} nodes - the list of nodes to filter\n * @returns {Element[]} the filtered elements\n */\nexport function substantiveElements(nodes) {\n  return [].filter.call(nodes, (/** @type {Node} */ node) =>\n    isSubstantiveElement(node)\n  );\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { getDefaultText } from \"./content.js\";\nimport { defaultState, getItemText, stateEffects } from \"./internal.js\";\n\n/**\n * Exposes the text content of a list's items as an array of strings.\n *\n * @module ItemsTextMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function ItemsTextMixin(Base) {\n  // The class prototype added by the mixin.\n  class ItemsText extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        texts: null,\n      });\n    }\n\n    /**\n     * Extract the text from the given item.\n     *\n     * The default implementation returns an item's `aria-label`, `alt`\n     * attribute, `innerText`, or `textContent`, in that order. You can override\n     * this to return the text that should be used.\n     *\n     * @param {Element} item\n     * @returns {string}\n     */\n    [getItemText](item) {\n      return super[getItemText]\n        ? super[getItemText](item)\n        : getDefaultText(item);\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // Regenerate texts when items change.\n      if (changed.items) {\n        const { items } = state;\n        const texts = getTextsFromItems(items, this[getItemText]);\n        if (texts) {\n          Object.freeze(texts);\n          Object.assign(effects, { texts });\n        }\n      }\n\n      return effects;\n    }\n  }\n\n  return ItemsText;\n}\n\n/**\n * Extract the text from the given items.\n *\n * @private\n * @param {Element[]} items\n */\nexport function getTextsFromItems(items, getText) {\n  return items ? Array.from(items, (item) => getText(item)) : null;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  goDown,\n  goEnd,\n  goLeft,\n  goRight,\n  goStart,\n  goUp,\n  keydown,\n  state,\n} from \"./internal.js\";\n\n/**\n * Maps direction keys to direction semantics.\n *\n * This mixin is useful for components that want to map direction keys (Left,\n * Right, etc.) to movement in the indicated direction (go left, go right,\n * etc.).\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin) for that\n * purpose, or wire up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin calls methods such as `goLeft` and `goRight`. You can define\n * what that means by implementing those methods yourself. If you want to use\n * direction keys to navigate a selection, use this mixin with\n * [DirectionCursorMixin](DirectionCursorMixin).\n *\n * If the component defines a property called `orientation`, the value of that\n * property will constrain navigation to the horizontal or vertical axis.\n *\n * @module KeyboardDirectionMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function KeyboardDirectionMixin(Base) {\n  // The class prototype added by the mixin.\n  class KeyboardDirection extends Base {\n    /**\n     * Invoked when the user wants to go/navigate down.\n     * The default implementation of this method does nothing.\n     */\n    [goDown]() {\n      if (super[goDown]) {\n        return super[goDown]();\n      }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the end (e.g., of a list).\n     * The default implementation of this method does nothing.\n     */\n    [goEnd]() {\n      if (super[goEnd]) {\n        return super[goEnd]();\n      }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate left.\n     * The default implementation of this method does nothing.\n     */\n    [goLeft]() {\n      if (super[goLeft]) {\n        return super[goLeft]();\n      }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate right.\n     * The default implementation of this method does nothing.\n     */\n    [goRight]() {\n      if (super[goRight]) {\n        return super[goRight]();\n      }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate to the start (e.g., of a\n     * list). The default implementation of this method does nothing.\n     */\n    [goStart]() {\n      if (super[goStart]) {\n        return super[goStart]();\n      }\n    }\n\n    /**\n     * Invoked when the user wants to go/navigate up.\n     * The default implementation of this method does nothing.\n     */\n    [goUp]() {\n      if (super[goUp]) {\n        return super[goUp]();\n      }\n    }\n\n    [keydown](/** @type {KeyboardEvent} */ event) {\n      let handled = false;\n\n      // Direction keys generally are low-priority keys: if a shadow element\n      // like an input has focus, we want to let that focused element handle\n      // direction keys. So we only handle the event if we're the target.\n      //\n      // (We'd really like to be able to provide direction key handling as a\n      // default — i.e., if the focused element doesn't handle a key, then we\n      // would handle it here. Unfortunately, there doesn't seem to be any\n      // general way for us to do that.)\n      if (event.target === this) {\n        // Respect orientation state if defined, otherwise assume \"both\".\n        const orientation = this[state].orientation || \"both\";\n        const horizontal =\n          orientation === \"horizontal\" || orientation === \"both\";\n        const vertical = orientation === \"vertical\" || orientation === \"both\";\n\n        // Ignore Left/Right keys when metaKey or altKey modifier is also pressed,\n        // as the user may be trying to navigate back or forward in the browser.\n        switch (event.key) {\n          case \"ArrowDown\":\n            if (vertical) {\n              handled = event.altKey ? this[goEnd]() : this[goDown]();\n            }\n            break;\n\n          case \"ArrowLeft\":\n            if (horizontal && !event.metaKey && !event.altKey) {\n              handled = this[goLeft]();\n            }\n            break;\n\n          case \"ArrowRight\":\n            if (horizontal && !event.metaKey && !event.altKey) {\n              handled = this[goRight]();\n            }\n            break;\n\n          case \"ArrowUp\":\n            if (vertical) {\n              handled = event.altKey ? this[goStart]() : this[goUp]();\n            }\n            break;\n\n          case \"End\":\n            handled = this[goEnd]();\n            break;\n\n          case \"Home\":\n            handled = this[goStart]();\n            break;\n        }\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[keydown] && super[keydown](event)) || false;\n    }\n  }\n\n  return KeyboardDirection;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  defaultTabIndex,\n  delegatesFocus,\n  keydown,\n  raiseChangeEvents,\n  render,\n  rendering,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Manages keyboard handling for a component.\n *\n * This mixin handles several keyboard-related features.\n *\n * First, it wires up a single keydown event handler that can be shared by\n * multiple mixins on a component. The event handler will invoke a `keydown`\n * method with the event object, and any mixin along the prototype chain that\n * wants to handle that method can do so.\n *\n * If a mixin wants to indicate that keyboard event has been handled, and that\n * other mixins should *not* handle it, the mixin's `keydown` handler should\n * return a value of true. The convention that seems to work well is that a\n * mixin should see if it wants to handle the event and, if not, then ask the\n * superclass to see if it wants to handle the event. This has the effect of\n * giving the mixin that was applied last the first chance at handling a\n * keyboard event.\n *\n * Example:\n *\n *     [keydown](event) {\n *       let handled;\n *       switch (event.key) {\n *         // Handle the keys you want, setting handled = true if appropriate.\n *       }\n *       // Prefer mixin result if it's defined, otherwise use base result.\n *       return handled || (super[keydown] && super[keydown](event));\n *     }\n *\n * A second feature provided by this mixin is that it implicitly makes the\n * component a tab stop if it isn't already, by setting `tabindex` to 0. This\n * has the effect of adding the component to the tab order in document order.\n *\n * @module KeyboardMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function KeyboardMixin(Base) {\n  // The class prototype added by the mixin.\n  class Keyboard extends Base {\n    constructor() {\n      // @ts-ignore\n      super();\n      this.addEventListener(\"keydown\", async (event) => {\n        this[raiseChangeEvents] = true;\n        // For use with FocusVisibleMixin.\n        if (!this[state].focusVisible) {\n          // The user may have begun interacting with this element using the\n          // mouse/touch, but has now begun using the keyboard, so show focus.\n          this[setState]({\n            focusVisible: true,\n          });\n        }\n        const handled = this[keydown](event);\n        if (handled) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n        }\n        await Promise.resolve();\n        this[raiseChangeEvents] = false;\n      });\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"tabindex\") {\n        // Parse the passed value, which could be a string or null.\n        let parsed;\n        if (newValue === null) {\n          // tabindex attribute was removed.\n          parsed = -1;\n        } else {\n          parsed = Number(newValue);\n          if (isNaN(parsed)) {\n            // Non-numeric tabindex falls back to default value (if defined).\n            parsed = this[defaultTabIndex] ? this[defaultTabIndex] : 0;\n          }\n        }\n        this.tabIndex = parsed;\n      } else {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      // If we're using DelegateFocusMixin, we don't need or want to set a\n      // tabindex on the host; we'll rely on the inner shadow elements to take\n      // the focus and raise keyboard events. Otherwise, we do set a tabindex on\n      // the host, so that we can get keyboard events.\n      const tabIndex = this[delegatesFocus] ? -1 : 0;\n      const state = Object.assign(super[defaultState] || {}, {\n        tabIndex,\n      });\n\n      return state;\n    }\n\n    /**\n     * See the [symbols](internal#internal.keydown) documentation for details.\n     */\n    [keydown](/** @type {KeyboardEvent} */ event) {\n      if (super[keydown]) {\n        return super[keydown](event);\n      }\n      return false;\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n      if (changed.tabIndex) {\n        this.tabIndex = this[state].tabIndex;\n      }\n    }\n\n    // Record our own notion of the state of the tabIndex property so we can\n    // rerender if necessary.\n    get tabIndex() {\n      return super.tabIndex;\n    }\n    set tabIndex(tabIndex) {\n      // If value has changed, invoke the super setter.\n      if (super.tabIndex !== tabIndex) {\n        super.tabIndex = tabIndex;\n      }\n\n      // The tabIndex setter can get called during rendering when we render our\n      // own notion of the tabIndex state, in which case we don't need or want\n      // to set state again.\n      if (!this[rendering]) {\n        // Record the new tabIndex in our state.\n        this[setState]({\n          tabIndex,\n        });\n      }\n    }\n  }\n\n  return Keyboard;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  closestAvailableItemIndex,\n  keydown,\n  raiseChangeEvents,\n  scrollTarget,\n  setState,\n  state,\n} from \"./internal.js\";\nimport { defaultScrollTarget } from \"./scrolling.js\";\n\n/**\n * Maps the Page Up and Page Down keys to item cursor operations.\n *\n * The keyboard interaction model generally follows that of Microsoft Windows'\n * list boxes instead of those in OS X:\n *\n * * The Page Up/Down and Home/End keys actually move the item cursor, rather\n *   than just scrolling. The former behavior seems more generally useful for\n *   keyboard users.\n *\n * * Pressing Page Up/Down will first move the cursor to the topmost/bottommost\n *   visible item if the cursor is not already there. Thereafter, the key\n *   will move the cursor up/down by a page, and (per the above point) make\n *   the current item visible.\n *\n * To ensure the current item is in view following use of Page Up/Down, use\n * the related [CursorInViewMixin](CursorInViewMixin).\n *\n * This mixin expects the component to provide:\n *\n * * A `[keydown]` method invoked when a key is pressed. You can use\n *   [KeyboardMixin](KeyboardMixin) for that purpose, or wire up your own\n *   keyboard handling and call `[keydown]` yourself.\n * * A `currentIndex` state member updatable via [setState]`.\n *\n * @module KeyboardPagedCursorMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function KeyboardPagedCursorMixin(Base) {\n  // The class prototype added by the mixin.\n  class KeyboardPagedCursor extends Base {\n    [keydown](/** @type {KeyboardEvent} */ event) {\n      let handled = false;\n      const orientation = this.orientation;\n      if (orientation !== \"horizontal\") {\n        switch (event.key) {\n          case \"PageDown\":\n            handled = this.pageDown();\n            break;\n\n          case \"PageUp\":\n            handled = this.pageUp();\n            break;\n        }\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[keydown] && super[keydown](event));\n    }\n\n    // Default orientation implementation defers to super,\n    // but if not found, looks in state.\n    get orientation() {\n      return (\n        super.orientation || (this[state] && this[state].orientation) || \"both\"\n      );\n    }\n\n    /**\n     * Scroll down one page.\n     */\n    pageDown() {\n      if (super.pageDown) {\n        super.pageDown();\n      }\n      return scrollOnePage(this, true);\n    }\n\n    /**\n     * Scroll up one page.\n     */\n    pageUp() {\n      if (super.pageUp) {\n        super.pageUp();\n      }\n      return scrollOnePage(this, false);\n    }\n\n    /**\n     * The element that will be scrolled when the user presses Page Up or\n     * Page Down. The default value is calculated by\n     * [defaultScrollTarget](defaultScrollTarget#defaultScrollTarget).\n     *\n     * See [scrollTarget](internal#internal.scrollTarget).\n     *\n     * @type {HTMLElement}\n     */\n    get [scrollTarget]() {\n      /** @type {any} */\n      const element = this;\n      return super[scrollTarget] || defaultScrollTarget(element);\n    }\n  }\n\n  return KeyboardPagedCursor;\n}\n\n/**\n * Return the item whose content spans the given y position (relative to the\n * top of the list's scrolling client area), or null if not found.\n *\n * If downward is true, move down the list of items to find the first item\n * found at the given y position; if downward is false, move up the list of\n * items to find the last item at that position.\n *\n * @private\n * @param {ReactiveElement} element\n * @param {number} y\n * @param {boolean} downward\n */\nfunction getIndexOfItemAtY(element, y, downward) {\n  const items = element[state].items;\n  const start = downward ? 0 : items.length - 1;\n  const end = downward ? items.length : 0;\n  const step = downward ? 1 : -1;\n\n  // Find the item spanning the indicated y coordinate.\n  let index;\n  /** @type {HTMLElement|SVGElement|null} */ let item = null;\n  let itemRect;\n  const { availableItemFlags } = element[state];\n  for (index = start; index !== end; index += step) {\n    // Only consider items available in the element's current state.\n    const available = availableItemFlags ? availableItemFlags[index] : true;\n    if (available) {\n      itemRect = items[index].getBoundingClientRect();\n      if (itemRect.top <= y && y <= itemRect.bottom) {\n        // Item spans the indicated y coordinate.\n        item = items[index];\n        break;\n      }\n    }\n  }\n\n  if (!item || !itemRect) {\n    return null;\n  }\n\n  // We may have found an item whose padding spans the given y coordinate,\n  // but whose content is actually above/below that point.\n  // TODO: If the item has a border, then padding should be included in\n  // considering a hit.\n  const itemStyle = getComputedStyle(item);\n  const itemPaddingTop = itemStyle.paddingTop\n    ? parseFloat(itemStyle.paddingTop)\n    : 0;\n  const itemPaddingBottom = itemStyle.paddingBottom\n    ? parseFloat(itemStyle.paddingBottom)\n    : 0;\n  const contentTop = itemRect.top + itemPaddingTop;\n  const contentBottom =\n    contentTop + item.clientHeight - itemPaddingTop - itemPaddingBottom;\n  if ((downward && contentTop <= y) || (!downward && contentBottom >= y)) {\n    // The indicated coordinate hits the actual item content.\n    return index;\n  } else {\n    // The indicated coordinate falls within the item's padding. Back up to\n    // the item below/above the item we found and return that.\n    return index - step;\n  }\n}\n\n/**\n * Move by one page downward (if downward is true), or upward (if false).\n * Return true if we ended up moving the cursor, false if not.\n *\n * @private\n * @param {ReactiveElement} element\n * @param {boolean} downward\n */\nfunction scrollOnePage(element, downward) {\n  const items = element[state].items;\n  const currentIndex = element[state].currentIndex;\n\n  // Determine the item visible just at the edge of direction we're heading.\n  // We'll move to that item if it's not already current.\n  const targetRect = element[scrollTarget].getBoundingClientRect();\n  const edge = downward ? targetRect.bottom : targetRect.top;\n  const indexOfItemAtEdge = getIndexOfItemAtY(element, edge, downward);\n\n  let newIndex;\n  if (indexOfItemAtEdge && currentIndex === indexOfItemAtEdge) {\n    // The item at the edge was already current, so scroll in the indicated\n    // direction by one page, measuring from the bounds of the current item.\n    // Leave the new item at that edge current.\n    const currentItem = items[currentIndex];\n    const currentRect = currentItem.getBoundingClientRect();\n    const pageHeight = element[scrollTarget].clientHeight;\n    const y = downward\n      ? currentRect.bottom + pageHeight\n      : currentRect.top - pageHeight;\n    newIndex = getIndexOfItemAtY(element, y, downward);\n  } else {\n    // The item at the edge wasn't current yet. Instead of scrolling, we'll just\n    // move to that item. That is, the first attempt to page up/down usually\n    // just moves the cursor to the edge in that direction.\n    newIndex = indexOfItemAtEdge;\n  }\n\n  if (!newIndex) {\n    // We went past the first/last item without finding an item. Move to the\n    // last item (if moving downward) or first item (if moving upward).\n    const index = downward ? items.length - 1 : 0;\n    newIndex = element[closestAvailableItemIndex]\n      ? element[closestAvailableItemIndex](element[state], {\n          direction: downward ? -1 /* Work up */ : 1 /* Work down */,\n          index,\n        })\n      : index;\n  }\n\n  const changed = newIndex !== currentIndex;\n  if (changed) {\n    // If external code causes an operation that scrolls the page, it's\n    // impossible for it to predict where the currentIndex is going to end up.\n    // Accordingly, we raise change events.\n    const saveRaiseChangesEvents = element[raiseChangeEvents];\n    element[raiseChangeEvents] = true;\n    element[setState]({\n      currentIndex: newIndex,\n    });\n    element[raiseChangeEvents] = saveRaiseChangesEvents;\n  }\n  return changed;\n}\n","/**\n * Constants used by Elix mixins and components\n *\n * Sharing these constants allows for greater consistency in things such as user\n * interface timings.\n *\n * @module constants\n */\n\n/**\n * Time in milliseconds after which the user is considered to have stopped\n * typing.\n *\n * This is used by\n * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin).\n *\n * @const {number} TYPING_TIMEOUT_DURATION\n */\nexport const TYPING_TIMEOUT_DURATION = 1000;\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { TYPING_TIMEOUT_DURATION } from \"./constants.js\";\nimport { goToItemWithPrefix, keydown, setState, state } from \"./internal.js\";\n\n// Symbols for private data members on an element.\nconst typedPrefixKey = Symbol(\"typedPrefix\");\nconst prefixTimeoutKey = Symbol(\"prefixTimeout\");\n\n/**\n * Lets a user navigate an item cursor by typing the beginning of items\n *\n * Example: suppose a component using this mixin has the following items:\n *\n *     <sample-list-component>\n *       <div>Apple</div>\n *       <div>Apricot</div>\n *       <div>Banana</div>\n *       <div>Blackberry</div>\n *       <div>Blueberry</div>\n *       <div>Cantaloupe</div>\n *       <div>Cherry</div>\n *       <div>Lemon</div>\n *       <div>Lime</div>\n *     </sample-list-component>\n *\n * If this component receives the focus, and the user presses the \"b\" or \"B\"\n * key, the item cursor will move to \"Banana\", because it's the first item that\n * matches the prefix \"b\". (Matching is case-insensitive.) If the user now\n * presses the \"l\" or \"L\" key quickly, the prefix to match becomes \"bl\", so the\n * cursor will move to \"Blackberry\".\n *\n * The prefix typing feature has a one second timeout — the prefix to match will\n * be reset after a second has passed since the user last typed a key. If, in\n * the above example, the user waits a second between typing \"b\" and \"l\", the\n * prefix will become \"l\", so the cursor would move to \"Lemon\".\n *\n * This mixin expects the component to invoke a `keydown` method when a key is\n * pressed. You can use [KeyboardMixin](KeyboardMixin) for that purpose, or wire\n * up your own keyboard handling and call `keydown` yourself.\n *\n * This mixin also expects the component to provide an `items` property. The\n * `textContent` of those items will be used for purposes of prefix matching.\n *\n * @module KeyboardPrefixCursorMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function KeyboardPrefixCursorMixin(Base) {\n  // The class prototype added by the mixin.\n  class KeyboardPrefixCursor extends Base {\n    constructor() {\n      // @ts-ignore\n      super();\n      resetTypedPrefix(this);\n    }\n\n    /**\n     * Go to the first item whose text content begins with the given prefix.\n     *\n     * @param {string} prefix - The prefix string to search for\n     * @returns {boolean}\n     */\n    [goToItemWithPrefix](prefix) {\n      if (super[goToItemWithPrefix]) {\n        super[goToItemWithPrefix](prefix);\n      }\n      if (prefix == null || prefix.length === 0) {\n        return false;\n      }\n      // Find item that begins with the prefix. Ignore case.\n      const searchText = prefix.toLowerCase();\n      /** @type {string[]} */ const texts = this[state].texts;\n      const index = texts.findIndex(\n        (text) => text.substr(0, prefix.length).toLowerCase() === searchText\n      );\n      if (index >= 0) {\n        const previousIndex = this[state].currentIndex;\n        this[setState]({ currentIndex: index });\n        return this[state].currentIndex !== previousIndex;\n      } else {\n        return false;\n      }\n    }\n\n    [keydown](/** @type {KeyboardEvent} */ event) {\n      let handled;\n\n      switch (event.key) {\n        case \"Backspace\":\n          handleBackspace(this);\n          handled = true;\n          break;\n\n        case \"Escape\":\n          // Pressing Escape lets user quickly start typing a new prefix.\n          resetTypedPrefix(this);\n          break;\n\n        default:\n          if (\n            !event.ctrlKey &&\n            !event.metaKey &&\n            !event.altKey &&\n            event.key.length === 1\n          ) {\n            handlePlainCharacter(this, event.key);\n          }\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super[keydown] && super[keydown](event));\n    }\n  }\n\n  return KeyboardPrefixCursor;\n}\n\n/**\n * Handle the Backspace key: remove the last character from the prefix.\n *\n * @private\n * @param {ReactiveElement} element\n */\nfunction handleBackspace(element) {\n  /** @type {any} */ const cast = element;\n  const length = cast[typedPrefixKey] ? cast[typedPrefixKey].length : 0;\n  if (length > 0) {\n    cast[typedPrefixKey] = cast[typedPrefixKey].substr(0, length - 1);\n  }\n  element[goToItemWithPrefix](cast[typedPrefixKey]);\n  setPrefixTimeout(element);\n}\n\n/**\n * Add a plain character to the prefix.\n *\n * @private\n * @param {ReactiveElement} element\n * @param {string} char\n */\nfunction handlePlainCharacter(element, char) {\n  /** @type {any} */ const cast = element;\n  const prefix = cast[typedPrefixKey] || \"\";\n  cast[typedPrefixKey] = prefix + char;\n  element[goToItemWithPrefix](cast[typedPrefixKey]);\n  setPrefixTimeout(element);\n}\n\n/**\n * Stop listening for typing.\n *\n * @private\n * @param {ReactiveElement} element\n */\nfunction resetPrefixTimeout(element) {\n  /** @type {any} */ const cast = element;\n  if (cast[prefixTimeoutKey]) {\n    clearTimeout(cast[prefixTimeoutKey]);\n    cast[prefixTimeoutKey] = false;\n  }\n}\n\n/**\n * Clear the prefix under construction.\n *\n * @private\n * @param {ReactiveElement} element\n */\nfunction resetTypedPrefix(element) {\n  /** @type {any} */ (element)[typedPrefixKey] = \"\";\n  resetPrefixTimeout(element);\n}\n\n/**\n * Wait for the user to stop typing.\n *\n * @private\n * @param {ReactiveElement} element\n */\nfunction setPrefixTimeout(element) {\n  resetPrefixTimeout(element);\n  /** @type {any} */ (element)[prefixTimeoutKey] = setTimeout(() => {\n    resetTypedPrefix(element);\n  }, TYPING_TIMEOUT_DURATION);\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { setState } from \"./internal.js\";\n\n/**\n * Lets an element determine whether it resides in right-to-left text.\n *\n * @module LanguageDirectionMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function LanguageDirectionMixin(Base) {\n  // The class prototype added by the mixin.\n  return class LanguageDirection extends Base {\n    // The only way to get text direction is to wait for the component to\n    // connect and then inspect the computed style on its root element. We set\n    // state before calling super so the new state will be included when\n    // ReactiveMixin calls render.\n    connectedCallback() {\n      /** @type {any} */ const element = this;\n      const languageDirection = getComputedStyle(element).direction;\n      const rightToLeft = languageDirection === \"rtl\";\n      this[setState]({ rightToLeft });\n      super.connectedCallback();\n    }\n  };\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { getDefaultText } from \"./content.js\";\nimport {\n  defaultState,\n  getItemText,\n  setState,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\n/**\n * Exposes a public API for the selected text of a list-like element.\n *\n * This mixin exists for list-like components that want to provide a more\n * convenient way to get/set the selected item using text. It adds a `selectedText`\n * property that gets the `textContent` of a component's `selectedItem`. The\n * `selectedText` property can also be set to set the selection to the first item in\n * the `items` collection that has the requested `textContent`. If the indicated\n * text is not found in `items`, the selection is cleared.\n *\n * This mixin expects a component to provide an `items` array of all elements in\n * the list. A standard way to do that with is\n * [ContentItemsMixin](ContentItemsMixin). This also expects the definition of a\n * `selectedIndex` state, which can be obtained from\n * [CursorSelectMixin](CursorSelectMixin).\n *\n * @module SelectedTextAPIMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function SelectedTextAPIMixin(Base) {\n  // The class prototype added by the mixin.\n  class SelectedTextAPI extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        selectedText: \"\",\n      });\n    }\n\n    /**\n     * Extract the text from the given item.\n     *\n     * The default implementation returns an item's `aria-label`, `alt`\n     * attribute, `innerText`, or `textContent`, in that order. You can override\n     * this to return the text that should be used.\n     *\n     * @param {Element} item\n     * @returns {string}\n     */\n    [getItemText](item) {\n      return super[getItemText]\n        ? super[getItemText](item)\n        : getDefaultText(item);\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // selectedText tracks text of selected item\n      if (changed.items || changed.selectedIndex) {\n        const { items, selectedIndex } = state;\n        const selectedItem = items ? items[selectedIndex] : null;\n        const selectedText = selectedItem\n          ? this[getItemText](selectedItem)\n          : \"\";\n        Object.assign(effects, { selectedText });\n      }\n\n      return effects;\n    }\n\n    /**\n     * The text content of the selected item.\n     *\n     * Setting this value to a string will attempt to select the first list item\n     * whose text matches that string. Setting this to a string not matching any\n     * list item will result in no selection.\n     *\n     * @type {string}\n     */\n    get selectedText() {\n      return this[state].selectedText;\n    }\n    set selectedText(selectedText) {\n      // Find index of item with desired text.\n      const { items } = this[state];\n      const selectedIndex = items\n        ? indexOfItemWithText(items, this[getItemText], String(selectedText))\n        : -1;\n      this[setState]({ selectedIndex });\n    }\n  }\n\n  return SelectedTextAPI;\n}\n\n/**\n * @private\n * @param {Element[]} items\n * @param {string} text\n */\nfunction indexOfItemWithText(items, getText, text) {\n  return items.findIndex((item) => getText(item) === text);\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { defaultState, setState, state, stateEffects } from \"./internal.js\";\n\n/**\n * Exposes a public API for the value of a list-like element.\n *\n * @module SelectedValueAPIMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function SelectedValueAPIMixin(Base) {\n  // The class prototype added by the mixin.\n  class SelectedValueAPI extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        value: \"\",\n      });\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // Value tracks the value attribute on the selected item.\n      if (changed.items || changed.selectedIndex) {\n        const { items, selectedIndex } = state;\n        const selectedItem = items ? items[selectedIndex] : null;\n        const value = selectedItem ? selectedItem.getAttribute(\"value\") : \"\";\n        Object.assign(effects, { value });\n      }\n\n      return effects;\n    }\n\n    /**\n     * The value attribute of the selected item.\n     *\n     * Setting this to a string will attempt to select the first list item whose\n     * value attribute matches that string. Setting this to a string not\n     * matching any value attribute will result in no selection.\n     *\n     * @type {string}\n     */\n    get value() {\n      return this[state].value;\n    }\n    set value(value) {\n      // Find index of item with desired value.\n      const { items } = this[state];\n      const selectedIndex = items\n        ? indexOfItemWithValue(items, String(value))\n        : -1;\n      this[setState]({ selectedIndex });\n    }\n  }\n\n  return SelectedValueAPI;\n}\n\n/**\n * @private\n * @param {Element[]} items\n * @param {string} value\n */\nfunction indexOfItemWithValue(items, value) {\n  return items.findIndex((item) => item.getAttribute(\"value\") === value);\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { raiseChangeEvents, rendered, setState, state } from \"./internal.js\";\n\n/**\n * Exposes a public API for single selection on a list-like element\n *\n * This mixin expects a component to provide an `items` Array of all elements in\n * the list. This mixin also expects the component to apply\n * [ItemsCursorMixin](ItemsCursorMixin) and\n * [CursorSelectMixin](CursorSelectMixin) or otherwise define a compatible\n * `selectedIndex` state and other state members for navigating the current\n * item.\n *\n * Given the above, this mixin exposes a consistent public API for reading and\n * manipulating the current item as a selection. This includes public members\n * `selectedIndex` and `selectedItem`, selection navigation methods, and a\n * `selected-index-changed` event.\n *\n * This mixin does not produce any user-visible effects to represent selection;\n * that is up to the component to provide.\n *\n * @module SingleSelectAPIMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function SingleSelectAPIMixin(Base) {\n  // The class prototype added by the mixin.\n  class SingleSelectAPI extends Base {\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"selected-index\") {\n        this.selectedIndex = Number(newValue);\n      } else {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (changed.selectedIndex && this[raiseChangeEvents]) {\n        const selectedIndex = this[state].selectedIndex;\n        const oldEvent = new CustomEvent(\"selected-index-changed\", {\n          bubbles: true,\n          detail: { selectedIndex },\n        });\n        this.dispatchEvent(oldEvent);\n        /**\n         * Raised when the `selectedIndex` property changes.\n         *\n         * @event selectedindexchange\n         */\n        const event = new CustomEvent(\"selectedindexchange\", {\n          bubbles: true,\n          detail: { selectedIndex },\n        });\n        this.dispatchEvent(event);\n      }\n    }\n\n    /**\n     * The index of the selected item, or -1 if no item is selected.\n     *\n     * @type {number}\n     */\n    get selectedIndex() {\n      const { items, selectedIndex } = this[state];\n      return items && items.length > 0 ? selectedIndex : -1;\n    }\n    set selectedIndex(selectedIndex) {\n      if (!isNaN(selectedIndex)) {\n        this[setState]({ selectedIndex });\n      }\n    }\n\n    /**\n     * The selected item, or null if no item is selected.\n     *\n     * @type {Element}\n     */\n    get selectedItem() {\n      const { items, selectedIndex } = this[state];\n      return items && items[selectedIndex];\n    }\n    set selectedItem(selectedItem) {\n      const { items } = this[state];\n      if (!items) {\n        return;\n      }\n      const index = items.indexOf(selectedItem);\n      if (index >= 0) {\n        this[setState]({ selectedIndex: index });\n      }\n    }\n  }\n\n  return SingleSelectAPI;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  contentSlot,\n  defaultState,\n  firstRender,\n  raiseChangeEvents,\n  rendered,\n  setState,\n  shadowRoot,\n} from \"./internal.js\";\n\n/**\n * Defines a component's content as the flattened set of nodes assigned to a\n * slot.\n *\n * This mixin defines a component's `content` state member as the flattened\n * set of nodes assigned to a slot, typically the default slot.\n *\n * If the set of assigned nodes changes, the `content` state will be updated.\n * This helps a component satisfy the Gold Standard checklist item for\n * monitoring\n * [Content Changes](https://github.com/webcomponents/gold-standard/wiki/Content-Changes).\n *\n * By default, the mixin looks in the component's shadow subtree for a default\n * (unnamed) `slot` element. You can specify that a different slot should be\n * used by overriding the `internal.contentSlot` property.\n *\n * Most Elix [elements](elements) use `SlotContentMixin`, including\n * [ListBox](ListBox), [Modes](Modes), and [Tabs](Tabs).\n *\n * @module SlotContentMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function SlotContentMixin(Base) {\n  // The class prototype added by the mixin.\n  class SlotContent extends Base {\n    /**\n     * See [contentSlot](internal#internal.contentSlot).\n     */\n    get [contentSlot]() {\n      /** @type {HTMLSlotElement|null} */ const slot =\n        this[shadowRoot] && this[shadowRoot].querySelector(\"slot:not([name])\");\n      if (!this[shadowRoot] || !slot) {\n        /* eslint-disable no-console */\n        console.warn(\n          `SlotContentMixin expects ${this.constructor.name} to define a shadow tree that includes a default (unnamed) slot.\\nSee https://elix.org/documentation/SlotContentMixin.`\n        );\n      }\n      return slot;\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        content: null,\n      });\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (this[firstRender]) {\n        // Listen to changes on the default slot.\n        const slot = this[contentSlot];\n        if (slot) {\n          slot.addEventListener(\"slotchange\", async () => {\n            // Although slotchange isn't generally a user-driven event, it's\n            // impossible for us to know whether a change in slot content is going\n            // to result in effects that the host of this element can predict.\n            // To be on the safe side, we raise any change events that come up\n            // during the processing of this event.\n            this[raiseChangeEvents] = true;\n\n            // The nodes assigned to the given component have changed.\n            // Update the component's state to reflect the new content.\n            const content = slot.assignedNodes({ flatten: true });\n            Object.freeze(content);\n            this[setState]({ content });\n\n            await Promise.resolve();\n            this[raiseChangeEvents] = false;\n          });\n        }\n      }\n    }\n  }\n\n  return SlotContent;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport ContentItemsMixin from \"./ContentItemsMixin.js\";\nimport SlotContentMixin from \"./SlotContentMixin.js\";\n\n/**\n * Treats the elements assigned to the default slot as list items\n *\n * This is simply a combination of\n * [ContentItemsMixin](ContentItemsMixin) and\n * [SlotContentMixin](SlotContentMixin).\n *\n * @module SlotItemsMixin\n * @mixes ContentItemsMixin\n * @mixes SlotContentMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function SlotItemsMixin(Base) {\n  return ContentItemsMixin(SlotContentMixin(Base));\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { isSubstantiveElement } from \"./content.js\";\nimport { defaultState, stateEffects } from \"./internal.js\";\n\n/**\n * Treats an element's content nodes as list items.\n *\n * Items differ from nodes contents in several ways:\n *\n * * They are often referenced via index.\n * * They may have a selection state.\n * * It's common to do work to initialize the appearance or state of a new\n *   item.\n * * Text nodes are filtered out.\n * * Auxiliary invisible child elements are filtered out and not counted as\n *   items. Auxiliary elements include link, script, style, and template\n *   elements. This filtering ensures that those auxiliary elements can be\n *   used in markup inside of a list without being treated as list items.\n *\n * This mixin expects a component to provide a `content` state member returning\n * a raw set of elements. You can provide that yourself, or use\n * [SlotContentMixin](SlotContentMixin).\n *\n * Most Elix [elements](elements) use `ContentItemsMixin`, including\n * [ListBox](ListBox), [Modes](Modes), and [Tabs](Tabs).\n *\n * @module ContentItemsMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function ContentItemsMixin(Base) {\n  return class ContentItems extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        items: null,\n      });\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // Regenerate items when content changes.\n      if (changed.content) {\n        /** @type {Node[]} */ const content = state.content;\n        const items = content\n          ? Array.prototype.filter.call(content, (/** @type {Node} */ item) =>\n              isSubstantiveElement(item)\n            )\n          : null;\n        if (items) {\n          Object.freeze(items);\n        }\n        Object.assign(effects, { items });\n      }\n\n      return effects;\n    }\n  };\n}\n","import { indexOfItemContainingTarget } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  firstRender,\n  raiseChangeEvents,\n  render,\n  setState,\n  state,\n  tap,\n} from \"./internal.js\";\n\n/**\n * A tap/mousedown on a list item makes that item current.\n *\n * This simple mixin is useful in list-like elements like [ListBox](ListBox),\n * where a tap/mousedown on a list item implicitly selects it.\n *\n * The standard use for this mixin is in list-like elements. Native list\n * boxes don't appear to be consistent with regard to whether they select\n * on mousedown or click/mouseup. This mixin assumes the use of mousedown.\n * On touch devices, that event appears to trigger when the touch is *released*.\n *\n * This mixin only listens to mousedown events for the primary mouse button\n * (typically the left button). Right clicks are ignored so that the browser may\n * display a context menu.\n *\n * This mixin expects the component to provide an `state.items` member. It also\n * expects the component to define a `state.currentIndex` member; you can\n * provide that yourself, or use [ItemsCursorMixin](ItemsCursorMixin).\n *\n * If the component receives an event that doesn't correspond to an item (e.g.,\n * the user taps on the element background visible between items), the cursor\n * will be removed. However, if the component sets `state.currentItemRequired` to\n * true, a background tap will *not* remove the cursor.\n *\n * @module TapCursorMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function TapCursorMixin(Base) {\n  // The class prototype added by the mixin.\n  return class TapCursor extends Base {\n    constructor() {\n      // @ts-ignore\n      super();\n      this.addEventListener(\"mousedown\", (event) => {\n        // Only process events for the main (usually left) button.\n        if (event.button !== 0) {\n          return;\n        }\n        this[raiseChangeEvents] = true;\n        this[tap](event);\n        this[raiseChangeEvents] = false;\n      });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n      if (this[firstRender]) {\n        Object.assign(this.style, {\n          touchAction: \"manipulation\", // for iOS Safari\n          mozUserSelect: \"none\",\n          msUserSelect: \"none\",\n          webkitUserSelect: \"none\",\n          userSelect: \"none\",\n        });\n      }\n    }\n\n    [tap](/** @type {MouseEvent} */ event) {\n      // In some situations, the event target will not be the child which was\n      // originally clicked on. E.g., if the item clicked on is a button, the\n      // event seems to be raised in phase 2 (AT_TARGET) — but the event target\n      // will be the component, not the item that was clicked on. Instead of\n      // using the event target, we get the first node in the event's composed\n      // path.\n      // @ts-ignore\n      const target = event.composedPath\n        ? event.composedPath()[0]\n        : event.target;\n\n      // Find which item was clicked on and, if found, make it current. Ignore\n      // clicks on disabled items.\n      //\n      // For elements which don't require a cursor, a background click will\n      // determine the item was null, in which we case we'll remove the cursor.\n      const { items, currentItemRequired } = this[state];\n      if (items && target instanceof Node) {\n        const targetIndex = indexOfItemContainingTarget(items, target);\n        const item = targetIndex >= 0 ? items[targetIndex] : null;\n        if ((item && !item.disabled) || (!item && !currentItemRequired)) {\n          this[setState]({\n            currentIndex: targetIndex,\n          });\n          event.stopPropagation();\n        }\n      }\n    }\n  };\n}\n","import { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport AriaListMixin from \"./AriaListMixin.js\";\nimport ComposedFocusMixin from \"./ComposedFocusMixin.js\";\nimport CursorAPIMixin from \"./CursorAPIMixin.js\";\nimport CursorInViewMixin from \"./CursorInViewMixin.js\";\nimport CursorSelectMixin from \"./CursorSelectMixin.js\";\nimport DirectionCursorMixin from \"./DirectionCursorMixin.js\";\nimport FocusVisibleMixin from \"./FocusVisibleMixin.js\";\nimport FormElementMixin from \"./FormElementMixin.js\";\nimport {\n  defaultState,\n  ids,\n  render,\n  scrollTarget,\n  setState,\n  state,\n  template,\n} from \"./internal.js\";\nimport ItemsAPIMixin from \"./ItemsAPIMixin.js\";\nimport ItemsCursorMixin from \"./ItemsCursorMixin.js\";\nimport ItemsTextMixin from \"./ItemsTextMixin.js\";\nimport KeyboardDirectionMixin from \"./KeyboardDirectionMixin.js\";\nimport KeyboardMixin from \"./KeyboardMixin.js\";\nimport KeyboardPagedCursorMixin from \"./KeyboardPagedCursorMixin.js\";\nimport KeyboardPrefixCursorMixin from \"./KeyboardPrefixCursorMixin.js\";\nimport LanguageDirectionMixin from \"./LanguageDirectionMixin.js\";\nimport SelectedTextAPIMixin from \"./SelectedTextAPIMixin.js\";\nimport SelectedValueAPIMixin from \"./SelectedValueAPIMixin.js\";\nimport SingleSelectAPIMixin from \"./SingleSelectAPIMixin.js\";\nimport SlotItemsMixin from \"./SlotItemsMixin.js\";\nimport TapCursorMixin from \"./TapCursorMixin.js\";\n\nconst Base = AriaListMixin(\n  ComposedFocusMixin(\n    CursorAPIMixin(\n      CursorInViewMixin(\n        CursorSelectMixin(\n          DirectionCursorMixin(\n            FocusVisibleMixin(\n              FormElementMixin(\n                ItemsAPIMixin(\n                  ItemsCursorMixin(\n                    ItemsTextMixin(\n                      KeyboardDirectionMixin(\n                        KeyboardMixin(\n                          KeyboardPagedCursorMixin(\n                            KeyboardPrefixCursorMixin(\n                              LanguageDirectionMixin(\n                                SingleSelectAPIMixin(\n                                  SelectedTextAPIMixin(\n                                    SelectedValueAPIMixin(\n                                      SlotItemsMixin(\n                                        TapCursorMixin(ReactiveElement)\n                                      )\n                                    )\n                                  )\n                                )\n                              )\n                            )\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n);\n\n/**\n * Single-selection list box\n *\n * This component supports ARIA support and full keyboard navigation. See\n * [KeyboardDirectionMixin](KeyboardDirectionMixin),\n * [KeyboardPagedCursorMixin](KeyboardPagedCursorMixin), and\n * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin) for keyboard\n * details.\n *\n * @inherits ReactiveElement\n * @mixes AriaListMixin\n * @mixes ComposedFocusMixin\n * @mixes CursorInViewMixin\n * @mixes CursorAPIMixin\n * @mixes DirectionCursorMixin\n * @mixes FocusVisibleMixin\n * @mixes FormElementMixin\n * @mixes ItemsAPIMixin\n * @mixes ItemsCursorMixin\n * @mixes ItemsTextMixin\n * @mixes KeyboardDirectionMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardPagedCursorMixin\n * @mixes KeyboardPrefixCursorMixin\n * @mixes LanguageDirectionMixin\n * @mixes SelectedTextAPIMixin\n * @mixes SelectedValueAPIMixin\n * @mixes SingleSelectAPIMixin\n * @mixes SlotItemsMixin\n * @mixes TapCursorMixin\n */\nclass ListBox extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      orientation: \"vertical\",\n    });\n  }\n\n  get orientation() {\n    return this[state].orientation;\n  }\n  set orientation(orientation) {\n    this[setState]({ orientation });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n    if (changed.items || changed.currentIndex) {\n      // Apply `selected` style to the selected item only.\n      const { currentIndex, items } = this[state];\n      if (items) {\n        items.forEach((item, index) => {\n          item.toggleAttribute(\"selected\", index === currentIndex);\n        });\n      }\n    }\n    if (changed.orientation) {\n      // Update list orientation styling.\n      const style =\n        this[state].orientation === \"vertical\"\n          ? {\n              display: \"block\",\n              flexDirection: \"\",\n              overflowX: \"hidden\",\n              overflowY: \"auto\",\n            }\n          : {\n              display: \"flex\",\n              flexDirection: \"row\",\n              overflowX: \"auto\",\n              overflowY: \"hidden\",\n            };\n      Object.assign(this[ids].container.style, style);\n    }\n  }\n\n  // @ts-ignore\n  get [scrollTarget]() {\n    return this[ids].container;\n  }\n\n  get [template]() {\n    const result = super[template];\n    result.content.append(fragmentFrom.html`\n      <style>\n        :host {\n          box-sizing: border-box;\n          cursor: default;\n          display: flex;\n          overflow: hidden; /* Container element is responsible for scrolling */\n          -webkit-tap-highlight-color: transparent;\n        }\n\n        #container {\n          display: flex;\n          flex: 1;\n          -webkit-overflow-scrolling: touch; /* for momentum scrolling */\n        }\n      </style>\n      <div id=\"container\" role=\"none\">\n        <slot id=\"slot\"></slot>\n      </div>\n    `);\n    return result;\n  }\n}\n\nexport default ListBox;\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { defaultAriaRole, ensureId } from \"./accessibility.js\";\nimport {\n  defaultState,\n  render,\n  rendering,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Exposes a list's currently-selected item to assistive technologies.\n *\n * Handling ARIA selection state properly is actually quite complex:\n *\n * * The items in the list need to be indicated as possible items via an ARIA\n *   `role` attribute value such as \"option\".\n * * The selected item(s) need to be marked as selected by setting the item's\n *   `aria-selected` attribute to true *and* the other items need be marked as\n *   *not* selected by setting `aria-selected` to false.\n * * The outermost element with the keyboard focus needs to have attributes\n *   set on it so that the current item is knowable at the list level via the\n *   `aria-activedescendant` attribute.\n * * Use of `aria-activedescendant` in turn requires that all items in the\n *   list have ID attributes assigned to them.\n * * If the list supports mutli-selection, `aria-multiselectable` must be\n *   set to \"true\" on the host.\n *\n * This mixin tries to address all of the above requirements. To that end,\n * this mixin will assign generated IDs to any item that doesn't already have\n * an ID.\n *\n * ARIA relies on elements to provide `role` attributes. This mixin will apply\n * a default role of \"listbox\" on the outer list if it doesn't already have an\n * explicit role. Similarly, this mixin will apply a default role of \"option\"\n * to any list item that does not already have a role specified.\n *\n * This mixin expects the component to define a `currentIndex` state member to\n * indicate the current item. You can supply that yourself, or do so via\n * [ItemsCursorMixin](ItemsCursorMixin). For a multi-select list, you must also\n * define a `selectedItemFlags` state member, available via\n * [ItemsMultiSelectMixin](ItemsMultiSelectMixin).\n *\n * @module AriaListMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function AriaListMixin(Base) {\n  // The class prototype added by the mixin.\n  class AriaList extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      const base = super[defaultState];\n      return Object.assign(base, {\n        itemRole: base.itemRole || \"option\",\n        role: base.role || \"listbox\",\n      });\n    }\n\n    get itemRole() {\n      return this[state].itemRole;\n    }\n    set itemRole(itemRole) {\n      this[setState]({ itemRole });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      const { itemRole } = this[state];\n      /** @type {ListItemElement[]} */ const items = this[state].items;\n\n      // Give each item an ID.\n      if (changed.items && items) {\n        items.forEach((item) => {\n          if (!item.id) {\n            item.id = ensureId(item);\n          }\n        });\n      }\n\n      // Give each item a role.\n      if ((changed.items || changed.itemRole) && items) {\n        items.forEach((item) => {\n          if (itemRole === defaultAriaRole[item.localName]) {\n            item.removeAttribute(\"role\");\n          } else {\n            item.setAttribute(\"role\", itemRole);\n          }\n        });\n      }\n\n      // Reflect the selected state to each item.\n      if (changed.items || changed.selectedIndex || changed.selectedItemFlags) {\n        // Does the list support multi-selection?\n        const { selectedItemFlags, selectedIndex } = this[state];\n        if (items) {\n          items.forEach((item, index) => {\n            const selected = selectedItemFlags\n              ? selectedItemFlags[index] // Multi-select\n              : index === selectedIndex; // Single-select\n            item.setAttribute(\"aria-selected\", selected.toString());\n          });\n        }\n      }\n\n      // Indicate on the host that the current item is active.\n      if (changed.items || changed.selectedIndex) {\n        const { selectedIndex } = this[state];\n        const selectedItem =\n          selectedIndex >= 0 && items ? items[selectedIndex] : null;\n        if (selectedItem) {\n          if (!selectedItem.id) {\n            selectedItem.id = ensureId(selectedItem);\n          }\n          this.setAttribute(\"aria-activedescendant\", selectedItem.id);\n        } else {\n          this.removeAttribute(\"aria-activedescendant\");\n        }\n      }\n\n      if (changed.selectedItemFlags) {\n        // Let ARIA know this is a multi-select list box.\n        if (this[state].selectedItemFlags) {\n          this.setAttribute(\"aria-multiselectable\", \"true\");\n        } else {\n          this.removeAttribute(\"aria-multiselectable\");\n        }\n      }\n\n      // Let ARIA know list orientation.\n      if (changed.orientation) {\n        const { orientation } = this[state];\n        this.setAttribute(\"aria-orientation\", orientation);\n      }\n\n      // Apply top-level role.\n      if (changed.role) {\n        const { role } = this[state];\n        this.setAttribute(\"role\", role);\n      }\n    }\n\n    // Setting the standard role attribute will invoke this property setter,\n    // which will allow us to update our state.\n    get role() {\n      return super.role;\n    }\n    set role(role) {\n      super.role = role;\n      if (!this[rendering]) {\n        this[setState]({ role });\n      }\n    }\n  }\n\n  return AriaList;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { defaultState, stateEffects } from \"./internal.js\";\n\n/**\n * Keeps the current item and selected item in sync.\n *\n * This can be used to connect [ItemsCursorMixin](ItemsCursorMixin) with\n * [SingleSelectAPIMixin](SingleSelectAPIMixin).\n *\n * @module CursorSelectMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function CursorSelectMixin(Base) {\n  // The class prototype added by the mixin.\n  return class CursorSelect extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        selectedIndex: -1,\n        selectedItem: null,\n      });\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      if (changed.currentIndex) {\n        // Priority one: selected index tracks current index.\n        Object.assign(effects, {\n          selectedIndex: state.currentIndex,\n        });\n      } else if (changed.selectedIndex) {\n        // Priority two: current index tracks selected index.\n        // These priorities ensure that, both current index and selected index\n        // are changed, current index wins.\n        Object.assign(effects, {\n          currentIndex: state.selectedIndex,\n        });\n      }\n\n      // Same priorities as above.\n      if (changed.currentItem) {\n        Object.assign(effects, {\n          selectedItem: state.currentItem,\n        });\n      } else if (changed.selectedItem) {\n        Object.assign(effects, {\n          currentItem: state.selectedItem,\n        });\n      }\n\n      return effects;\n    }\n  };\n}\n","import { updateChildNodes } from \"../core/dom.js\";\nimport { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport { transmute } from \"../core/template.js\";\nimport Input from \"./Input.js\";\nimport {\n  defaultState,\n  firstRender,\n  ids,\n  inputDelegate,\n  matchText,\n  raiseChangeEvents,\n  render,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  stateEffects,\n  template,\n} from \"./internal.js\";\nimport ListBox from \"./ListBox.js\";\n\n/**\n * A text input box that completes text as the user types\n *\n * @inherits Input\n */\nclass AutoCompleteInput extends Input {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      autoCompleteSelect: false,\n      opened: false,\n      originalText: \"\",\n      textIndex: -1,\n      texts: [],\n    });\n  }\n\n  /**\n   * Search the given array of text strings for one that matches `prefix`.\n   *\n   * This method is invoked by the auto-complete algorithm when the user types\n   * characters into the input.\n   *\n   * The default implementation does a case-insensitive prefix search. You can\n   * override this method to define custom auto-complete behavior. Return the\n   * complete matching string if a match was found, or null if there was no\n   * match.\n   *\n   * @param {string[]} texts\n   * @param {string} prefix\n   * @returns {string|null}\n   */\n  [matchText](texts, prefix) {\n    if (prefix.length === 0 || !texts) {\n      return null;\n    }\n    const prefixLowerCase = prefix.toLowerCase();\n    const match = texts.find((text) =>\n      text.toLowerCase().startsWith(prefixLowerCase)\n    );\n    return match || null;\n  }\n\n  get opened() {\n    return this[state].opened;\n  }\n  set opened(opened) {\n    this[setState]({ opened });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n    if (this[firstRender]) {\n      // In many ways it would be cleaner to do AutoComplete work in a keydown\n      // listener. Unfortunately, Chrome for Android sets the keyCode on *all*\n      // keydown events to a mysterious 229 value, making it impossible for us\n      // to look at the keyCode and determine whether the user is typing a key\n      // that should trigger AutoComplete.\n      //\n      // Instead, we listen to input events. That comes with its own set of\n      // headaches, noted below.\n      this[ids].inner.addEventListener(\"input\", () => {\n        // Gboard will generate multiple input events for a single keypress. In\n        // particular, if we do AutoComplete and leave the text selected, then\n        // when the user types the next key, we'll get *three* input events: one\n        // for the actual change, and two other events (probably related to\n        // Gboard's own AutoComplete behavior). We give the input value a chance\n        // to stabilize by waiting a tick.\n        setTimeout(() => {\n          this[raiseChangeEvents] = true;\n          /** @type {any} */\n          const inner = this.inner;\n          const text = this.value.toLowerCase();\n          // We only AutoComplete if the user's typing at the end of the input.\n          // Read the selection start and end directly off the inner element to\n          // ensure they're up to date.\n          const typingAtEnd =\n            inner.selectionStart === text.length &&\n            inner.selectionEnd === text.length;\n          // Moreover, we only AutoComplete if we're sure the user's added a\n          // single character to the value seen on the previous input event.\n          // Among other things, we want to ensure the user can delete text from\n          // the end without having AutoComplete kick in.\n          const originalText = this[state].originalText;\n          const userAddedText =\n            text.startsWith(originalText) &&\n            text.length === originalText.length + 1;\n          if (typingAtEnd && userAddedText) {\n            autoComplete(this);\n          }\n          // Remember what the user typed for next time.\n          this[setState]({\n            originalText: text,\n          });\n          this[raiseChangeEvents] = false;\n        });\n      });\n\n      transmute(this[ids].accessibleList, ListBox);\n    }\n\n    // Let ARIA know whether combo box is open.\n    if (changed.opened) {\n      const { opened } = this[state];\n      this[ids].inner.setAttribute(\"aria-expanded\", opened.toString());\n    }\n\n    // Copy the text values to the invisible, accessible list.\n    // TODO: We could defer this work to after the component gets focus.\n    if (changed.texts) {\n      const { texts } = this[state];\n      const options =\n        texts === null\n          ? []\n          : texts.map((text) => {\n              const div = document.createElement(\"div\");\n              div.textContent = text;\n              return div;\n            });\n      updateChildNodes(this[ids].accessibleList, options);\n    }\n\n    // Select the the accessible list item for the current text.\n    if (changed.textIndex) {\n      const { textIndex } = this[state];\n\n      /** @type {any} */ const list = this[ids].accessibleList;\n      if (\"currentIndex\" in list) {\n        list.currentIndex = textIndex;\n      }\n\n      const item = list.currentItem;\n      const id = item ? item.id : null;\n      if (id) {\n        this[inputDelegate].setAttribute(\"aria-activedescendant\", id);\n      } else {\n        this[inputDelegate].removeAttribute(\"aria-activedescendant\");\n      }\n    }\n  }\n\n  [rendered](/** @type {ChangedFlags} */ changed) {\n    super[rendered](changed);\n    const { autoCompleteSelect, originalText } = this[state];\n    if (changed.originalText && autoCompleteSelect) {\n      // We've finished rendering new auto-completed text.\n      // Leave the auto-completed portion (after the part the user originally\n      // typed) selected.\n      this[setState]({\n        autoCompleteSelect: false,\n        selectionEnd: this[state].value.length,\n        selectionStart: originalText.length,\n      });\n\n      // Dispatch an input event so that listeners can process the\n      // auto-completed text.\n      // @ts-ignore\n      const InputEvent = window.InputEvent || Event;\n      const event = new InputEvent(\"input\", {\n        // @ts-ignore\n        detail: {\n          originalText,\n        },\n      });\n      this.dispatchEvent(event);\n    }\n  }\n\n  [stateEffects](state, changed) {\n    const effects = super[stateEffects]\n      ? super[stateEffects](state, changed)\n      : {};\n\n    if (changed.valueCopy) {\n      const { texts, valueCopy } = state;\n      const textIndex = texts.indexOf(valueCopy);\n      Object.assign(effects, { textIndex });\n    }\n\n    return effects;\n  }\n\n  get [template]() {\n    const result = super[template];\n\n    // Apply ARIA combobox attributes to the input.\n    const inner = result.content.querySelector('[part~=\"input\"]');\n    if (inner) {\n      inner.setAttribute(\"aria-autocomplete\", \"both\");\n      inner.setAttribute(\"aria-controls\", \"accessibleList\");\n      inner.setAttribute(\"role\", \"combobox\");\n    }\n\n    // Add an accessible list.\n    result.content.append(fragmentFrom.html`\n      <style>\n        #accessibleList {\n          height: 0;\n          position: absolute;\n          width: 0;\n        }\n      </style>\n      <div id=\"accessibleList\" tabindex=\"-1\"></div>\n    `);\n\n    return result;\n  }\n\n  /**\n   * The set of texts the input will match against.\n   *\n   * @type {string[]}\n   */\n  get texts() {\n    return this[state].texts;\n  }\n  set texts(texts) {\n    this[setState]({ texts });\n  }\n\n  // Setting the value from the outside is treated as if the user had typed the\n  // value. This way the component's value can be prepopulated, and the user can\n  // start typing at the end of it to get AutoComplete.\n  // @ts-ignore\n  get value() {\n    return super.value;\n  }\n  set value(value) {\n    super.value = value;\n    // If the input has focus, we assume the user is typing, and rely on\n    // the `input` event to update the originalText state.\n    if (this[shadowRoot] && !this.inner.matches(\":focus\")) {\n      this[setState]({\n        originalText: value,\n      });\n    }\n  }\n}\n\nexport function autoComplete(/** @type {AutoCompleteInput} */ element) {\n  const match = element[matchText](element.texts, element.value);\n\n  // If found, update the input value to the match.\n  // Leave the auto-completed portion selected.\n  if (match) {\n    element[setState]({\n      autoCompleteSelect: true,\n      value: match,\n    });\n  }\n\n  return match;\n}\n\nexport default AutoCompleteInput;\n","import ReactiveElement from \"../core/ReactiveElement.js\";\nimport { firstRender, render } from \"./internal.js\";\n\n/**\n * An element with no visible appearance\n *\n * In some situations, you may be using a component that defines an\n * [element role](customizing#element-part-types) that you don't want to fill.\n * In such cases, you can indicate that the `Hidden` element class should be\n * used to fill that role. The component will create an instance of this class\n * inside its shadow tree, but the element will be invisible to the user.\n *\n * @inherits ReactiveElement\n */\nclass Hidden extends ReactiveElement {\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n    if (this[firstRender]) {\n      this.setAttribute(\"hidden\", \"\");\n    }\n  }\n}\n\nexport default Hidden;\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  ids,\n  raiseChangeEvents,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\nconst documentMouseupListenerKey = Symbol(\"documentMouseupListener\");\n\n/**\n * Add drag-select behavior to an element with a popup.\n *\n * This allows a user to mouse down on a popup source, drag into the resulting\n * popup, and release the mouse to select something in the popup. This can be\n * used in conjunction with [PopupListMixin](PopupListMixin).\n *\n * @module PopupDragSelectMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function PopupDragSelectMixin(Base) {\n  // The class prototype added by the mixin.\n  class PopupDragSelect extends Base {\n    connectedCallback() {\n      super.connectedCallback();\n      // Handle edge case where component is opened, removed, then added back.\n      listenIfOpenAndConnected(this);\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        dragSelect: true,\n      });\n    }\n\n    disconnectedCallback() {\n      if (super.disconnectedCallback) {\n        super.disconnectedCallback();\n      }\n      listenIfOpenAndConnected(this);\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      super[rendered](changed);\n\n      if (changed.opened) {\n        listenIfOpenAndConnected(this);\n      }\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects](state, changed);\n\n      // Set things when opening, or reset things when closing.\n      if (changed.opened) {\n        if (state.opened) {\n          // Opening\n          Object.assign(effects, {\n            // Until we get a mouseup, we're doing a drag-select.\n            dragSelect: true,\n          });\n        }\n      }\n\n      return effects;\n    }\n  }\n\n  return PopupDragSelect;\n}\n\nasync function handleMouseup(/** @type {MouseEvent} */ event) {\n  // @ts-ignore\n  const element = this;\n  const hitTargets = element[shadowRoot].elementsFromPoint(\n    event.clientX,\n    event.clientY\n  );\n  if (element.opened) {\n    // Was mouseup over source part?\n    const overSource = hitTargets.indexOf(element[ids].source) >= 0;\n\n    // Was mouseup over the popup or popup frame?\n    const popup = element[ids].popup;\n    const overPopup = hitTargets.indexOf(popup) >= 0;\n    const overPopupFrame = popup.frame && hitTargets.indexOf(popup.frame) >= 0;\n\n    if (overSource) {\n      // User released the mouse over the source button (behind the\n      // backdrop), so we're no longer doing a drag-select.\n      if (element[state].dragSelect) {\n        element[raiseChangeEvents] = true;\n        element[setState]({\n          dragSelect: false,\n        });\n        element[raiseChangeEvents] = false;\n      }\n    } else if (!(overPopup || overPopupFrame)) {\n      // If we get to this point, the user released over the backdrop with\n      // the popup open, so close.\n      element[raiseChangeEvents] = true;\n      await element.close();\n      element[raiseChangeEvents] = false;\n    }\n  }\n}\n\nfunction listenIfOpenAndConnected(element) {\n  if (element[state].opened && element.isConnected) {\n    // If the popup is open and user releases the mouse over the backdrop, we\n    // want to close the popup. We need to listen to mouseup on the document,\n    // not this element. If the user mouses down on the source, then moves the\n    // mouse off the document before releasing the mouse, the element itself\n    // won't get the mouseup. The document will, however, so it's a more\n    // reliable source of mouse state.\n    //\n    // Coincidentally, we *also* need to listen to mouseup on the document to\n    // tell whether the user released the mouse over the source button. When the\n    // user mouses down, the backdrop will appear and cover the source, so from\n    // that point on the source won't receive a mouseup event. Again, we can\n    // listen to mouseup on the document and do our own hit-testing to see if\n    // the user released the mouse over the source.\n    if (!element[documentMouseupListenerKey]) {\n      // Not listening yet; start.\n      element[documentMouseupListenerKey] = handleMouseup.bind(element);\n      document.addEventListener(\"mouseup\", element[documentMouseupListenerKey]);\n    }\n  } else if (element[documentMouseupListenerKey]) {\n    // Currently listening; stop.\n    document.removeEventListener(\n      \"mouseup\",\n      element[documentMouseupListenerKey]\n    );\n    element[documentMouseupListenerKey] = null;\n  }\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  raiseChangeEvents,\n  rendered,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Tracks the disabled state of a component that can be disabled\n *\n * @module DisabledMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function DisabledMixin(Base) {\n  // The class prototype added by the mixin.\n  class Disabled extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        disabled: false,\n      });\n    }\n\n    /**\n     * True if the component is disabled, false (the default) if not.\n     *\n     * The value of this property will be reflected to the `disabled` attribute\n     * so that it can be referenced in CSS. Note that this non-native\n     * implementation of the `disabled` attribute will *not* trigger the\n     * `:disabled` CSS pseudo-class, so your style rules will have to reference\n     * the presence or absence of the `disabled` attribute. That is, instead\n     * of writing\n     *\n     *     my-component:disabled { ... }\n     *\n     * write this instead\n     *\n     *     my-component[disabled] { ... }\n     *\n     * Like the native `disabled` attribute, this attribute is boolean. That\n     * means that it's *existence* in markup sets the attribute, even if set to\n     * an empty string or a string like \"false\".\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get disabled() {\n      return this[state].disabled;\n    }\n    // AttributeMarshallingMixin should parse this as a boolean attribute for us.\n    set disabled(disabled) {\n      this[setState]({ disabled });\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (changed.disabled) {\n        // Reflect value of disabled property to the corresponding attribute.\n        this.toggleAttribute(\"disabled\", this.disabled);\n\n        if (this[raiseChangeEvents]) {\n          const oldEvent = new CustomEvent(\"disabled-changed\", {\n            bubbles: true,\n          });\n          this.dispatchEvent(oldEvent);\n          /**\n           * Raised when the `disabled` property changes.\n           *\n           * @event disabledchange\n           */\n          const event = new CustomEvent(\"disabledchange\", {\n            bubbles: true,\n          });\n          this.dispatchEvent(event);\n        }\n      }\n    }\n  }\n\n  return Disabled;\n}\n","/**\n * Function for positioning a popup relative to a source element.\n *\n * @module positionPopup\n */\n\n/**\n * Given an (x, y) origin point, a bounding rectangle, and a layout, return the\n * height and width of the available space in the quadrant used by that layout.\n *\n * @private\n * @param {DOMRect} sourceRect\n * @param {DOMRect} boundsRect\n */\nfunction availableSpace(sourceRect, boundsRect, direction, align) {\n  const sourceOrigin = getSourceOrigin(sourceRect, direction, align);\n\n  let height = 0;\n  let width = 0;\n  const vertical = direction === \"above\" || direction === \"below\";\n  switch (direction) {\n    case \"above\":\n      height = sourceOrigin.y - boundsRect.top;\n      break;\n    case \"below\":\n      height = boundsRect.bottom - sourceOrigin.y;\n      break;\n    case \"left\":\n      width = sourceOrigin.x - boundsRect.left;\n      break;\n    case \"right\":\n      width = boundsRect.right - sourceOrigin.x;\n      break;\n  }\n  switch (align) {\n    case \"bottom\":\n      height = sourceOrigin.y - boundsRect.top;\n      break;\n    case \"center\":\n      if (vertical) {\n        width = boundsRect.width;\n      } else {\n        height = boundsRect.height;\n      }\n      break;\n    case \"stretch\":\n      if (vertical) {\n        width = sourceRect.width;\n      } else {\n        height = sourceRect.height;\n      }\n      break;\n    case \"left\":\n      width = boundsRect.right - sourceOrigin.x;\n      break;\n    case \"right\":\n      width = sourceOrigin.x - boundsRect.left;\n      break;\n    case \"top\":\n      height = boundsRect.bottom - sourceOrigin.y;\n      break;\n  }\n  height = Math.max(0, height);\n  width = Math.max(0, width);\n  return { height, width };\n}\n\n/**\n * Given two layouts, return -1 if the first is better, 1 if the second is\n * better, and 0 if they're equally good.\n *\n * Our comparison uses a heuristic that looks to see whether a layout can fit\n * the popup in height, width, or both. A layout is best if it fits both height\n * and width. If each layout only fits one dimension, then the layout that gives\n * the popup more space is preferred.\n *\n * @private\n * @param {DOMRect} sourceRect\n * @param {DOMRect} popupRect\n * @param {DOMRect} boundsRect\n */\nfunction compareLayouts(layout1, layout2, sourceRect, popupRect, boundsRect) {\n  const space1 = availableSpace(\n    sourceRect,\n    boundsRect,\n    layout1.direction,\n    layout1.align\n  );\n  const space2 = availableSpace(\n    sourceRect,\n    boundsRect,\n    layout2.direction,\n    layout2.align\n  );\n  const fitsWidth1 = popupRect.width <= space1.width;\n  const fitsHeight1 = popupRect.height <= space1.height;\n  const fitsEither1 = fitsWidth1 || fitsHeight1;\n  const fitsBoth1 = fitsWidth1 && fitsHeight1;\n  const fitsWidth2 = popupRect.width <= space2.width;\n  const fitsHeight2 = popupRect.height <= space2.height;\n  const fitsEither2 = fitsWidth2 || fitsHeight2;\n  const fitsBoth2 = fitsWidth2 && fitsHeight2;\n  const area1 = space1.width * space1.height;\n  const area2 = space2.width * space2.height;\n  if (fitsBoth1 && fitsBoth2) {\n    // Both layouts can fit in both dimensions; they're equally good.\n    return 0;\n  } else if (fitsBoth1) {\n    // Layout 1 has space for popup in both dimensions.\n    return -1;\n  } else if (fitsBoth2) {\n    // Layout 2 has space for popup in both dimensions.\n    return 1;\n  } else if (fitsEither1 && !fitsEither2) {\n    // Layout 1 fits in one dimension, layout 2 doesn't fit either.\n    return -1;\n  } else if (fitsEither2 && !fitsEither1) {\n    // Layout 2 fits in one dimensions, layout 1 doesn't fit either.\n    return 1;\n  } else if (fitsEither1 && area1 > area2) {\n    // Layout 1 fits in one dimension and gives popup more space.\n    return -1;\n  } else if (fitsEither2 && area2 > area1) {\n    // Layout 2 fits in one dimension and gives popup more space.\n    return 1;\n  } else if (area1 > area2) {\n    // Layout 1 gives popup more space.\n    return -1;\n  } else if (area2 > area1) {\n    // Layout 2 gives popup more space.\n    return 1;\n  } else {\n    // Layouts equally good or bad.\n    return 0;\n  }\n}\n\n/**\n * Determine the (x, y) location at which the popup should be positioned to\n * touch the indicated source origin point.\n *\n * @private\n * @param {DOMRect} sourceRect\n * @param {DOMRect} popupRect\n * @param {DOMRect} boundsRect\n */\nfunction getPositionedRect(\n  sourceRect,\n  popupRect,\n  boundsRect,\n  direction,\n  align\n) {\n  // With respect to which point on the source will we position the popup?\n  const sourceOrigin = getSourceOrigin(sourceRect, direction, align);\n\n  // We'll adjust our bounds depending upon the layout.\n  let {\n    x: boundsLeft,\n    y: boundsTop,\n    bottom: boundsBottom,\n    right: boundsRight,\n  } = boundsRect;\n\n  let x = 0;\n  let y = 0;\n  let height = popupRect.height;\n  let width = popupRect.width;\n  const vertical = direction === \"above\" || direction === \"below\";\n  switch (direction) {\n    case \"above\":\n      y = sourceOrigin.y - popupRect.height;\n      boundsBottom = sourceOrigin.y;\n      break;\n    case \"below\":\n      y = sourceOrigin.y;\n      boundsTop = sourceOrigin.y;\n      break;\n    case \"left\":\n      x = sourceOrigin.x - popupRect.width;\n      boundsRight = sourceOrigin.x;\n      break;\n    case \"right\":\n      x = sourceOrigin.x;\n      boundsLeft = sourceOrigin.x;\n      break;\n  }\n  switch (align) {\n    case \"bottom\":\n      y = sourceOrigin.y - popupRect.height;\n      boundsBottom = sourceOrigin.y;\n      break;\n    case \"left\":\n      x = sourceOrigin.x;\n      boundsLeft = sourceOrigin.x;\n      break;\n    case \"center\":\n      if (vertical) {\n        x = sourceOrigin.x - popupRect.width / 2;\n      } else {\n        y = sourceOrigin.y - popupRect.height / 2;\n      }\n      break;\n    case \"right\":\n      x = sourceOrigin.x - popupRect.width;\n      boundsRight = sourceOrigin.x;\n      break;\n    case \"stretch\":\n      if (vertical) {\n        x = sourceOrigin.x;\n        width = sourceRect.width;\n      } else {\n        y = sourceOrigin.y;\n        height = sourceRect.height;\n      }\n      break;\n    case \"top\":\n      y = sourceOrigin.y;\n      boundsTop = sourceOrigin.y;\n      break;\n  }\n\n  // Force the desired rectangle to fit within the bounds.\n  x = Math.max(x, boundsLeft);\n  y = Math.max(y, boundsTop);\n  width = Math.min(width, boundsRight - x);\n  height = Math.min(height, boundsBottom - y);\n\n  return new DOMRect(x, y, width, height);\n}\n\n/**\n * For a given layout, we will use a different point on the source element as a\n * reference point to position the popup. Return that (x, y) point.\n *\n * @private\n * @param {DOMRect} sourceRect\n */\nfunction getSourceOrigin(sourceRect, direction, align) {\n  let x = 0;\n  let y = 0;\n  const vertical = direction === \"above\" || direction === \"below\";\n  switch (direction) {\n    case \"above\":\n      y = sourceRect.top;\n      break;\n    case \"below\":\n      y = sourceRect.bottom;\n      break;\n    case \"left\":\n    case \"right\":\n      x = sourceRect[direction];\n      break;\n  }\n  switch (align) {\n    case \"bottom\":\n    case \"top\":\n      y = sourceRect[align];\n      break;\n    case \"left\":\n    case \"right\":\n      x = sourceRect[align];\n      break;\n    case \"center\":\n      if (vertical) {\n        x = sourceRect.left + sourceRect.width / 2;\n      } else {\n        y = sourceRect.top + sourceRect.height / 2;\n      }\n      break;\n    case \"stretch\":\n      if (vertical) {\n        x = sourceRect.left;\n      } else {\n        y = sourceRect.top;\n      }\n      break;\n  }\n  return { x, y };\n}\n\n/**\n * Return the optimum layout for the popup element with respect to a source\n * element that fits in the given bounds.\n *\n * @param {DOMRect} sourceRect\n * @param {DOMRect} popupRect\n * @param {DOMRect} boundsRect\n * @param {any} options\n */\nexport default function layoutPopup(\n  sourceRect,\n  popupRect,\n  boundsRect,\n  options\n) {\n  const normalized = normalizeOptions(options);\n\n  // Given the direction and alignment, which layouts do we want to consider?\n  const layouts = prioritizedLayouts(normalized.direction, normalized.align);\n\n  // Sort layouts by our heuristic.\n  layouts.sort((layout1, layout2) =>\n    compareLayouts(layout1, layout2, sourceRect, popupRect, boundsRect)\n  );\n\n  // Take the best layout.\n  const layout = layouts[0];\n\n  // Find the positioned rect with respect to the source origin.\n  layout.rect = getPositionedRect(\n    sourceRect,\n    popupRect,\n    boundsRect,\n    layout.direction,\n    layout.align\n  );\n\n  return layout;\n}\n\n// Normalize the popup options. Convert any logical layout options (start, end)\n// to physical options (e.g., left, right). Replace any unknown option values\n// with defaults.\nfunction normalizeOptions(options) {\n  const {\n    align: logicalAlign,\n    direction: logicalDirection,\n    rightToLeft,\n  } = options;\n  const defaultDirection = \"below\";\n  const physicalDirection =\n    {\n      above: \"above\",\n      below: \"below\",\n      column: \"below\",\n      \"column-reverse\": \"above\",\n      left: \"left\",\n      right: \"right\",\n      row: rightToLeft ? \"left\" : \"right\",\n      \"row-reverse\": rightToLeft ? \"right\" : \"left\",\n    }[logicalDirection] || defaultDirection;\n  const crossAxis = {\n    above: \"horizontal\",\n    below: \"horizontal\",\n    left: \"vertical\",\n    right: \"vertical\",\n  }[physicalDirection];\n  const defaultAlign = {\n    horizontal: \"left\",\n    vertical: \"top\",\n  }[crossAxis];\n  const physicalAlign =\n    {\n      horizontal: {\n        center: \"center\",\n        end: rightToLeft ? \"left\" : \"right\",\n        left: \"left\",\n        right: \"right\",\n        start: rightToLeft ? \"right\" : \"left\",\n        stretch: \"stretch\",\n      },\n      vertical: {\n        bottom: \"bottom\",\n        center: \"center\",\n        end: \"bottom\",\n        start: \"top\",\n        stretch: \"stretch\",\n        top: \"top\",\n      },\n    }[crossAxis][logicalAlign] || defaultAlign;\n  return {\n    align: physicalAlign,\n    direction: physicalDirection,\n    rightToLeft,\n  };\n}\n\n// Given a preferred direction and alignment, determine the set of 2 or 4 layout\n// alternatives that should be considered, in priority order.\nfunction prioritizedLayouts(preferredDirection, preferredAlign) {\n  const flipDirection = {\n    above: \"below\",\n    below: \"above\",\n    left: \"right\",\n    right: \"left\",\n  };\n  const flipAlign = {\n    top: \"bottom\",\n    bottom: \"top\",\n    left: \"right\",\n    right: \"left\",\n  };\n\n  // Our first choice of layout will be the preferred options.\n  const possibilties = [\n    { align: preferredAlign, direction: preferredDirection },\n  ];\n\n  if (preferredAlign === \"center\" || preferredAlign === \"stretch\") {\n    // Center/stretch align only needs to consider flipping over main axis.\n    possibilties.push({\n      align: preferredAlign,\n      direction: flipDirection[preferredDirection],\n    });\n  } else {\n    // Consider possibilities of flipping on either axis or both.\n    possibilties.push({\n      align: flipAlign[preferredAlign],\n      direction: preferredDirection,\n    });\n    possibilties.push({\n      align: preferredAlign,\n      direction: flipDirection[preferredDirection],\n    });\n    possibilties.push({\n      align: flipAlign[preferredAlign],\n      direction: flipDirection[preferredDirection],\n    });\n  }\n\n  return possibilties;\n}\n","import { booleanAttributeValue, setInternalState } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  raiseChangeEvents,\n  render,\n  rendered,\n  setState,\n  startEffect,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\n/** @type {any} */\nconst closePromiseKey = Symbol(\"closePromise\");\n/** @type {any} */\nconst closeResolveKey = Symbol(\"closeResolve\");\n\n/**\n * Tracks the open/close state of a component.\n *\n * @module OpenCloseMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function OpenCloseMixin(Base) {\n  // The class prototype added by the mixin.\n  class OpenClose extends Base {\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"opened\") {\n        const value = booleanAttributeValue(name, newValue);\n        if (this.opened !== value) {\n          this.opened = value;\n        }\n      } else {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n    }\n\n    /**\n     * Close the component (if not already closed).\n     *\n     * Some components like [AlertDialog](AlertDialog) want to indicate why or\n     * how they were closed. To support such scenarios, you can supply a value\n     * to the optional `closeResult` parameter. This closeResult will be made\n     * available in the `whenClosed` promise and the `state.closeResult` member.\n     *\n     * @param {object} [closeResult] - an indication of how or why the element closed\n     */\n    async close(closeResult) {\n      if (super.close) {\n        await super.close();\n      }\n      this[setState]({ closeResult });\n      await this.toggle(false);\n    }\n\n    /**\n     * True if the element is currently closed.\n     *\n     * This read-only property is provided as a convenient inverse of `opened`.\n     *\n     * @type {boolean}\n     */\n    get closed() {\n      return this[state] && !this[state].opened;\n    }\n\n    /**\n     * True if the element has completely closed.\n     *\n     * For components not using asynchronous open/close effects, this property\n     * returns the same value as the `closed` property. For elements that have a\n     * true value of `state.openCloseEffects` (e.g., elements using\n     * [TransitionEffectMixin](TransitionEffectMixin)), this property returns\n     * true only if `state.effect` is \"close\" and `state.effectPhase` is\n     * \"after\".\n     *\n     * @type {boolean}\n     */\n    get closeFinished() {\n      return this[state].closeFinished;\n    }\n\n    get closeResult() {\n      return this[state].closeResult;\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      const defaults = {\n        closeResult: null,\n        opened: false,\n      };\n      // If this component defines a `startEffect` method (e.g., by using\n      // TransitionEffectMixin), include default state for open/close effects.\n      // Since the component is closed by default, the default effect state is\n      // after the close effect has completed.\n      if (this[startEffect]) {\n        Object.assign(defaults, {\n          closeFinished: true,\n          effect: \"close\",\n          effectPhase: \"after\",\n          openCloseEffects: true,\n        });\n      }\n      return Object.assign(super[defaultState] || {}, defaults);\n    }\n\n    /**\n     * Open the element (if not already opened).\n     */\n    async open() {\n      if (super.open) {\n        await super.open();\n      }\n      this[setState]({ closeResult: undefined });\n      await this.toggle(true);\n    }\n\n    /**\n     * True if the element is currently opened.\n     *\n     * This property can be set as a boolean attribute\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get opened() {\n      return this[state] && this[state].opened;\n    }\n    set opened(opened) {\n      this[setState]({ closeResult: undefined });\n      this.toggle(opened);\n    }\n\n    [render](changed) {\n      super[render](changed);\n\n      // Reflect opened state.\n      if (changed.opened) {\n        const { opened } = this[state];\n        setInternalState(this, \"opened\", opened);\n      }\n\n      // Reflect closed state. To handle asynchronous close effects, we reflect\n      // the inverse of closeFinished instead of reflecting closed.\n      if (changed.closeFinished) {\n        const { closeFinished } = this[state];\n        setInternalState(this, \"closed\", closeFinished);\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (changed.opened && this[raiseChangeEvents]) {\n        const oldEvent = new CustomEvent(\"opened-changed\", {\n          bubbles: true,\n          detail: {\n            closeResult: this[state].closeResult,\n            opened: this[state].opened,\n          },\n        });\n        this.dispatchEvent(oldEvent);\n        /**\n         * Raised when the opened/closed state of the component changes.\n         *\n         * @event openedchange\n         */\n        const openedChangeEvent = new CustomEvent(\"openedchange\", {\n          bubbles: true,\n          detail: {\n            closeResult: this[state].closeResult,\n            opened: this[state].opened,\n          },\n        });\n        this.dispatchEvent(openedChangeEvent);\n\n        if (this[state].opened) {\n          const oldOpenedEvent = new CustomEvent(\"opened\", {\n            bubbles: true,\n          });\n          this.dispatchEvent(oldOpenedEvent);\n          /**\n           * Raised when the component opens.\n           *\n           * @event open\n           */\n          const openEvent = new CustomEvent(\"open\", {\n            bubbles: true,\n          });\n          this.dispatchEvent(openEvent);\n        } else {\n          const oldClosedEvent = new CustomEvent(\"closed\", {\n            bubbles: true,\n            detail: {\n              closeResult: this[state].closeResult,\n            },\n          });\n          this.dispatchEvent(oldClosedEvent);\n          /**\n           * Raised when the component closes.\n           *\n           * @event close\n           */\n          const closeEvent = new CustomEvent(\"close\", {\n            bubbles: true,\n            detail: {\n              closeResult: this[state].closeResult,\n            },\n          });\n          this.dispatchEvent(closeEvent);\n        }\n      }\n\n      // If someone's waiting for the component to close, and it's completely\n      // finished closing, then resolve the close promise.\n      const closeResolve = this[closeResolveKey];\n      if (this.closeFinished && closeResolve) {\n        this[closeResolveKey] = null;\n        this[closePromiseKey] = null;\n        closeResolve(this[state].closeResult);\n      }\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // Update our notion of closeFinished to track the closed state for\n      // components with synchronous open/close effects and components with\n      // asynchronous open/close effects.\n      if (\n        changed.openCloseEffects ||\n        changed.effect ||\n        changed.effectPhase ||\n        changed.opened\n      ) {\n        const { effect, effectPhase, openCloseEffects, opened } = state;\n        const closeFinished = openCloseEffects\n          ? effect === \"close\" && effectPhase === \"after\"\n          : !opened;\n        Object.assign(effects, { closeFinished });\n      }\n\n      return effects;\n    }\n\n    /**\n     * Toggle the open/close state of the element.\n     *\n     * @param {boolean} [opened] - true if the element should be opened, false\n     * if closed.\n     */\n    async toggle(opened = !this.opened) {\n      if (super.toggle) {\n        await super.toggle(opened);\n      }\n      const changed = opened !== this[state].opened;\n      if (changed) {\n        /** @type {PlainObject} */ const changes = { opened };\n        if (this[state].openCloseEffects) {\n          changes.effect = opened ? \"open\" : \"close\";\n          if (this[state].effectPhase === \"after\") {\n            changes.effectPhase = \"before\";\n          }\n        }\n        await this[setState](changes);\n      }\n    }\n\n    /**\n     * This method can be used as an alternative to listening to the\n     * \"openedchange\" event, particularly in situations where you want to only\n     * handle the next time the component is closed.\n     *\n     * @returns {Promise} A promise that resolves when the element has\n     * completely closed, including the completion of any asynchronous opening\n     * effect.\n     */\n    whenClosed() {\n      if (!this[closePromiseKey]) {\n        this[closePromiseKey] = new Promise((resolve) => {\n          this[closeResolveKey] = resolve;\n        });\n      }\n      return this[closePromiseKey];\n    }\n  }\n\n  return OpenClose;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  render,\n  rendering,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Lets a component define its ARIA role through a `role` state member\n *\n * Among other things, this allows a class or mixin to define a default\n * role through the component's `defaultState`.\n *\n * Some mixins come with identicial support for managing an ARIA role. Those\n * mixins include [AriaListMixin](AriaListMixin),\n * [AriaMenuMixin](AriaMenuMixin), [DialogModalityMixin](DialogModalityMixin),\n * and [PopupModalityMixin](PopupModalityMixin). If you're using one of those\n * mixins, you do *not* need to use this mixin.\n *\n * @module AriaRoleMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function AriaRoleMixin(Base) {\n  // The class prototype added by the mixin.\n  class AriaRole extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        role: null,\n      });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n      if (changed.role) {\n        // Apply top-level role.\n        const { role } = this[state];\n        if (role) {\n          this.setAttribute(\"role\", role);\n        } else {\n          this.removeAttribute(\"role\");\n        }\n      }\n    }\n\n    // Setting the standard role attribute will invoke this property setter,\n    // which will allow us to update our state.\n    get role() {\n      return super.role;\n    }\n    set role(role) {\n      const s = String(role);\n      super.role = s;\n      if (!this[rendering]) {\n        this[setState]({ s });\n      }\n    }\n  }\n\n  return AriaRole;\n}\n","import { templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport AriaRoleMixin from \"./AriaRoleMixin.js\";\nimport { defaultState, template } from \"./internal.js\";\n\nconst Base = AriaRoleMixin(ReactiveElement);\n\n/**\n * Background element shown behind an overlay's primary content\n *\n * The backdrop is transparent by default, suggesting to the user that the\n * overlay is modeless, and they can click through it to reach the background\n * elements. For a modal variant, see [ModalBackdrop](ModalBackdrop).\n *\n * @inherits ReactiveElement\n * @mixes AriaRoleMixin\n */\nclass Backdrop extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      role: \"none\",\n    });\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <style>\n        :host {\n          display: inline-block;\n          height: 100%;\n          left: 0;\n          position: fixed;\n          top: 0;\n          touch-action: manipulation;\n          width: 100%;\n        }\n      </style>\n      <slot></slot>\n    `;\n  }\n}\n\nexport default Backdrop;\n","import { templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport { template } from \"./internal.js\";\n\n/**\n * A simple frame for overlay content.\n *\n * The default appearance of `OverlayFrame` uses a simple drop-shadow to let the\n * user see the framed content as being on top of the background page content.\n *\n * @inherits ReactiveElement\n */\nclass OverlayFrame extends ReactiveElement {\n  get [template]() {\n    return templateFrom.html`\n      <style>\n        :host {\n          display: inline-block;\n          position: relative;\n        }\n      </style>\n      <slot></slot>\n    `;\n  }\n}\n\nexport default OverlayFrame;\n","import { deepContains, firstFocusableElement } from \"../core/dom.js\";\nimport { fragmentFrom, templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  firstRender,\n  render,\n  rendered,\n  setState,\n  state,\n  template,\n} from \"./internal.js\";\n\n/** @type {any} */\nconst appendedToDocumentKey = Symbol(\"appendedToDocument\");\n/** @type {any} */\nconst defaultZIndexKey = Symbol(\"assignedZIndex\");\n/** @type {any} */\nconst restoreFocusToElementKey = Symbol(\"restoreFocusToElement\");\n\n/**\n * Displays an opened element on top of other page elements.\n *\n * This mixin handles showing and hiding an overlay element. It, together with\n * [OpenCloseMixin](OpenCloseMixin), form the core behavior for [Overlay](Overlay),\n * which in turn forms the basis of Elix's overlay components.\n *\n * @module OverlayMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function OverlayMixin(Base) {\n  // The class prototype added by the mixin.\n  class Overlay extends Base {\n    // TODO: Document\n    get autoFocus() {\n      return this[state].autoFocus;\n    }\n    set autoFocus(autoFocus) {\n      this[setState]({ autoFocus });\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        autoFocus: true,\n        persistent: false,\n      });\n    }\n\n    async open() {\n      if (!this[state].persistent && !this.isConnected) {\n        // Overlay isn't in document yet.\n        this[appendedToDocumentKey] = true;\n        document.body.append(this);\n      }\n      if (super.open) {\n        await super.open();\n      }\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      if (this[firstRender]) {\n        this.addEventListener(\"blur\", (event) => {\n          // What has the focus now?\n          const newFocusedElement =\n            event.relatedTarget || document.activeElement;\n          /** @type {any} */\n          const node = this;\n          if (newFocusedElement instanceof HTMLElement) {\n            const focusInside = deepContains(node, newFocusedElement);\n            if (!focusInside) {\n              if (this.opened) {\n                // The user has most likely clicked on something in the background\n                // of a modeless overlay. Remember that element, and restore focus\n                // to it when the overlay finishes closing.\n                this[restoreFocusToElementKey] = newFocusedElement;\n              } else {\n                // A blur event fired, but the overlay closed itself before the blur\n                // event could be processed. In closing, we may have already\n                // restored the focus to the element that originally invoked the\n                // overlay. Since the user has clicked somewhere else to close the\n                // overlay, put the focus where they wanted it.\n                newFocusedElement.focus();\n                this[restoreFocusToElementKey] = null;\n              }\n            }\n          }\n        });\n      }\n\n      if (changed.effectPhase || changed.opened || changed.persistent) {\n        if (!this[state].persistent) {\n          // Temporary overlay\n          const closed =\n            typeof this.closeFinished === \"undefined\"\n              ? this.closed\n              : this.closeFinished;\n\n          if (closed) {\n            if (this[defaultZIndexKey]) {\n              // Remove default z-index.\n              this.style.zIndex = \"\";\n              this[defaultZIndexKey] = null;\n            }\n          } else if (this[defaultZIndexKey]) {\n            this.style.zIndex = this[defaultZIndexKey];\n          } else {\n            if (!hasZIndex(this)) {\n              bringToFront(this);\n            }\n          }\n        }\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (this[firstRender]) {\n        // Perform one-time check to see if component needs a default z-index.\n        if (this[state].persistent && !hasZIndex(this)) {\n          bringToFront(this);\n        }\n      }\n\n      if (changed.opened) {\n        if (this[state].autoFocus) {\n          if (this[state].opened) {\n            // Opened\n            if (\n              !this[restoreFocusToElementKey] &&\n              document.activeElement !== document.body\n            ) {\n              // Remember which element had the focus before we were opened.\n              this[restoreFocusToElementKey] = document.activeElement;\n            }\n            // Focus on the element itself (if it's focusable), or the first focusable\n            // element inside it.\n            // TODO: We'd prefer to require that overlays (like the Overlay base\n            // class) make use of delegatesFocus via DelegateFocusMixin, which would\n            // let us drop the need for this mixin here to do anything special with\n            // focus. However, an initial trial of this revealed an issue in\n            // MenuButton, where invoking the menu did not put the focus on the first\n            // menu item as expected. Needs more investigation.\n            const focusElement = firstFocusableElement(this);\n            if (focusElement) {\n              focusElement.focus();\n            }\n          } else {\n            // Closed\n            if (this[restoreFocusToElementKey]) {\n              // Restore focus to the element that had the focus before the overlay was\n              // opened.\n              this[restoreFocusToElementKey].focus();\n              this[restoreFocusToElementKey] = null;\n            }\n          }\n        }\n      }\n\n      // If we're finished closing an overlay that was automatically added to the\n      // document, remove it now. Note: we only do this when the component\n      // updates, not when it mounts, because we don't want an automatically-added\n      // element to be immediately removed during its connectedCallback.\n      if (\n        !this[firstRender] &&\n        !this[state].persistent &&\n        this.closeFinished &&\n        this[appendedToDocumentKey]\n      ) {\n        this[appendedToDocumentKey] = false;\n        if (this.parentNode) {\n          this.parentNode.removeChild(this);\n        }\n      }\n    }\n\n    get [template]() {\n      const result = super[template] || templateFrom.html``;\n\n      // We'd like to just use the `hidden` attribute, but a side-effect of\n      // styling with the hidden attribute is that naive styling of the\n      // component from the outside (to change to display: flex, say) will\n      // override the display: none implied by hidden. To work around this\n      // problem, we use display: none when the overlay is closed.\n      result.content.append(fragmentFrom.html`\n        <style>\n          :host([closed]) {\n            display: none;\n          }\n        </style>\n      `);\n\n      return result;\n    }\n  }\n\n  return Overlay;\n}\n\n// Pick a default z-index, remember it, and apply it.\nfunction bringToFront(element) {\n  const defaultZIndex = maxZIndexInUse() + 1;\n  element[defaultZIndexKey] = defaultZIndex;\n  element.style.zIndex = defaultZIndex.toString();\n}\n\n/**\n * If the element has or inherits an explicit numeric z-index, return true.\n * Otherwise, return false.\n *\n * @private\n * @param {HTMLElement} element\n * @returns {boolean}\n */\nfunction hasZIndex(element) {\n  const computedZIndex = getComputedStyle(element).zIndex;\n  const explicitZIndex = element.style.zIndex;\n  const isExplicitZIndexNumeric = !isNaN(parseInt(explicitZIndex));\n  if (computedZIndex === \"auto\") {\n    return isExplicitZIndexNumeric;\n  }\n  if (computedZIndex === \"0\" && !isExplicitZIndexNumeric) {\n    // Might be on Safari, which reports a computed z-index of zero even in\n    // cases where no z-index has been inherited but the element creates a\n    // stacking context. Inspect the composed tree parent to infer whether the\n    // element is really inheriting a z-index.\n    const parent =\n      element.assignedSlot ||\n      (element instanceof ShadowRoot ? element.host : element.parentNode);\n    if (!(parent instanceof HTMLElement)) {\n      // Theoretical edge case, assume zero z-index is real.\n      return true;\n    }\n    if (!hasZIndex(parent)) {\n      // The parent doesn't have a numeric z-index, and the element itself\n      // doesn't have a numeric z-index, so the \"0\" value for the computed\n      // z-index is simulated, not a real assigned numeric z-index.\n      return false;\n    }\n  }\n  // Element has a non-zero numeric z-index.\n  return true;\n}\n\n/*\n * Return the highest z-index currently in use in the document's light DOM.\n *\n * This calculation looks at all light DOM elements, so is theoretically\n * expensive. That said, it only runs when an overlay is opening, and is only used\n * if an overlay doesn't have a z-index already. In cases where performance is\n * an issue, this calculation can be completely circumvented by manually\n * applying a z-index to an overlay.\n */\nfunction maxZIndexInUse() {\n  const elements = document.body.querySelectorAll(\"*\");\n  const zIndices = Array.from(elements, (element) => {\n    const style = getComputedStyle(element);\n    let zIndex = 0;\n    if (style.position !== \"static\" && style.zIndex !== \"auto\") {\n      const parsed = style.zIndex ? parseInt(style.zIndex) : 0;\n      zIndex = !isNaN(parsed) ? parsed : 0;\n    }\n    return zIndex;\n  });\n  return Math.max(...zIndices);\n}\n","import { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport { transmute } from \"../core/template.js\";\nimport Backdrop from \"./Backdrop.js\";\nimport {\n  checkSize,\n  defaultState,\n  ids,\n  render,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  template,\n} from \"./internal.js\";\nimport OpenCloseMixin from \"./OpenCloseMixin.js\";\nimport OverlayFrame from \"./OverlayFrame.js\";\nimport OverlayMixin from \"./OverlayMixin.js\";\nimport SlotContentMixin from \"./SlotContentMixin.js\";\n\n// TODO: We'd like to use DelegateFocusMixin in this component, but see the note\n// at OverlayMixin's openedChanged function.\nconst Base = OpenCloseMixin(OverlayMixin(SlotContentMixin(ReactiveElement)));\n\n/**\n * An element that appears over other page elements\n *\n * The main overlay content is presented within a frame on top of an optional\n * backdrop.\n *\n * The overlay logic is provided by [OverlayMixin](OverlayMixin). `Overlay` adds\n * the definition of customizable element tags: [frameTag](#frameTag) for the\n * frame around the overlay content, and [backdropTag](#backdropTag) (if\n * defined) for the optional element covering the page elements behind the\n * overlay.\n *\n * As a convenience, the `open` method of `Overlay` will automatically add the\n * overlay to the end of the document body if the overlay isn't already in the\n * document. If the overlay is automatically attached in this way, then when it\n * closes, it will automatically be removed.\n *\n * See [Dialog](Dialog) and [Popup](Popup) for modal and modeless subclasses,\n * respectively.\n *\n * @inherits ReactiveElement\n * @mixes OpenCloseMixin\n * @mixes OverlayMixin\n * @mixes SlotContentMixin\n * @part {Backdrop} backdrop - the backdrop behind the overlay\n * @part {OverlayFrame} frame - the frame around the overlay\n */\nclass Overlay extends Base {\n  get backdrop() {\n    return this[ids] && this[ids].backdrop;\n  }\n\n  /**\n   * The class or tag used for the `backdrop` part - the optional\n   * element shown behind the overlay.\n   *\n   * This can help focus the user's attention on the overlay content.\n   * Additionally, a backdrop can be used to absorb clicks on background page\n   * elements. For example, [Dialog](Dialog) uses [ModalBackdrop](ModalBackdrop)\n   * as an overlay backdrop in such a way.\n   *\n   * @type {PartDescriptor}\n   * @default Backdrop\n   */\n  get backdropPartType() {\n    return this[state].backdropPartType;\n  }\n  set backdropPartType(backdropPartType) {\n    this[setState]({ backdropPartType });\n  }\n\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      backdropPartType: Backdrop,\n      framePartType: OverlayFrame,\n    });\n  }\n\n  get frame() {\n    return this[ids].frame;\n  }\n\n  /**\n   * The class or tag used to create the `frame` part – the overlay's\n   * primary content.\n   *\n   * The frame element can be used to provide a border around the overlay\n   * content, and to provide visual effects such as a drop-shadow to help\n   * distinguish overlay content from background page elements.\n   *\n   * @type {PartDescriptor}\n   * @default OverlayFrame\n   */\n  get framePartType() {\n    return this[state].framePartType;\n  }\n  set framePartType(framePartType) {\n    this[setState]({ framePartType });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n    renderParts(this[shadowRoot], this[state], changed);\n  }\n\n  [rendered](/** @type {ChangedFlags} */ changed) {\n    super[rendered](changed);\n\n    if (changed.opened && this[state].content) {\n      // If contents know how to size themselves, ask them to check their size.\n      this[state].content.forEach((element) => {\n        if (element[checkSize]) {\n          element[checkSize]();\n        }\n      });\n    }\n  }\n\n  get [template]() {\n    const result = super[template];\n\n    // TODO: Consider moving frameContent div to Drawer.\n    result.content.append(fragmentFrom.html`\n      <style>\n        :host {\n          display: inline-grid;\n          /* Constrain content if overlay's height is constrained. */\n          grid-template: minmax(0, 1fr) / minmax(0, 1fr);\n          max-height: 100vh;\n          max-width: 100vw;\n          outline: none;\n          position: fixed;\n          -webkit-tap-highlight-color: transparent;\n        }\n\n        [part~=\"frame\"] {\n          box-sizing: border-box;\n          display: grid;\n          overscroll-behavior: contain;\n          pointer-events: initial;\n          position: relative;\n        }\n\n        #frameContent {\n          display: grid;\n          grid-template: minmax(0, 1fr) / minmax(0, 1fr);\n          overflow: hidden;\n        }\n      </style>\n      <div id=\"backdrop\" part=\"backdrop\" tabindex=\"-1\"></div>\n      <div id=\"frame\" part=\"frame\" role=\"none\">\n        <div id=\"frameContent\">\n          <slot></slot>\n        </div>\n      </div>\n    `);\n\n    renderParts(result.content, this[state]);\n\n    return result;\n  }\n}\n\n/**\n * Render parts for the template or an instance.\n *\n * @private\n * @param {DocumentFragment} root\n * @param {PlainObject} state\n * @param {ChangedFlags} [changed]\n */\nfunction renderParts(root, state, changed) {\n  if (!changed || changed.backdropPartType) {\n    const { backdropPartType } = state;\n    const backdrop = root.getElementById(\"backdrop\");\n    if (backdrop) {\n      transmute(backdrop, backdropPartType);\n    }\n  }\n  if (!changed || changed.framePartType) {\n    const { framePartType } = state;\n    const frame = root.getElementById(\"frame\");\n    if (frame) {\n      transmute(frame, framePartType);\n    }\n  }\n}\n\nexport default Overlay;\n","import { deepContains, ownEvent } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  firstRender,\n  keydown,\n  raiseChangeEvents,\n  render,\n  rendered,\n  rendering,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/** @type {any} */\nconst implicitCloseListenerKey = Symbol(\"implicitCloseListener\");\n\n/**\n * Gives an overlay lightweight popup-style behavior.\n *\n * This mixin expects the component to provide:\n *\n * * An open/close API compatible with `OpenCloseMixin`.\n *\n * The mixin provides these features to the component:\n *\n * * Event handlers that close the element presses the Esc key, moves the focus\n *   outside the element, scrolls the document, resizes the document, or\n *   switches focus away from the document.\n * * A default ARIA role of `alert`.\n *\n * For modal overlays, use `DialogModalityMixin` instead. See the documentation\n * of that mixin for a comparison of modality behaviors.\n *\n * @module PopupModalityMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function PopupModalityMixin(Base) {\n  // The class prototype added by the mixin.\n  class PopupModality extends Base {\n    /**\n     * True if the popup should close if the user resizes the window.\n     *\n     * @type {boolean}\n     * @default true\n     */\n    get closeOnWindowResize() {\n      return this[state].closeOnWindowResize;\n    }\n    set closeOnWindowResize(closeOnWindowResize) {\n      this[setState]({ closeOnWindowResize });\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        closeOnWindowResize: true,\n        role: \"alert\",\n      });\n    }\n\n    // Close on Esc key.\n    [keydown](/** @type {KeyboardEvent} */ event) {\n      let handled = false;\n\n      switch (event.key) {\n        case \"Escape\":\n          this.close({\n            canceled: \"Escape\",\n          });\n          handled = true;\n          break;\n      }\n\n      // Prefer mixin result if it's defined, otherwise use base result.\n      return handled || (super.keydown && super.keydown(event)) || false;\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      if (this[firstRender]) {\n        // If we lose focus, and the new focus isn't inside us, then close.\n        this.addEventListener(\"blur\", blurHandler.bind(this));\n      }\n\n      if (changed.role) {\n        // Apply top-level role.\n        const { role } = this[state];\n        this.setAttribute(\"role\", role);\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (changed.opened) {\n        if (this.opened) {\n          // Wait before wiring up events – if the popup was opened because the\n          // user clicked something, that opening click event may still be\n          // bubbling up, and we only want to start listening after it's been\n          // processed. Alternatively, if the popup caused the page to scroll, we\n          // don't want to immediately close because the page scrolled (only if\n          // the user scrolls).\n          const callback =\n            \"requestIdleCallback\" in window\n              ? window[\"requestIdleCallback\"]\n              : setTimeout;\n          callback(() => {\n            // It's conceivable the popup was closed before the timeout completed,\n            // so double-check that it's still opened before listening to events.\n            if (this.opened) {\n              addEventListeners(this);\n            }\n          });\n        } else {\n          removeEventListeners(this);\n        }\n      }\n    }\n\n    // Setting the standard role attribute will invoke this property setter,\n    // which will allow us to update our state.\n    get role() {\n      return super.role;\n    }\n    set role(role) {\n      super.role = role;\n      if (!this[rendering]) {\n        this[setState]({ role });\n      }\n    }\n  }\n\n  return PopupModality;\n}\n\nfunction addEventListeners(/** @type {ReactiveElement} */ element) {\n  // Close handlers for window events.\n  element[implicitCloseListenerKey] = closeHandler.bind(element);\n\n  // Window blur event tracks loss of focus of *window*, not just element.\n  window.addEventListener(\"blur\", element[implicitCloseListenerKey]);\n  window.addEventListener(\"resize\", element[implicitCloseListenerKey]);\n  window.addEventListener(\"scroll\", element[implicitCloseListenerKey]);\n}\n\nfunction removeEventListeners(/** @type {ReactiveElement} */ element) {\n  if (element[implicitCloseListenerKey]) {\n    window.removeEventListener(\"blur\", element[implicitCloseListenerKey]);\n    window.removeEventListener(\"resize\", element[implicitCloseListenerKey]);\n    window.removeEventListener(\"scroll\", element[implicitCloseListenerKey]);\n    element[implicitCloseListenerKey] = null;\n  }\n}\n\n// Note: This routine also exists in PopupButton, may want to eventually\n// share that. Note that PopupButton handles blur on the *button*; here\n// we're dealing with the popup.\nasync function blurHandler(/** @type {Event} */ event) {\n  // @ts-ignore\n  /** @type {any} */ const element = this;\n  // What has the focus now?\n  const newFocusedElement =\n    /** @type {any} */ (event).relatedTarget || document.activeElement;\n  /** @type {any} */\n  if (\n    newFocusedElement instanceof Element &&\n    !deepContains(element, newFocusedElement)\n  ) {\n    element[raiseChangeEvents] = true;\n    await element.close({ canceled: \"window blur\" });\n    element[raiseChangeEvents] = false;\n  }\n}\n\nasync function closeHandler(/** @type {Event} */ event) {\n  // @ts-ignore\n  /** @type {any} */ const element = this;\n  const handleEvent =\n    event.type !== \"resize\" || element[state].closeOnWindowResize;\n  if (!ownEvent(element, event) && handleEvent) {\n    element[raiseChangeEvents] = true;\n    await element.close({\n      canceled: `window ${event.type}`,\n    });\n    element[raiseChangeEvents] = false;\n  }\n}\n","import { ids, raiseChangeEvents, render } from \"./internal.js\";\nimport KeyboardMixin from \"./KeyboardMixin.js\";\nimport Overlay from \"./Overlay.js\";\nimport PopupModalityMixin from \"./PopupModalityMixin.js\";\n\nconst Base = KeyboardMixin(PopupModalityMixin(Overlay));\n\n/**\n * Lightweight form of modeless overlay that can be easily dismissed\n *\n * When opened, the popup displays its children on top of other page elements.\n *\n * @inherits Overlay\n * @mixes KeyboardMixin\n * @mixes PopupModalityMixin\n */\nclass Popup extends Base {\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n    if (changed.backdropPartType) {\n      this[ids].backdrop.addEventListener(\n        \"mousedown\",\n        mousedownHandler.bind(this)\n      );\n\n      // Mobile Safari doesn't seem to generate a mousedown handler on the\n      // backdrop in some cases that Mobile Chrome handles. For completeness, we\n      // also listen to touchend.\n      if (!(\"PointerEvent\" in window)) {\n        this[ids].backdrop.addEventListener(\"touchend\", mousedownHandler);\n      }\n    }\n  }\n}\n\n/**\n * @private\n * @param {Event} event\n */\nasync function mousedownHandler(event) {\n  // @ts-ignore\n  const element = this;\n  element[raiseChangeEvents] = true;\n  await element.close({\n    canceled: \"mousedown outside\",\n  });\n  element[raiseChangeEvents] = false;\n  event.preventDefault();\n  event.stopPropagation();\n}\n\nexport default Popup;\n","import { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport { transmute } from \"../core/template.js\";\nimport DisabledMixin from \"./DisabledMixin.js\";\nimport FocusVisibleMixin from \"./FocusVisibleMixin.js\";\nimport {\n  defaultState,\n  firstRender,\n  ids,\n  inputDelegate,\n  raiseChangeEvents,\n  render,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  stateEffects,\n  template,\n} from \"./internal.js\";\nimport LanguageDirectionMixin from \"./LanguageDirectionMixin.js\";\nimport layoutPopup from \"./layoutPopup.js\";\nimport OpenCloseMixin from \"./OpenCloseMixin.js\";\nimport Popup from \"./Popup.js\";\n\nconst resizeListenerKey = Symbol(\"resizeListener\");\n\nconst Base = DisabledMixin(\n  FocusVisibleMixin(LanguageDirectionMixin(OpenCloseMixin(ReactiveElement)))\n);\n\n/**\n * Positions a popup with respect to a source element\n *\n * @inherits ReactiveElement\n * @mixes DisabledMixin\n * @mixes FocusVisibleMixin\n * @mixes OpenCloseMixin\n * @part {Popup} popup - the popup element\n * @part {button} source - the element used as the reference point for positioning the popup, generally the element that invokes the popup\n */\nclass PopupSource extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      ariaHasPopup: \"true\",\n      popupAlign: \"start\",\n      popupDirection: \"column\",\n      popupLayout: null,\n      popupPartType: Popup,\n      sourcePartType: \"div\",\n    });\n  }\n\n  // By default, assume that the source part is an input-like element that will\n  // get the foucs.\n  get [inputDelegate]() {\n    return this[ids].source;\n  }\n\n  get frame() {\n    return /** @type {any} */ (this[ids].popup).frame;\n  }\n\n  // TODO: Remove this deprecated property.\n  get horizontalAlign() {\n    return this[state].popupAlign;\n  }\n  set horizontalAlign(horizontalAlign) {\n    console.warn(\n      `The \"horizontalAlign\" property has been renamed to \"popupAlign\"; the \"horizontal-align\" attribute is now \"popup-align\".`\n    );\n    this[setState]({ popupAlign: horizontalAlign });\n  }\n\n  /**\n   * The alignment of the popup with respect to the source button.\n   *\n   * * `bottom`: popup and source are bottom-aligned\n   * * `end`: popup and source are aligned on the trailing edge according to the\n   *   text direction\n   * * `left`: popup and source are left-aligned\n   * * `right`: popup and source are right-aligned\n   * * `start`: popup and source are aligned on the leading edge according to\n   *   the text direction\n   * * `stretch`: both left and right edges are aligned\n   * * `top`: popup and source are top-aligned\n   *\n   * @type {('bottom'|'end'|'left'|'right'|'start'|'stretch'|'top')}\n   * @default 'start'\n   */\n  get popupAlign() {\n    return this[state].popupAlign;\n  }\n  set popupAlign(popupAlign) {\n    this[setState]({ popupAlign });\n  }\n\n  /**\n   * The preferred direction for the popup.\n   *\n   * * `above`: popup appears above the source\n   * * `below`: popup appears below the source\n   * * `column-reverse`: popup appears before the source in the block axis\n   * * `column`: popup appears after the source in the block axis\n   * * `left`: popup appears to the left of the source\n   * * `right`: popup appears to the right of the source\n   * * `row-reverse`: popup appears before the source in the inline axis\n   * * `row`: popup appears after the source in the inline axis\n   *\n   * @type {('above'|'below'|'column-reverse'|'column'|'left'|'right'|'row-reverse'|'row')}\n   * @default 'column'\n   */\n  get popupDirection() {\n    return this[state].popupDirection;\n  }\n  set popupDirection(popupDirection) {\n    this[setState]({ popupDirection });\n  }\n\n  // TODO: Remove this deprecated property.\n  get popupPosition() {\n    return this[state].popupPosition;\n  }\n  set popupPosition(popupPosition) {\n    console.warn(\n      `The \"popupPosition\" property has been renamed to \"popupDirection\"; the \"popup-position\" attribute is now \"popup-direction\".`\n    );\n    this[setState]({ popupPosition });\n  }\n\n  /**\n   * The class or tag used to create the `popup` part – the element\n   * responsible for displaying the popup and handling overlay behavior.\n   *\n   * @type {PartDescriptor}\n   * @default Popup\n   */\n  get popupPartType() {\n    return this[state].popupPartType;\n  }\n  set popupPartType(popupPartType) {\n    this[setState]({ popupPartType });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n\n    renderParts(this[shadowRoot], this[state], changed);\n\n    if (this[firstRender] || changed.ariaHasPopup) {\n      const { ariaHasPopup } = this[state];\n      if (ariaHasPopup === null) {\n        this[inputDelegate].removeAttribute(\"aria-haspopup\");\n      } else {\n        this[inputDelegate].setAttribute(\n          \"aria-haspopup\",\n          this[state].ariaHasPopup\n        );\n      }\n    }\n\n    if (changed.popupPartType) {\n      // Popup's opened state becomes our own opened state.\n      this[ids].popup.addEventListener(\"open\", () => {\n        if (!this.opened) {\n          this[raiseChangeEvents] = true;\n          this.open();\n          this[raiseChangeEvents] = false;\n        }\n      });\n\n      // Popup's closed state becomes our own closed state.\n      this[ids].popup.addEventListener(\"close\", (event) => {\n        if (!this.closed) {\n          this[raiseChangeEvents] = true;\n          /** @type {any} */\n\n          const cast = event;\n          const closeResult = cast.detail.closeResult;\n          this.close(closeResult);\n          this[raiseChangeEvents] = false;\n        }\n      });\n    }\n\n    if (changed.opened || changed.popupLayout) {\n      const { opened, popupLayout } = this[state];\n\n      if (!opened) {\n        // Popup closed. Reset the styles used to position it.\n        Object.assign(this[ids].popup.style, {\n          bottom: \"\",\n          left: \"\",\n          opacity: \"\",\n          right: \"\",\n          top: \"\",\n        });\n      } else if (!popupLayout) {\n        // Popup opened but not yet laid out.\n        //\n        // Render the component invisibly so we can measure it before showing\n        // it. We hide it by giving it zero opacity. If we use `visibility:\n        // hidden` for this purpose, the popup won't be able to receive the\n        // focus, which would complicate our overlay focus handling.\n        //\n        // In case the popup is being relayed out because a layout-affecting\n        // property changed while the popup is open, we reset the positiong\n        // styles too.\n        Object.assign(this[ids].popup.style, {\n          bottom: \"\",\n          left: \"\",\n          opacity: 0,\n          right: \"\",\n          top: \"\",\n        });\n      } else {\n        // Popup opened and laid out. Position the popup using only the edges\n        // implicated in the layout.\n        const popup = this[ids].popup;\n        const positionStyling = getPositiongStylingForLayout(popupLayout);\n        Object.assign(popup.style, positionStyling, {\n          opacity: \"\",\n        });\n      }\n    }\n\n    if (changed.opened) {\n      const { opened } = this[state];\n      /** @type {any} */ (this[ids].popup).opened = opened;\n    }\n\n    if (changed.disabled) {\n      if (\"disabled\" in this[ids].source) {\n        const { disabled } = this[state];\n        /** @type {any} */ (this[ids].source).disabled = disabled;\n      }\n    }\n\n    // Let the popup know its position relative to the source.\n    if (changed.popupLayout) {\n      const { popupLayout } = this[state];\n      if (popupLayout) {\n        const { align, direction } = popupLayout;\n        /** @type {any} */ const popup = this[ids].popup;\n        if (\"position\" in popup) {\n          popup.position = direction;\n        }\n        if (\"align\" in popup) {\n          popup.align = align;\n        }\n      }\n    }\n  }\n\n  [rendered](/** @type {ChangedFlags} */ changed) {\n    super[rendered](changed);\n    const { opened } = this[state];\n    if (changed.opened) {\n      if (opened) {\n        // Worth noting that's possible (but unusual) for a popup to render\n        // opened on first render.\n        waitThenRenderOpened(this);\n      } else {\n        removeEventListeners(this);\n      }\n    } else if (\n      changed.popupLayout &&\n      this[state].opened &&\n      !this[state].popupLayout\n    ) {\n      // A layout-affecting property changed while the popup is open; do layout\n      // again.\n      choosePopupLayout(this);\n    }\n  }\n\n  /**\n   * The class or tag used to create the `source` part - the button\n   * (or other element) the user can tap/click to invoke the popup.\n   *\n   * @type {PartDescriptor}\n   * @default 'button'\n   */\n  get sourcePartType() {\n    return this[state].sourcePartType;\n  }\n  set sourcePartType(sourcePartType) {\n    this[setState]({ sourcePartType });\n  }\n\n  [stateEffects](state, changed) {\n    const effects = super[stateEffects](state, changed);\n\n    // We reset our popup calculations when the popup closes, or if it's open\n    // and state that affects positioning has changed.\n    if (\n      (changed.opened && !state.opened) ||\n      (state.opened &&\n        (changed.popupAlign || changed.popupDirection || changed.rightToLeft))\n    ) {\n      Object.assign(effects, {\n        popupLayout: null,\n      });\n    }\n\n    return effects;\n  }\n\n  get [template]() {\n    const result = super[template];\n    result.content.append(fragmentFrom.html`\n      <style>\n        :host {\n          display: inline-block;\n          position: relative;\n        }\n\n        [part~=\"source\"] {\n          height: 100%;\n          -webkit-tap-highlight-color: transparent;\n          touch-action: manipulation;\n          width: 100%;\n        }\n\n        [part~=\"popup\"] {\n          max-height: 100%;\n          max-width: 100%;\n          outline: none;\n          position: fixed;\n        }\n      </style>\n      <div id=\"source\" part=\"source\">\n        <slot name=\"source\"></slot>\n      </div>\n      <div id=\"popup\" part=\"popup\" exportparts=\"backdrop, frame\" role=\"none\">\n        <slot></slot>\n      </div>\n    `);\n\n    renderParts(result.content, this[state]);\n\n    return result;\n  }\n}\n\nfunction addEventListeners(/** @type {PopupSource} */ element) {\n  /** @type {any} */ const cast = element;\n  cast[resizeListenerKey] = () => {\n    // If viewport resizes while the popup is open, we may want to change which\n    // layout we're using for the popup.\n    choosePopupLayout(element);\n  };\n  const viewport = window.visualViewport || window;\n  viewport.addEventListener(\"resize\", cast[resizeListenerKey]);\n}\n\n/**\n * Based on the current size of the source, popup, and viewport, determine which\n * layout we'll use for the popup.\n *\n * @private\n * @param {PopupSource} element\n */\nfunction choosePopupLayout(element) {\n  const { popupAlign, popupDirection, rightToLeft } = element[state];\n  const sourceRect = element[ids].source.getBoundingClientRect();\n  const popupRect = element[ids].popup.getBoundingClientRect();\n  const boundsRect = viewportBounds();\n\n  const popupLayout = layoutPopup(sourceRect, popupRect, boundsRect, {\n    align: popupAlign,\n    direction: popupDirection,\n    rightToLeft,\n  });\n\n  element[setState]({ popupLayout });\n}\n\n// Given a complete layout for a popup (including the rect), determine the\n// styling that should be applied to the popup.\nfunction getPositiongStylingForLayout(layout) {\n  const { align, direction, rect } = layout;\n  const bounds = viewportBounds();\n  const styling = {};\n  const vertical = direction === \"above\" || direction === \"below\";\n  switch (direction) {\n    case \"above\":\n      styling.bottom = `${bounds.bottom - rect.bottom}px`;\n      break;\n    case \"below\":\n      styling.top = `${rect.top}px`;\n      break;\n    case \"left\":\n      styling.right = `${bounds.right - rect.right}px`;\n      break;\n    case \"right\":\n      styling.left = `${rect.left}px`;\n      break;\n  }\n  switch (align) {\n    case \"bottom\":\n      styling.bottom = `${bounds.bottom - rect.bottom}px`;\n      break;\n    case \"center\":\n    case \"stretch\":\n      if (vertical) {\n        styling.left = `${rect.left}px`;\n        styling.right = `${bounds.right - rect.right}px`;\n      } else {\n        styling.bottom = `${bounds.bottom - rect.bottom}px`;\n        styling.top = `${rect.top}px`;\n      }\n      break;\n    case \"left\":\n      styling.left = `${rect.left}px`;\n      break;\n    case \"right\":\n      styling.right = `${bounds.right - rect.right}px`;\n      break;\n    case \"top\":\n      styling.top = `${rect.top}px`;\n      break;\n  }\n  return styling;\n}\n\nfunction removeEventListeners(/** @type {PopupSource} */ element) {\n  /** @type {any} */ const cast = element;\n  if (cast[resizeListenerKey]) {\n    const viewport = window.visualViewport || window;\n    viewport.removeEventListener(\"resize\", cast[resizeListenerKey]);\n    cast[resizeListenerKey] = null;\n  }\n}\n\n/**\n * Render parts for the template or an instance.\n *\n * @private\n * @param {DocumentFragment} root\n * @param {PlainObject} state\n * @param {ChangedFlags} [changed]\n */\nfunction renderParts(root, state, changed) {\n  if (!changed || changed.popupPartType) {\n    const { popupPartType } = state;\n    const popup = root.getElementById(\"popup\");\n    if (popup) {\n      transmute(popup, popupPartType);\n    }\n  }\n  if (!changed || changed.sourcePartType) {\n    const { sourcePartType } = state;\n    const source = root.getElementById(\"source\");\n    if (source) {\n      transmute(source, sourcePartType);\n    }\n  }\n}\n\n// Determine the bounding rectangle of the viewport. We prefer the\n// VisualViewport API where that's available, as that handles a pinch-zoomed\n// viewport on mobile. If not availble (as of October 2020, Firefox), we fall\n// back to using the window as the viewport.\nfunction viewportBounds() {\n  // @ts-ignore\n  const viewport = window.visualViewport;\n  const boundsRect = viewport\n    ? new DOMRect(\n        viewport.offsetLeft,\n        viewport.offsetTop,\n        viewport.width,\n        viewport.height\n      )\n    : new DOMRect(0, 0, window.innerWidth, window.innerHeight);\n  return boundsRect;\n}\n\n/**\n *\n * When a popup is first rendered, we let it render invisibly so that it doesn't\n * affect the page layout.\n *\n * We then wait, for two reasons:\n *\n * 1) We need to give the popup time to render invisibly. That lets us get the\n *    true size of the popup content.\n *\n * 2) Wire up events that can dismiss the popup. If the popup was opened because\n *    the user clicked something, that opening click event may still be bubbling\n *    up, and we only want to start listening after it's been processed.\n *    Along the same lines, if the popup caused the page to scroll, we don't\n *    want to immediately close because the page scrolled (only if the user\n *    scrolls).\n *\n * After waiting, we can take care of both of the above tasks.\n *\n * @private\n * @param {PopupSource} element\n */\nfunction waitThenRenderOpened(element) {\n  // Wait a tick to let the newly-opened component actually render.\n  setTimeout(() => {\n    // It's conceivable the popup was closed before the timeout completed,\n    // so double-check that it's still opened before listening to events.\n    if (element[state].opened) {\n      choosePopupLayout(element);\n      addEventListeners(element);\n    }\n  });\n}\n\nexport default PopupSource;\n","import { templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport DisabledMixin from \"./DisabledMixin.js\";\nimport {\n  defaultState,\n  ids,\n  render,\n  setState,\n  state,\n  template,\n} from \"./internal.js\";\n\nconst Base = DisabledMixin(ReactiveElement);\n\n/**\n * An element that can point up or down.\n *\n * @inherits ReactiveElement\n * @mixes DisabledMixin\n * @part down-icon - the icon shown in the toggle if the popup will open or close in the down direction\n * @part toggle-icon - both the up and down icons\n * @part up-icon - the icon shown in the toggle if the popup will open or close in the up direction\n */\nclass UpDownToggle extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      direction: \"down\",\n    });\n  }\n\n  /**\n   * Indicates which direction the element should point to.\n   *\n   * @type {'down'|'up'}\n   * @default 'down'\n   */\n  get direction() {\n    return this[state].direction;\n  }\n  set direction(direction) {\n    this[setState]({ direction });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n\n    if (changed.direction) {\n      const { direction } = this[state];\n      this[ids].downIcon.style.display =\n        direction === \"down\" ? \"block\" : \"none\";\n      this[ids].upIcon.style.display = direction === \"up\" ? \"block\" : \"none\";\n    }\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <style>\n        :host {\n          display: inline-block;\n        }\n      </style>\n      <div id=\"downIcon\" part=\"toggle-icon down-icon\">\n        <slot name=\"down-icon\"></slot>\n      </div>\n      <div id=\"upIcon\" part=\"toggle-icon up-icon\">\n        <slot name=\"up-icon\"></slot>\n      </div>\n    `;\n  }\n}\n\nexport default UpDownToggle;\n","import { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { transmute } from \"../core/template.js\";\nimport {\n  defaultState,\n  ids,\n  render,\n  setState,\n  shadowRoot,\n  state,\n  template,\n} from \"./internal.js\";\nimport UpDownToggle from \"./UpDownToggle.js\";\n\n/**\n * Manages a popup toggle part for a popup source.\n *\n * @module PopupToggleMixin\n * @part {UpDownToggle} popup-toggle - the element that lets the user know they can open the popup\n * @part down-icon - the icon shown in the toggle if the popup will open or close in the down direction\n * @part up-icon - the icon shown in the toggle if the popup will open or close in the up direction\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function PopupToggleMixin(Base) {\n  // The class prototype added by the mixin.\n  class PopupToggle extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        popupTogglePartType: UpDownToggle,\n      });\n    }\n\n    /**\n     * The class or tag used to create the `popup-toggle` part – the\n     * element that lets the user know they can open the popup.\n     *\n     * @type {PartDescriptor}\n     * @default UpDownToggle\n     */\n    get popupTogglePartType() {\n      return this[state].popupTogglePartType;\n    }\n    set popupTogglePartType(popupTogglePartType) {\n      this[setState]({ popupTogglePartType });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      super[render](changed);\n\n      renderParts(this[shadowRoot], this[state], changed);\n\n      // Tell the toggle which direction it should point to depending on which\n      // direction the popup will open. Since we assume this is used for up/down\n      // popup directions, we don't handle left/right directions.\n      if (changed.popupDirection || changed.popupTogglePartType) {\n        const { popupDirection } = this[state];\n        const toggleDirection =\n          popupDirection === \"above\" || popupDirection === \"column-reverse\"\n            ? \"up\"\n            : \"down\";\n        /** @type {any} */ const popupToggle = this[ids].popupToggle;\n        if (\"direction\" in popupToggle) {\n          popupToggle.direction = toggleDirection;\n        }\n      }\n\n      if (changed.disabled) {\n        const { disabled } = this[state];\n        /** @type {any} */ (this[ids].popupToggle).disabled = disabled;\n      }\n    }\n\n    get [template]() {\n      const result = super[template];\n\n      // Append a toggle button to the source.\n      const source = result.content.querySelector('[part~=\"source\"]');\n      if (source) {\n        source.append(fragmentFrom.html`\n          <div\n            id=\"popupToggle\"\n            part=\"popup-toggle\"\n            exportparts=\"toggle-icon, down-icon, up-icon\"\n            tabindex=\"-1\"\n          ></div>\n      `);\n      }\n\n      renderParts(result.content, this[state]);\n\n      result.content.append(fragmentFrom.html`\n      <style>\n        [part~=\"popup-toggle\"] {\n          outline: none;\n        }\n\n        [part~=\"source\"] {\n          align-items: center;\n          display: flex;\n        }\n      </style>\n    `);\n\n      return result;\n    }\n  }\n\n  return PopupToggle;\n}\n\n/**\n * Render parts for the template or an instance.\n *\n * @private\n * @param {DocumentFragment} root\n * @param {PlainObject} state\n * @param {ChangedFlags} [changed]\n */\nfunction renderParts(root, state, changed) {\n  if (!changed || changed.popupTogglePartType) {\n    const { popupTogglePartType } = state;\n    const popupToggle = root.getElementById(\"popupToggle\");\n    if (popupToggle) {\n      transmute(popupToggle, popupTogglePartType);\n    }\n  }\n}\n","import { forwardFocus } from \"../core/dom.js\";\nimport { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport { transmute } from \"../core/template.js\";\nimport DelegateFocusMixin from \"./DelegateFocusMixin.js\";\nimport DelegateInputLabelMixin from \"./DelegateInputLabelMixin.js\";\nimport DelegateInputSelectionMixin from \"./DelegateInputSelectionMixin.js\";\nimport FocusVisibleMixin from \"./FocusVisibleMixin.js\";\nimport FormElementMixin from \"./FormElementMixin.js\";\nimport Hidden from \"./Hidden.js\";\nimport {\n  defaultState,\n  ids,\n  inputDelegate,\n  keydown,\n  raiseChangeEvents,\n  render,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  stateEffects,\n  template,\n} from \"./internal.js\";\nimport KeyboardMixin from \"./KeyboardMixin.js\";\nimport PopupDragSelectMixin from \"./PopupDragSelectMixin.js\";\nimport PopupSource from \"./PopupSource.js\";\nimport PopupToggleMixin from \"./PopupToggleMixin.js\";\n\nconst Base = DelegateFocusMixin(\n  DelegateInputLabelMixin(\n    DelegateInputSelectionMixin(\n      FocusVisibleMixin(\n        FormElementMixin(\n          KeyboardMixin(PopupDragSelectMixin(PopupToggleMixin(PopupSource)))\n        )\n      )\n    )\n  )\n);\n\n/**\n * A text input paired with a popup that can be used as an alternative to typing\n *\n * @inherits PopupSource\n * @mixes DelegateFocusMixin\n * @mixes DelegateInputLabelMixin\n * @mixes DelegateInputSelectionMixin\n * @mixes FocusVisibleMixin\n * @mixes FormElementMixin\n * @mixes KeyboardMixin\n * @mixes PopupDragSelectMixin\n * @mixes PopupToggleMixin\n * @part {Hidden} backdrop\n * @part {input} input - the text input element\n * @part {div} source\n */\nclass ComboBox extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      ariaHasPopup: null,\n      confirmedValue: \"\",\n      focused: false,\n      inputPartType: \"input\",\n      orientation: \"vertical\",\n      placeholder: \"\",\n      selectText: false,\n      value: \"\",\n    });\n  }\n\n  get [inputDelegate]() {\n    return this[ids].input;\n  }\n\n  /**\n   * The combo box's input element.\n   *\n   * @type {Element|null}\n   */\n  get input() {\n    return this[shadowRoot] ? this[ids].input : null;\n  }\n\n  /**\n   * The class or tag used to create the `input` part into which the\n   * user can enter text.\n   *\n   * @type {PartDescriptor}\n   * @default 'input'\n   */\n  get inputPartType() {\n    return this[state].inputPartType;\n  }\n  set inputPartType(inputPartType) {\n    this[setState]({ inputPartType });\n  }\n\n  [keydown](/** @type {KeyboardEvent} */ event) {\n    let handled;\n\n    switch (event.key) {\n      // Up/Down arrow keys and Page Up/Page Down open the popup.\n      case \"ArrowDown\":\n      case \"ArrowUp\":\n      case \"PageDown\":\n      case \"PageUp\":\n        if (this.closed) {\n          this.open();\n          handled = true;\n        }\n        break;\n\n      // Enter opens popup.\n      case \"Enter\":\n        if (!this.opened) {\n          this.open();\n          handled = true;\n        }\n        break;\n\n      // Escape cancels popup.\n      case \"Escape\":\n        this.close({ canceled: \"Escape\" });\n        handled = true;\n        break;\n\n      // On Windows, F4 is a standard keyboard shortcut to open or cancel a\n      // combo box.\n      case \"F4\":\n        if (this.opened) {\n          this.close({ canceled: \"F4\" });\n        } else {\n          this.open();\n        }\n        handled = true;\n        break;\n    }\n\n    // Prefer mixin result if it's defined, otherwise use base result.\n    return handled || (super[keydown] && super[keydown](event));\n  }\n\n  /**\n   * The prompt text shown in the input if it is empty.\n   *\n   * @type {string}\n   */\n  get placeholder() {\n    return this[state].placeholder;\n  }\n  set placeholder(placeholder) {\n    this[setState]({\n      placeholder: String(placeholder),\n    });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n\n    renderParts(this[shadowRoot], this[state], changed);\n\n    if (changed.inputPartType) {\n      this[ids].input.addEventListener(\"blur\", () => {\n        this[setState]({\n          focused: false,\n        });\n        // If we're open and lose focus, then close.\n        if (this.opened) {\n          this[raiseChangeEvents] = true;\n          this.close();\n          this[raiseChangeEvents] = false;\n        }\n      });\n\n      this[ids].input.addEventListener(\"focus\", () => {\n        this[raiseChangeEvents] = true;\n        this[setState]({\n          focused: true,\n        });\n        this[raiseChangeEvents] = false;\n      });\n\n      this[ids].input.addEventListener(\"input\", () => {\n        this[raiseChangeEvents] = true;\n        /** @type {any} */\n        const cast = this[ids].input;\n        const value = cast.value;\n        /** @type {PlainObject} */ const changes = {\n          value,\n          selectText: false,\n        };\n        if (this.closed && value > \"\") {\n          // If user types while popup is closed, implicitly open it.\n          changes.opened = true;\n        }\n        this[setState](changes);\n        this[raiseChangeEvents] = false;\n      });\n\n      this[ids].input.addEventListener(\"keydown\", () => {\n        this[raiseChangeEvents] = true;\n        this[setState]({\n          selectText: false,\n        });\n        this[raiseChangeEvents] = false;\n      });\n\n      // If the user clicks on the input and the popup is closed, open it.\n      this[ids].input.addEventListener(\"mousedown\", (event) => {\n        // Only process events for the main (usually left) button.\n        if (/** @type {MouseEvent} */ (event).button !== 0) {\n          return;\n        }\n        this[raiseChangeEvents] = true;\n        this[setState]({\n          selectText: false,\n        });\n        if (this.closed && !this.disabled) {\n          this.open();\n        }\n        this[raiseChangeEvents] = false;\n      });\n    }\n\n    // If input wants to know whether combo box is opened, let it know.\n    if (changed.opened || changed.inputPartType) {\n      /** @type {any} */ const input = this[ids].input;\n      if (\"opened\" in input) {\n        const { opened } = this[state];\n        input.opened = opened;\n      }\n    }\n\n    if (changed.popupTogglePartType) {\n      const popupToggle = this[ids].popupToggle;\n      const input = this[ids].input;\n      popupToggle.addEventListener(\"mousedown\", (event) => {\n        // Only process events for the main (usually left) button.\n        if (/** @type {MouseEvent} */ (event).button !== 0) {\n          return;\n        }\n        // Ignore mousedown if we're presently disabled.\n        if (this[state].disabled) {\n          event.preventDefault();\n          return;\n        }\n        this[raiseChangeEvents] = true;\n        this.toggle();\n        this[raiseChangeEvents] = false;\n      });\n      if (popupToggle instanceof HTMLElement && input instanceof HTMLElement) {\n        // Forward focus for new toggle button.\n        forwardFocus(popupToggle, input);\n      }\n    }\n\n    if (changed.popupPartType) {\n      const popup = this[ids].popup;\n      /** @type {any} */ const cast = popup;\n\n      // Make popup not focusable.\n      popup.removeAttribute(\"tabindex\");\n\n      // Override popup's backdrop to hide it.\n      if (\"backdropPartType\" in popup) {\n        cast.backdropPartType = Hidden;\n      }\n      if (\"autoFocus\" in popup) {\n        cast.autoFocus = false;\n      }\n      const frame = cast.frame;\n      if (frame) {\n        Object.assign(frame.style, {\n          display: \"flex\",\n          flexDirection: \"column\",\n        });\n      }\n      if (\"closeOnWindowResize\" in popup) {\n        cast.closeOnWindowResize = false;\n      }\n    }\n\n    if (changed.disabled) {\n      const { disabled } = this[state];\n      /** @type {any} */ (this[ids].input).disabled = disabled;\n      /** @type {any} */ (this[ids].popupToggle).disabled = disabled;\n    }\n\n    if (changed.placeholder) {\n      const { placeholder } = this[state];\n      /** @type {any} */ (this[ids].input).placeholder = placeholder;\n    }\n\n    if (changed.value) {\n      const { value } = this[state];\n      /** @type {any} */ (this[ids].input).value = value;\n    }\n  }\n\n  [rendered](/** @type {ChangedFlags} */ changed) {\n    super[rendered](changed);\n    if (this[state].selectText) {\n      // Select the text in the input after giving the inner input a chance to render the value.\n      setTimeout(() => {\n        // Text selection might have been turned off in the interim;\n        // double-check that we still want to select text.\n        if (this[state].selectText) {\n          /** @type {any} */\n          const cast = this[ids].input;\n          const value = cast.value;\n          if (value > \"\") {\n            cast.selectionStart = 0;\n            cast.selectionEnd = cast.value.length;\n          }\n        }\n      });\n    }\n  }\n\n  [stateEffects](state, changed) {\n    const effects = super[stateEffects](state, changed);\n\n    // If the value changes while the popup is closed (or closing), consider the\n    // value to be confirmed. This confirmed value will be restored if the user\n    // later opens the popup and then cancels it. On the other hand, if the user\n    // is cancelling the popup, then restore the value from the most recent\n    // confirmed value.\n    if (changed.opened || changed.value) {\n      const { closeResult, opened } = state;\n      if (!opened) {\n        const canceled = closeResult && closeResult.canceled;\n        if (canceled) {\n          // Restore previous confirmed value.\n          Object.assign(effects, {\n            value: state.confirmedValue,\n          });\n        } else {\n          // Confirm current value.\n          Object.assign(effects, {\n            confirmedValue: state.value,\n          });\n        }\n      }\n    }\n\n    // Select text on closing.\n    // Exception: on mobile devices, leaving the text selected may show\n    // selection handles, which may suggest to the user that there's something\n    // more they should be doing with the text even though they're done with it.\n    // We therefore avoid leaving text selected if an on-screen keyboard is in\n    // use. Since we can't actually detect that, we use the absence of a\n    // fine-grained pointer (mouse) as a proxy for mobile.\n    if (changed.opened && !state.opened) {\n      const probablyMobile = matchMedia(\"(pointer: coarse)\").matches;\n      const selectText = !probablyMobile;\n      Object.assign(effects, { selectText });\n    }\n\n    return effects;\n  }\n\n  get [template]() {\n    const result = super[template];\n\n    // Put an input element and toggle in the source.\n    const sourceSlot = result.content.querySelector('slot[name=\"source\"]');\n    if (sourceSlot) {\n      sourceSlot.replaceWith(fragmentFrom.html`\n        <input id=\"input\" part=\"input\"></input>\n      `);\n    }\n\n    renderParts(result.content, this[state]);\n\n    result.content.append(\n      fragmentFrom.html`\n        <style>\n          [part~=\"source\"] {\n            background-color: inherit;\n            display: inline-grid;\n            grid-template-columns: 1fr auto;\n            position: relative;\n          }\n\n          [part~=\"input\"] {\n            outline: none;\n          }\n        </style>\n      `\n    );\n\n    return result;\n  }\n\n  get value() {\n    return this[state].value;\n  }\n  set value(value) {\n    this[setState]({ value });\n  }\n}\n\n/**\n * Render parts for the template or an instance.\n *\n * @private\n * @param {DocumentFragment} root\n * @param {PlainObject} state\n * @param {ChangedFlags} [changed]\n */\nfunction renderParts(root, state, changed) {\n  if (!changed || changed.inputPartType) {\n    const { inputPartType } = state;\n    const input = root.getElementById(\"input\");\n    if (input) {\n      transmute(input, inputPartType);\n    }\n  }\n}\n\nexport default ComboBox;\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { inputDelegate } from \"./internal.js\";\n\n/**\n * Delegates text selection methods and properties to an inner input-type element\n *\n * This mixin makes it easy for you to support the complete set standard DOM\n * APIs for selecting text by delegating those methods to an inner input-type\n * element.\n *\n * You can identify which inner input element selection should be delegated to\n * by defining an `internal.inputDelegate` property and returning the desired\n * inner input.\n *\n * @module DelegateInputSelectionMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function DelegateInputSelectionMixin(Base) {\n  // The class prototype added by the mixin.\n  class DelegateInputSelection extends Base {\n    /**\n     * Selects all the text.\n     *\n     * See the standard [select](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select)\n     * documentation for details.\n     */\n    select() {\n      this[inputDelegate].select();\n    }\n\n    /**\n     * The end index of the selected text.\n     *\n     * See the standard [input](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement)\n     * element documentation for details.\n     */\n    get selectionEnd() {\n      return this[inputDelegate].selectionEnd;\n    }\n    set selectionEnd(selectionEnd) {\n      this[inputDelegate].selectionEnd = selectionEnd;\n    }\n\n    /**\n     * The beginning index of the selected text.\n     *\n     * See the standard [input](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement)\n     * element documentation for details.\n     */\n    get selectionStart() {\n      return this[inputDelegate].selectionStart;\n    }\n    set selectionStart(selectionStart) {\n      this[inputDelegate].selectionStart = selectionStart;\n    }\n\n    /**\n     * Replaces a range of text.\n     *\n     * See the standard [setRangeText](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setRangeText)\n     * documentation for details.\n     */\n    setRangeText(...params) {\n      this[inputDelegate].setRangeText(...params);\n    }\n\n    /**\n     * Sets the start and end positions of the current text selection.\n     *\n     * See the standard [setSelectionRange](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange)\n     * documentation for details.\n     */\n    setSelectionRange(...params) {\n      this[inputDelegate].setSelectionRange(...params);\n      /** @type {HTMLInputElement} */ const e = document.createElement(\"input\");\n      e.select;\n    }\n  }\n\n  return DelegateInputSelection;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  goFirst,\n  goLast,\n  goNext,\n  goPrevious,\n  itemsDelegate,\n  setState,\n} from \"./internal.js\";\n\n/**\n * has the effect of adding the component to the tab order in document order.\n *\n * @module DelegateCursorMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function DelegateCursorMixin(Base) {\n  // The class prototype added by the mixin.\n  class DelegateCursor extends Base {\n    [goFirst]() {\n      return delegateCursorOperation(this, goFirst);\n    }\n\n    [goLast]() {\n      return delegateCursorOperation(this, goLast);\n    }\n\n    [goNext]() {\n      return delegateCursorOperation(this, goNext);\n    }\n\n    [goPrevious]() {\n      return delegateCursorOperation(this, goPrevious);\n    }\n  }\n\n  return DelegateCursor;\n}\n\nfunction delegateCursorOperation(element, operation) {\n  /** @type {any} */ const cast = element[itemsDelegate];\n  if (!cast[operation]) {\n    return false;\n  }\n\n  const changed = cast[operation]();\n  if (changed) {\n    const currentIndex = cast.currentIndex;\n    element[setState]({ currentIndex });\n  }\n\n  return changed;\n}\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  itemsDelegate,\n  render,\n  rendered,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/** @type {any} */\nconst itemsChangedListenerKey = Symbol(\"itemsChangedListener\");\n/** @type {any} */\nconst previousItemsDelegateKey = Symbol(\"previousItemsDelegate\");\n/** @type {any} */\nconst currentIndexChangedListenerKey = Symbol(\"currentIndexChangedListener\");\n\n/**\n * Treats the items inside a shadow element as the component's own items.\n *\n * @module DelegateItemsMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function DelegateItemsMixin(Base) {\n  // The class prototype added by the mixin.\n  class DelegateItems extends Base {\n    constructor() {\n      super();\n      // @ts-ignore\n      this[itemsChangedListenerKey] = (event) => {\n        /** @type {any} */\n        const cast = event.target;\n        const delegateItems = cast.items;\n        if (this[state].items !== delegateItems) {\n          this[setState]({\n            items: delegateItems,\n          });\n        }\n      };\n      // @ts-ignore\n      this[currentIndexChangedListenerKey] = (event) => {\n        /** @type {any} */\n        const cast = event;\n        const delegateCurrentIndex = cast.detail.currentIndex;\n        if (this[state].currentIndex !== delegateCurrentIndex) {\n          this[setState]({\n            currentIndex: delegateCurrentIndex,\n          });\n        }\n      };\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        items: null,\n      });\n    }\n\n    /**\n     * The current set of items drawn from the element's current state.\n     *\n     * @returns {Element[]|null} the element's current items\n     */\n    get items() {\n      return this[state] ? this[state].items : null;\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      if (changed.currentIndex) {\n        if (typeof this[itemsDelegate] === \"undefined\") {\n          throw `To use DelegateItemsMixin, ${this.constructor.name} must define a getter for [itemsDelegate].`;\n        }\n        if (\"currentIndex\" in this[itemsDelegate]) {\n          this[itemsDelegate].currentIndex = this[state].currentIndex;\n        }\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      // If the delegate changed, wire up event handlers.\n      const previousItemsDelegate = this[previousItemsDelegateKey];\n      if (this[itemsDelegate] !== previousItemsDelegate) {\n        if (previousItemsDelegate) {\n          // Stop listening to events on previous delegate.\n          previousItemsDelegate.removeEventListener(\n            this[itemsChangedListenerKey]\n          );\n          previousItemsDelegate.removeEventListener(\n            this[currentIndexChangedListenerKey]\n          );\n        }\n        // Start listening to events on new delegate.\n        this[itemsDelegate].addEventListener(\n          \"itemschange\",\n          this[itemsChangedListenerKey]\n        );\n        this[itemsDelegate].addEventListener(\n          \"currentindexchange\",\n          this[currentIndexChangedListenerKey]\n        );\n        this[previousItemsDelegateKey] = this[itemsDelegate];\n      }\n    }\n  }\n\n  return DelegateItems;\n}\n","import { indexOfItemContainingTarget } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  keydown,\n  raiseChangeEvents,\n  render,\n  rendered,\n  setState,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\nconst documentMousemoveListenerKey = Symbol(\"documentMousemoveListener\");\n\n/**\n * Syncs the cursor a popup source and a list-like element inside the popup.\n *\n * This includes support for drag-select operations: the user can mouse down on\n * the source to produce the popup, drag into the popup to highlight an item,\n * then release the mouse to select that item.\n *\n * @module PopupListMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function PopupListMixin(Base) {\n  // The class prototype added by the mixin.\n  class PopupList extends Base {\n    connectedCallback() {\n      super.connectedCallback();\n      // Handle edge case where component is opened, removed, then added back.\n      listenIfOpenAndConnected(this);\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        currentIndex: -1,\n        hasHoveredOverItemSinceOpened: false,\n        popupList: null,\n      });\n    }\n\n    disconnectedCallback() {\n      if (super.disconnectedCallback) {\n        super.disconnectedCallback();\n      }\n      listenIfOpenAndConnected(this);\n    }\n\n    [keydown](/** @type {KeyboardEvent} */ event) {\n      let handled = false;\n\n      switch (event.key) {\n        // Enter closes popup.\n        case \"Enter\":\n          if (this.opened) {\n            selectCurrentItemAndClose(this);\n            handled = true;\n          }\n      }\n\n      // Prefer our result if it's defined, otherwise use base result.\n      return handled || (super[keydown] && super[keydown](event)) || false;\n    }\n\n    [render](changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      if (changed.popupList) {\n        const { popupList } = this[state];\n        if (popupList) {\n          // If the user mouses up on a list item, close the list with that item as\n          // the close result.\n          popupList.addEventListener(\"mouseup\", async (event) => {\n            // If we're doing a drag-select (user moused down on button, dragged\n            // mouse into list, and released), we close. If we're not doing a\n            // drag-select (the user opened the list with a complete click), and\n            // there's a selection, they clicked on an item, so also close.\n            // Otherwise, the user clicked the list open, then clicked on a list\n            // separator or list padding; stay open.\n            const currentIndex = this[state].currentIndex;\n            if (this[state].dragSelect || currentIndex >= 0) {\n              // We don't want the document mouseup handler in\n              // PopupDragSelectMixin to close the popup before we've asked the\n              // list to highlight the selection. We stop event propagation\n              // here, before we enter any async code, to actually stop\n              // propagation.\n              event.stopPropagation();\n              this[raiseChangeEvents] = true;\n              await selectCurrentItemAndClose(this);\n              this[raiseChangeEvents] = false;\n            } else {\n              event.stopPropagation();\n            }\n          });\n\n          // Track changes in the list's cursor.\n          popupList.addEventListener(\"currentindexchange\", (event) => {\n            this[raiseChangeEvents] = true;\n            /** @type {any} */\n            const cast = event;\n            this[setState]({\n              currentIndex: cast.detail.currentIndex,\n            });\n            this[raiseChangeEvents] = false;\n          });\n        }\n      }\n\n      // The popup's current item is represented in the visible list.\n      if (changed.currentIndex || changed.popupList) {\n        const { currentIndex, popupList } = this[state];\n        if (popupList && \"currentIndex\" in popupList) {\n          popupList.currentIndex = currentIndex;\n        }\n      }\n    }\n\n    [rendered](changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      if (changed.opened) {\n        if (this[state].opened) {\n          // Ensure the list's cursor is visible. If the cursor moved while the\n          // list was closed, the cursor may not be in view yet.\n          const { popupList } = this[state];\n          if (popupList.scrollCurrentItemIntoView) {\n            // Give popup time to render.\n            setTimeout(() => {\n              popupList.scrollCurrentItemIntoView();\n            });\n          }\n        }\n        listenIfOpenAndConnected(this);\n      }\n    }\n\n    [stateEffects](state, changed) {\n      const effects = super[stateEffects]\n        ? super[stateEffects](state, changed)\n        : {};\n\n      // When opening, reset out notion of whether the user has hovered over an\n      // item since the list was opened.\n      if (changed.opened && state.opened) {\n        Object.assign(effects, {\n          hasHoveredOverItemSinceOpened: false,\n        });\n      }\n\n      return effects;\n    }\n  }\n\n  return PopupList;\n}\n\n// Handle a mouse hover select operation.\nfunction handleMousemove(/** @type {MouseEvent} */ event) {\n  // @ts-ignore\n  const element = this;\n  const { hasHoveredOverItemSinceOpened, opened } = element[state];\n  if (opened) {\n    // Treat the deepest element in the composed event path as the target.\n    const target = event.composedPath ? event.composedPath()[0] : event.target;\n    const items = element.items;\n\n    if (target && target instanceof Node && items) {\n      const hoverIndex = indexOfItemContainingTarget(items, target);\n      const item = items[hoverIndex];\n\n      // If the user is hovering over an enabled item, make it current.\n      // If the user is not hovering over an enabled item, but has\n      // hovered over such an item at least once since the list was\n      // opened, then clear cursor.\n      const currentIndex = item && !item.disabled ? hoverIndex : -1;\n\n      if (\n        (hasHoveredOverItemSinceOpened || currentIndex >= 0) &&\n        currentIndex !== element[state].currentIndex\n      ) {\n        element[raiseChangeEvents] = true;\n        element[setState]({ currentIndex });\n        if (currentIndex >= 0 && !hasHoveredOverItemSinceOpened) {\n          element[setState]({ hasHoveredOverItemSinceOpened: true });\n        }\n        element[raiseChangeEvents] = false;\n      }\n    }\n  }\n}\n\nfunction listenIfOpenAndConnected(element) {\n  if (element[state].opened && element.isConnected) {\n    if (!element[documentMousemoveListenerKey]) {\n      // Not listening yet; start.\n      element[documentMousemoveListenerKey] = handleMousemove.bind(element);\n      document.addEventListener(\n        \"mousemove\",\n        element[documentMousemoveListenerKey]\n      );\n    }\n  } else if (element[documentMousemoveListenerKey]) {\n    // Currently listening; stop.\n    document.removeEventListener(\n      \"mousemove\",\n      element[documentMousemoveListenerKey]\n    );\n    element[documentMousemoveListenerKey] = null;\n  }\n}\n\n/**\n * Highlight the current item (if one exists), then close the menu.\n */\nasync function selectCurrentItemAndClose(element) {\n  const originalRaiseChangeEvents = element[raiseChangeEvents];\n  const cursorDefined = element[state].currentIndex >= 0;\n  const items = element.items;\n  if (items) {\n    const closeResult = cursorDefined\n      ? items[element[state].currentIndex]\n      : undefined;\n\n    const list = element[state].popupList;\n    if (cursorDefined && \"flashCurrentItem\" in list) {\n      await list.flashCurrentItem();\n    }\n    const saveRaiseChangeEvents = element[raiseChangeEvents];\n    element[raiseChangeEvents] = originalRaiseChangeEvents;\n    await element.close(closeResult);\n    element[raiseChangeEvents] = saveRaiseChangeEvents;\n  }\n}\n","import { forwardFocus } from \"../core/dom.js\";\nimport { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport { transmute } from \"../core/template.js\";\nimport ComboBox from \"./ComboBox.js\";\nimport { getDefaultText } from \"./content.js\";\nimport CursorAPIMixin from \"./CursorAPIMixin.js\";\nimport DelegateCursorMixin from \"./DelegateCursorMixin.js\";\nimport DelegateItemsMixin from \"./DelegateItemsMixin.js\";\nimport {\n  defaultState,\n  getItemText,\n  goFirst,\n  goLast,\n  goNext,\n  goPrevious,\n  ids,\n  itemsDelegate,\n  keydown,\n  render,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  stateEffects,\n  template,\n} from \"./internal.js\";\nimport ListBox from \"./ListBox.js\";\nimport PopupListMixin from \"./PopupListMixin.js\";\nimport SingleSelectAPIMixin from \"./SingleSelectAPIMixin.js\";\n\nconst Base = CursorAPIMixin(\n  DelegateCursorMixin(\n    DelegateItemsMixin(PopupListMixin(SingleSelectAPIMixin(ComboBox)))\n  )\n);\n\n/**\n * A combo box whose popup presents a list of choices\n *\n * @inherits ComboBox\n * @mixes CursorAPIMixin\n * @mixes DelegateCursorMixin\n * @mixes DelegateItemsMixin\n * @mixes PopupListMixin\n * @mixes SingleSelectAPIMixin\n * @part {ListBox} list - the list of choices\n */\nclass ListComboBox extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      currentIndex: -1,\n      listPartType: ListBox,\n      popupAlign: \"stretch\",\n      selectedIndex: -1,\n      selectedItem: null,\n    });\n  }\n\n  /**\n   * Extract the text from the given item.\n   *\n   * The default implementation returns an item's `aria-label`, `alt` attribute,\n   * `innerText`, or `textContent`, in that order. You can override this to\n   * return the text that should be used.\n   *\n   * @param {ListItemElement} item\n   * @returns {string}\n   */\n  [getItemText](item) {\n    return getDefaultText(item);\n  }\n\n  // We do our own handling of the Up and Down arrow keys, rather than relying\n  // on KeyboardDirectionMixin. The latter supports Home and End, and we don't\n  // want to handle those -- we want to let the text input handle them.\n  // We also need to forward PageDown/PageUp to the list element.\n  [keydown](/** @type {KeyboardEvent} */ event) {\n    let handled;\n    /** @type {any} */\n    const list = this[ids].list;\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (this.opened) {\n          handled = event.altKey ? this[goLast]() : this[goNext]();\n        }\n        break;\n\n      case \"ArrowUp\":\n        if (this.opened) {\n          handled = event.altKey ? this[goFirst]() : this[goPrevious]();\n        }\n        break;\n\n      case \"PageDown\":\n        if (this.opened) {\n          handled = list.pageDown && list.pageDown();\n        }\n        break;\n\n      case \"PageUp\":\n        if (this.opened) {\n          handled = list.pageUp && list.pageUp();\n        }\n        break;\n    }\n\n    // If the list's current index changed as a result of a keyboard operation,\n    // update the selected index. We distinguish between keyboard operations\n    // (which update both cursor and selection) and mouse hover operations\n    // (which update the cursor, but not the selection).\n    if (handled) {\n      const { selectedIndex } = this[state];\n      if (selectedIndex !== list.currentIndex) {\n        this[setState]({\n          selectedIndex: list.currentIndex,\n        });\n      }\n    }\n\n    // Prefer mixin result if it's defined, otherwise use base result.\n    return handled || (super[keydown] && super[keydown](event));\n  }\n\n  /**\n   * The class or tag used to create the `list` part - the list of\n   * available choices shown in the popup.\n   *\n   * @type {PartDescriptor}\n   * @default ListBox\n   */\n  get listPartType() {\n    return this[state].listPartType;\n  }\n  set listPartType(listPartType) {\n    this[setState]({ listPartType });\n  }\n\n  get [itemsDelegate]() {\n    return this[ids].list;\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    if (changed.listPartType && this[ids].list) {\n      // Turn off focus handling for old list.\n      /** @type {any} */\n      const cast = this[ids].list;\n      forwardFocus(cast, null);\n    }\n\n    super[render](changed);\n\n    renderParts(this[shadowRoot], this[state], changed);\n\n    if (changed.listPartType) {\n      // Keep focus off of the list and on the top level combo box (which should\n      // delegate focus to the input).\n      const list = this[ids].list;\n      if (list instanceof HTMLElement) {\n        forwardFocus(list, this);\n      }\n    }\n  }\n\n  [rendered](changed) {\n    super[rendered](changed);\n\n    // Indicate which component is the popup's list.\n    if (changed.listPartType) {\n      this[setState]({\n        popupList: this[ids].list,\n      });\n    }\n  }\n\n  /**\n   * The `value` attribute of the selected item. If no item is selected, this\n   * returns the empty string.\n   *\n   * You can set this property to select the item with a matching `value`\n   * attribute.\n   *\n   * @type {string}\n   */\n  get selectedItemValue() {\n    const { items, selectedIndex } = this[state];\n    const selectedItem = items ? items[selectedIndex] : null;\n    return selectedItem ? selectedItem.getAttribute(\"value\") : \"\";\n  }\n  set selectedItemValue(selectedItemValue) {\n    const { items } = this[state];\n    const s = String(selectedItemValue);\n    const selectedIndex = items.findIndex(\n      (item) => item.getAttribute(\"value\") === s\n    );\n    this[setState]({ selectedIndex });\n  }\n\n  [stateEffects](state, changed) {\n    const effects = super[stateEffects](state, changed);\n\n    // We want the cursor to track the selection, but we don't always want the\n    // selection to track the cursor. (A mouse hover operation on the list will\n    // update the cursor, but shouldn't update the selection.) For that reason,\n    // we can't use the CursorSelectMixin, which updates in both directions.\n    if (changed.selectedIndex) {\n      Object.assign(effects, {\n        currentIndex: state.selectedIndex,\n      });\n    }\n    if (changed.selectedItem) {\n      Object.assign(effects, {\n        currentItem: state.selectedItem,\n      });\n    }\n\n    // If value was changed directly or typed, or items have updated, select the\n    // corresponding item in list.\n    if (changed.items || changed.value) {\n      const { value } = state;\n      /** @type {ListItemElement[]} */ const items = state.items;\n      if (items && value != null) {\n        const searchText = value.toLowerCase();\n        const currentIndex = items.findIndex((item) => {\n          const itemText = this[getItemText](item);\n          return itemText.toLowerCase() === searchText;\n        });\n        Object.assign(effects, {\n          currentIndex,\n        });\n      }\n    }\n\n    // If user selects a new item, make the item's text the value.\n    if (changed.selectedIndex) {\n      const { items, selectedIndex, value } = state;\n      const currentItem = items ? items[selectedIndex] : null;\n      const currentItemText = currentItem ? this[getItemText](currentItem) : \"\";\n      // See notes on mobile at ComboBox.defaultState.\n      const probablyMobile = matchMedia(\"(pointer: coarse)\").matches;\n      const selectText = !probablyMobile;\n      if (value !== currentItemText) {\n        Object.assign(effects, {\n          selectText,\n          value: currentItemText,\n        });\n      }\n    }\n\n    // If closing, make current item the selected item.\n    if (changed.opened) {\n      const { closeResult, currentIndex, opened } = state;\n      const closing = changed.opened && !opened;\n      const canceled = closeResult && closeResult.canceled;\n      if (closing && !canceled && currentIndex >= 0) {\n        Object.assign(effects, {\n          selectedIndex: currentIndex,\n        });\n      }\n    }\n\n    // When items change, we need to recalculate popup size.\n    if (changed.items) {\n      Object.assign(effects, {\n        popupMeasured: false,\n      });\n    }\n\n    return effects;\n  }\n\n  get [template]() {\n    const result = super[template];\n\n    // Wrap default slot with a list.\n    const defaultSlot = result.content.querySelector(\"slot:not([name])\");\n    if (defaultSlot) {\n      defaultSlot.replaceWith(fragmentFrom.html`\n        <div id=\"list\" part=\"list\" tabindex=\"-1\">\n          <slot></slot>\n        </div>\n      `);\n    }\n\n    result.content.append(fragmentFrom.html`\n      <style>\n        [part~=\"list\"] {\n          border: none;\n          flex: 1;\n          height: 100%;\n          max-height: 100%;\n          overscroll-behavior: contain;\n          width: 100%;\n        }\n      </style>\n    `);\n\n    renderParts(result.content, this[state]);\n\n    return result;\n  }\n}\n\n/**\n * Render parts for the template or an instance.\n *\n * @private\n * @param {DocumentFragment} root\n * @param {PlainObject} state\n * @param {ChangedFlags} [changed]\n */\nfunction renderParts(root, state, changed) {\n  if (!changed || changed.listPartType) {\n    const { listPartType } = state;\n    const list = root.getElementById(\"list\");\n    if (list) {\n      transmute(list, listPartType);\n    }\n  }\n}\n\nexport default ListComboBox;\n","import AutoCompleteInput from \"./AutoCompleteInput.js\";\nimport { defaultState, ids, render, state } from \"./internal.js\";\nimport ItemsTextMixin from \"./ItemsTextMixin.js\";\nimport ListComboBox from \"./ListComboBox.js\";\n\nconst Base = ItemsTextMixin(ListComboBox);\n\n/**\n * A combo box that auto-completes the user's input against the list items\n *\n * @inherits ListComboBox\n * @mixes ItemsTextMixin\n * @part {AutoCompleteInput} input\n */\nclass AutoCompleteComboBox extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      inputPartType: AutoCompleteInput,\n    });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n    if (changed.texts) {\n      if (\"texts\" in this[ids].input) {\n        /** @type {any} */ (this[ids].input).texts = this[state].texts;\n      }\n    }\n  }\n}\n\nexport default AutoCompleteComboBox;\n","import AutoCompleteComboBox from \"elix/src/base/AutoCompleteComboBox.js\";\nimport {\n  defaultState,\n  render,\n  rendered,\n  ids,\n  renderDataToElement,\n  state,\n  stateEffects,\n  setState,\n  template,\n} from \"elix/src/base/internal.js\";\nimport { templateFrom, fragmentFrom } from \"elix/src/core/htmlLiterals\";\n\nexport default class SdsCombobox extends AutoCompleteComboBox {\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      acceptTyping: false,\n      data: null,\n      itemPartType: \"div\",\n    });\n  }\n\n  get options() {\n    return this[state].data;\n  }\n  set options(options) {\n    this[setState]({\n      data: options,\n    });\n  }\n\n  [rendered](changed) {\n    super[rendered](changed);\n    if (changed.data || changed.itemPartType) {\n      const { data, itemPartType } = this[state];\n      // TODO: Reuse existing items array if present, just invoke\n      // `renderDataToElement` to update data.\n      if (data) {\n        const items = data.map((entry) => {\n          const item = createElement(itemPartType);\n          this[renderDataToElement](entry, item);\n          return item;\n        });\n        dom.updateChildNodes(this, items);\n      }\n    }\n  }\n\n  [renderDataToElement](entry, item) {\n    const { label, value } = entry;\n    item.textContent = label;\n    item.setAttribute(\"value\", value);\n  }\n\n  get [template]() {\n    const result = super[template];\n\n    result.content.append(fragmentFrom.html`\n      <style>\n        ::part(frame) {\n          background: var(--sds-g-color-neutral-base-1);\n          width: 100%;\n          border-bottom-left-radius: 4px;\n          border-bottom-right-radius: 4px;\n          box-shadow: 0 3px 12px rgba(53,71,90,.2);\n        }\n        ::part(input) {\n          width: 250px;\n          border: 1px solid var(--sds-g-color-neutral-base-4);\n          border-radius: 4px;\n          padding: 0.25rem;\n        }\n        ::slotted([role=\"option\"]) {\n          padding: 0.25rem 1rem;\n        }\n      </style>\n    `);\n\n    return result;\n  }\n}\n\ncustomElements.define(\"sds-combobox\", SdsCombobox);\n","import { templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport AriaMenuMixin from \"./AriaMenuMixin.js\";\nimport CursorAPIMixin from \"./CursorAPIMixin.js\";\nimport CursorInViewMixin from \"./CursorInViewMixin.js\";\nimport DelegateFocusMixin from \"./DelegateFocusMixin.js\";\nimport DirectionCursorMixin from \"./DirectionCursorMixin.js\";\nimport {\n  defaultState,\n  firstRender,\n  ids,\n  raiseChangeEvents,\n  render,\n  rendered,\n  scrollTarget,\n  setState,\n  state,\n  stateEffects,\n  tap,\n  template,\n} from \"./internal.js\";\nimport ItemsAPIMixin from \"./ItemsAPIMixin.js\";\nimport ItemsCursorMixin from \"./ItemsCursorMixin.js\";\nimport ItemsTextMixin from \"./ItemsTextMixin.js\";\nimport KeyboardDirectionMixin from \"./KeyboardDirectionMixin.js\";\nimport KeyboardMixin from \"./KeyboardMixin.js\";\nimport KeyboardPagedCursorMixin from \"./KeyboardPagedCursorMixin.js\";\nimport KeyboardPrefixCursorMixin from \"./KeyboardPrefixCursorMixin.js\";\nimport LanguageDirectionMixin from \"./LanguageDirectionMixin.js\";\nimport SlotItemsMixin from \"./SlotItemsMixin.js\";\nimport TapCursorMixin from \"./TapCursorMixin.js\";\n\nconst Base = AriaMenuMixin(\n  CursorAPIMixin(\n    CursorInViewMixin(\n      DelegateFocusMixin(\n        DirectionCursorMixin(\n          ItemsAPIMixin(\n            ItemsCursorMixin(\n              ItemsTextMixin(\n                KeyboardDirectionMixin(\n                  KeyboardMixin(\n                    KeyboardPagedCursorMixin(\n                      KeyboardPrefixCursorMixin(\n                        LanguageDirectionMixin(\n                          SlotItemsMixin(TapCursorMixin(ReactiveElement))\n                        )\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n);\n\n/**\n * A menu of choices or commands\n *\n * This holds the contents of the menu, not the top-level UI element that invokes\n * a menu. For that, see [MenuButton](MenuButton) or [PopupSource](PopupSource).\n *\n * @inherits ReactiveElement\n * @mixes AriaMenuMixin\n * @mixes CursorInViewMixin\n * @mixes CursorAPIMixin\n * @mixes DelegateFocusMixin\n * @mixes DirectionCursorMixin\n * @mixes ItemsAPIMixin\n * @mixes ItemsCursorMixin\n * @mixes ItemsTextMixin\n * @mixes KeyboardDirectionMixin\n * @mixes KeyboardMixin\n * @mixes KeyboardPagedCursorMixin\n * @mixes KeyboardPrefixCursorMixin\n * @mixes LanguageDirectionMixin\n * @mixes SingleSelectAPIMixin\n * @mixes SlotItemsMixin\n * @mixes TapCursorMixin\n */\nclass Menu extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      availableItemFlags: null,\n      highlightCurrentItem: true,\n      orientation: \"vertical\",\n      currentItemFocused: false,\n    });\n  }\n\n  /**\n   * Flash the current item.\n   *\n   * By default, this uses a heuristic to guess whether the menu was closed by a\n   * keyboard or mouse (on desktop). If so, the menu flashes the current item\n   * off then back on, emulating the menu item selection effect in macOS.\n   * Otherwise, it does nothing.\n   */\n  async flashCurrentItem() {\n    const keyboardActive = this[state].focusVisible;\n    const probablyDesktop = matchMedia(\"(pointer: fine)\").matches;\n    if (keyboardActive || probablyDesktop) {\n      const flashDuration = 75; // milliseconds\n      this[setState]({ highlightCurrentItem: false });\n      await new Promise((resolve) => setTimeout(resolve, flashDuration));\n      this[setState]({ highlightCurrentItem: true });\n      await new Promise((resolve) => setTimeout(resolve, flashDuration));\n    }\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n\n    if (this[firstRender]) {\n      // Listen to changes in disabled state.\n      this.addEventListener(\"disabledchange\", (event) => {\n        this[raiseChangeEvents] = true;\n        /** @type {any} */ const target = event.target;\n        const { items } = this[state];\n        const index = items === null ? -1 : items.indexOf(target);\n        if (index >= 0) {\n          // Update item availability.\n          const availableItemFlags = this[state].availableItemFlags.slice();\n          availableItemFlags[index] = !target.disabled;\n          this[setState]({ availableItemFlags });\n        }\n        this[raiseChangeEvents] = false;\n      });\n\n      // Treat a pointerdown event as a tap.\n      if (\"PointerEvent\" in window) {\n        // Prefer listening to standard pointer events.\n        this.addEventListener(\"pointerdown\", (event) => this[tap](event));\n      } else {\n        this.addEventListener(\"touchstart\", (event) => this[tap](event));\n      }\n\n      this.removeAttribute(\"tabindex\");\n    }\n\n    const { currentIndex, items } = this[state];\n\n    // Highlight the current item.\n    if (\n      (changed.items || changed.currentIndex || changed.highlightCurrentItem) &&\n      items\n    ) {\n      const { highlightCurrentItem } = this[state];\n      items.forEach((item, index) => {\n        item.toggleAttribute(\n          \"current\",\n          highlightCurrentItem && index === currentIndex\n        );\n      });\n    }\n\n    if (\n      (changed.items ||\n        changed.currentIndex ||\n        changed.currentItemFocused ||\n        changed.focusVisible) &&\n      items\n    ) {\n      // A menu has a complicated focus arrangement in which the current item has\n      // focus, which means it needs a tabindex. However, we don't want any other\n      // item in the menu to have a tabindex, so that if the user presses Tab or\n      // Shift+Tab, they move away from the menu entirely (rather than just moving\n      // to the next or previous item).\n      //\n      // That's already complex, but to make things worse, if we remove the\n      // tabindex from an item that has the focus, the focus gets moved to the\n      // document. In popup menus, the popup will conclude it's lost the focus,\n      // and implicitly close. So we want to move the focus in two phases: 1)\n      // set tabindex on a newly-current item so we can focus on it, 2) after\n      // the new item has been focused, remove the tabindex from any\n      // previous item.\n      items.forEach((item, index) => {\n        const current = index === currentIndex;\n        const isDefaultFocusableItem = currentIndex < 0 && index === 0;\n        if (!this[state].currentItemFocused) {\n          // Phase 1: Add tabindex to newly-current item.\n          if (current || isDefaultFocusableItem) {\n            item.tabIndex = 0;\n          }\n        } else {\n          // Phase 2: Remove tabindex from any previous item.\n          if (!(current || isDefaultFocusableItem)) {\n            item.removeAttribute(\"tabindex\");\n          }\n        }\n      });\n    }\n  }\n\n  [rendered](/** @type {ChangedFlags} */ changed) {\n    super[rendered](changed);\n    if (\n      !this[firstRender] &&\n      changed.currentIndex &&\n      !this[state].currentItemFocused\n    ) {\n      // The current item needs the focus, but this is complicated. See notes\n      // in render.\n      const { currentItem } = this[state];\n      const focusElement =\n        currentItem instanceof HTMLElement ? currentItem : this;\n      focusElement.focus();\n\n      // Now that the current item has been focused, we can remove/reset the\n      // tabindex on any item that had previously been current.\n      this[setState]({\n        currentItemFocused: true,\n      });\n    }\n  }\n\n  // @ts-ignore\n  get [scrollTarget]() {\n    return this[ids].content;\n  }\n\n  [stateEffects](state, changed) {\n    const effects = super[stateEffects](state, changed);\n\n    // When current item changes, we'll need to focus on it in rendered.\n    if (changed.currentIndex) {\n      Object.assign(effects, {\n        currentItemFocused: false,\n      });\n    }\n\n    // Mark disabled items as unavailable.\n    if (changed.items) {\n      const { items } = state;\n      const availableItemFlags =\n        items === null ? null : items.map((item) => !item.disabled);\n      Object.assign(effects, { availableItemFlags });\n    }\n\n    return effects;\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <style>\n        :host {\n          box-sizing: border-box;\n          cursor: default;\n          display: inline-flex;\n          -webkit-tap-highlight-color: transparent;\n          touch-action: manipulation;\n        }\n\n        #content {\n          display: flex;\n          flex: 1;\n          flex-direction: column;\n          max-height: 100%;\n          overflow-x: hidden;\n          overflow-y: auto;\n          -webkit-overflow-scrolling: touch; /* for momentum scrolling */\n        }\n        \n        ::slotted(*) {\n          flex-shrink: 0;\n          outline: none;\n          touch-action: manipulation;\n        }\n\n        ::slotted(option) {\n          font: inherit;\n          min-height: inherit;\n        }\n      </style>\n      <div id=\"content\" role=\"none\">\n        <slot></slot>\n      </div>\n    `;\n  }\n}\n\nexport default Menu;\n","import ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport { defaultAriaRole } from \"./accessibility.js\";\nimport {\n  defaultState,\n  render,\n  rendering,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Tells assistive technologies to describe a list's items as a menu of choices.\n *\n * @module AriaMenuMixin\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function AriaMenuMixin(Base) {\n  // The class prototype added by the mixin.\n  class AriaMenu extends Base {\n    // @ts-ignore\n    get [defaultState]() {\n      const base = super[defaultState];\n      return Object.assign(base, {\n        itemRole: base.itemRole || \"menuitem\",\n        role: base.role || \"menu\",\n      });\n    }\n\n    get itemRole() {\n      return this[state].itemRole;\n    }\n    set itemRole(itemRole) {\n      this[setState]({ itemRole });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      /** @type {ListItemElement[]} */ const items = this[state].items;\n      if ((changed.items || changed.itemRole) && items) {\n        // Give each item a role.\n        const { itemRole } = this[state];\n        items.forEach((item) => {\n          if (itemRole === defaultAriaRole[item.localName]) {\n            item.removeAttribute(\"role\");\n          } else {\n            item.setAttribute(\"role\", itemRole);\n          }\n        });\n      }\n\n      if (changed.role) {\n        // Apply top-level role.\n        const { role } = this[state];\n        this.setAttribute(\"role\", role);\n      }\n    }\n\n    // Setting the standard role attribute will invoke this property setter,\n    // which will allow us to update our state.\n    get role() {\n      return super.role;\n    }\n    set role(role) {\n      super.role = role;\n      if (!this[rendering]) {\n        this[setState]({ role });\n      }\n    }\n  }\n\n  return AriaMenu;\n}\n","import { deepContains, ownEvent } from \"../core/dom.js\";\nimport { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport DelegateFocusMixin from \"./DelegateFocusMixin.js\";\nimport {\n  defaultState,\n  firstRender,\n  ids,\n  keydown,\n  raiseChangeEvents,\n  render,\n  state,\n  template,\n} from \"./internal.js\";\nimport KeyboardMixin from \"./KeyboardMixin.js\";\nimport PopupDragSelectMixin from \"./PopupDragSelectMixin.js\";\nimport PopupSource from \"./PopupSource.js\";\n\nconst Base = DelegateFocusMixin(\n  KeyboardMixin(PopupDragSelectMixin(PopupSource))\n);\n\n/**\n * A button that invokes an attached popup\n *\n * @inherits PopupSource\n * @mixes DelegateFocusMixin\n * @mixes KeyboardMixin\n * @mixes PopupDragSelectMixin\n */\nclass PopupButton extends Base {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      sourcePartType: \"button\",\n    });\n  }\n\n  [keydown](/** @type {KeyboardEvent} */ event) {\n    let handled;\n\n    switch (event.key) {\n      // Space or Up/Down arrow keys open the popup.\n      case \" \":\n      case \"ArrowDown\":\n      case \"ArrowUp\":\n        if (this.closed) {\n          this.open();\n          handled = true;\n        }\n        break;\n\n      // Enter opens popup.\n      case \"Enter\":\n        if (!this.opened) {\n          this.open();\n          handled = true;\n        }\n        break;\n\n      // If popup is open, pressing Esc should close popup.\n      // This code exists to handle cases where the popup does not take the\n      // focus (autoFocus is false). In cases where the popup takes focus, it\n      // will be up to the popup to handle closing when Esc is pressed.\n      case \"Escape\":\n        if (this.opened) {\n          this.close({\n            canceled: \"Escape\",\n          });\n          handled = true;\n        }\n        break;\n    }\n\n    // Give superclass a chance to handle.\n    handled = super[keydown] && super[keydown](event);\n\n    if (!handled && this.opened && !event.metaKey && !event.altKey) {\n      // If they haven't already been handled, absorb keys that might cause the\n      // page to scroll in the background, which would in turn cause the popup to\n      // inadvertently close.\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n        case \"PageDown\":\n        case \"PageUp\":\n        case \" \":\n          handled = true;\n      }\n    }\n\n    return handled;\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n\n    if (this[firstRender]) {\n      // Close the popup if we're opened and lose focus. A typical popup using\n      // PopupModalityMixin will have its own logic to close on blur -- but in\n      // cases where the popup itself doesn't get focus (e.g., TooltipButton),\n      // that logic won't apply.\n      this.addEventListener(\"blur\", blurHandler.bind(this));\n\n      // If the source element gets the focus while the popup is open, the\n      // most likely expanation is that the user hit Shift+Tab to back up out of\n      // the popup. In that case, we should close.\n      this[ids].source.addEventListener(\"focus\", async (event) => {\n        const popupFocused = ownEvent(this[ids].popup, event);\n        // It's possible to get a focus event in the initial mousedown on the\n        // source button before the popup is even rendered. We don't want to\n        // close in that case, so we check to see if we've already measured the\n        // popup dimensions (which will be true if the popup fully completed\n        // rendering).\n        const measured = this[state].popupHeight !== null;\n        if (!popupFocused && this.opened && measured) {\n          this[raiseChangeEvents] = true;\n          await this.close();\n          this[raiseChangeEvents] = false;\n        }\n      });\n    }\n\n    if (changed.opened) {\n      // Reflect opened state to attribute for styling.\n      const { opened } = this[state];\n      this.toggleAttribute(\"opened\", opened);\n    }\n\n    if (changed.sourcePartType) {\n      // Desktop popups generally open on mousedown, not click/mouseup. On mobile,\n      // mousedown won't fire until the user releases their finger, so it behaves\n      // like a click.\n      const source = this[ids].source;\n      source.addEventListener(\"mousedown\", (event) => {\n        // mousedown events fire even if button is disabled, so we need\n        // to explicitly ignore those.\n        if (this.disabled) {\n          event.preventDefault();\n          return;\n        }\n        // Only handle primary button mouse down to avoid interfering with\n        // right-click behavior.\n        /** @type {any} */\n        const cast = event;\n        if (cast.button && cast.button !== 0) {\n          return;\n        }\n        // We give the default focus behavior time to run before opening the\n        // popup. See note below.\n        setTimeout(() => {\n          if (!this.opened) {\n            this[raiseChangeEvents] = true;\n            this.open();\n            this[raiseChangeEvents] = false;\n          }\n        });\n        event.stopPropagation();\n        // We don't prevent the default behavior for mousedown. Among other\n        // things, it sets the focus to the element the user moused down on.\n        // That's important for us, because OverlayMixin will remember that\n        // focused element (i.e., this element) when opening, and restore focus to\n        // it when the popup closes.\n      });\n    }\n\n    if (changed.popupPartType) {\n      this[ids].popup.removeAttribute(\"tabindex\");\n    }\n  }\n\n  get [template]() {\n    const result = super[template];\n    // When popup is open, it will have focus; don't show focus ring on host.\n    result.content.append(\n      fragmentFrom.html`\n        <style>\n          [part~=\"source\"] {\n            cursor: default;\n            outline: none;\n            -webkit-tap-highlight-color: transparent;\n            touch-action: manipulation;\n            -moz-user-select: none;\n            -ms-user-select: none;\n            -webkit-user-select: none;\n            user-select: none;\n          }\n\n          :host([opened][focus-visible]) {\n            outline: none;\n          }\n        </style>\n      `\n    );\n    return result;\n  }\n}\n\n// Note: This routine also exists in PopupModalityMixin, may want to eventually\n// share that. Note that PopupModalityMixin handles blur on the *popup*; here\n// we're dealing with the source button.\nasync function blurHandler(/** @type {Event} */ event) {\n  // @ts-ignore\n  /** @type {any} */ const element = this;\n  // What has the focus now?\n  const newFocusedElement =\n    /** @type {any} */ (event).relatedTarget || document.activeElement;\n  /** @type {any} */\n  if (\n    newFocusedElement instanceof Element &&\n    !deepContains(element, newFocusedElement)\n  ) {\n    element[raiseChangeEvents] = true;\n    await element.close({ canceled: \"blur\" });\n    element[raiseChangeEvents] = false;\n  }\n}\n\nexport default PopupButton;\n","import { updateChildNodes } from \"../core/dom.js\";\nimport { fragmentFrom } from \"../core/htmlLiterals.js\";\nimport { replace, transmute } from \"../core/template.js\";\nimport CursorAPIMixin from \"./CursorAPIMixin.js\";\nimport DelegateInputLabelMixin from \"./DelegateInputLabelMixin.js\";\nimport FormElementMixin from \"./FormElementMixin.js\";\nimport {\n  applyElementData,\n  defaultState,\n  ids,\n  render,\n  rendered,\n  setState,\n  shadowRoot,\n  state,\n  stateEffects,\n  template,\n} from \"./internal.js\";\nimport ItemsAPIMixin from \"./ItemsAPIMixin.js\";\nimport ItemsCursorMixin from \"./ItemsCursorMixin.js\";\nimport Menu from \"./Menu.js\";\nimport PopupButton from \"./PopupButton.js\";\nimport PopupListMixin from \"./PopupListMixin.js\";\nimport SelectedTextAPIMixin from \"./SelectedTextAPIMixin.js\";\nimport SelectedValueAPIMixin from \"./SelectedValueAPIMixin.js\";\nimport SingleSelectAPIMixin from \"./SingleSelectAPIMixin.js\";\nimport SlotItemsMixin from \"./SlotItemsMixin.js\";\n\nconst Base = CursorAPIMixin(\n  DelegateInputLabelMixin(\n    FormElementMixin(\n      ItemsAPIMixin(\n        ItemsCursorMixin(\n          PopupListMixin(\n            SelectedTextAPIMixin(\n              SelectedValueAPIMixin(\n                SingleSelectAPIMixin(SlotItemsMixin(PopupButton))\n              )\n            )\n          )\n        )\n      )\n    )\n  )\n);\n\n/**\n * Shows a single choice made from a pop-up list of choices\n *\n * @inherits PopupButton\n * @mixes CursorAPIMixin\n * @mixes DelegateInputLabelMixin\n * @mixes FormElementMixin\n * @mixes ItemsAPIMixin\n * @mixes ItemsCursorMixin\n * @mixes PopupListMixin\n * @mixes SelectedTextAPIMixin\n * @mixes SelectedValueAPIMixin\n * @mixes SingleSelectAPIMixin\n * @mixes SlotItemsMixin\n *\n * @part {Menu} list - the list shown in the popup\n * @part down-icon - the icon shown in the toggle if the popup will open or close in the down direction\n * @part up-icon - the icon shown in the toggle if the popup will open or close in the up direction\n * @part {div} value - region inside the toggle button showing the value of the current selection\n */\nclass DropdownList extends Base {\n  // Apply the data shown in the source element (an item in the list) to the\n  // target element (the value part). The default implementation clones the\n  // source's childNodes and sets those as as the child nodes of the target.\n  [applyElementData](source, target) {\n    const sourceChildNodes = source ? [...source.childNodes] : [];\n    const clones = sourceChildNodes.map((node) => node.cloneNode(true));\n    updateChildNodes(target, clones);\n  }\n\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      ariaHasPopup: \"listbox\",\n      listPartType: Menu,\n      selectedIndex: -1,\n      selectedItem: null,\n      valuePartType: \"div\",\n    });\n  }\n\n  // @ts-ignore\n  get items() {\n    /** @type {any} */\n    const list = this[ids] && this[ids].list;\n    return list ? list.items : null;\n  }\n\n  /**\n   * The class or tag used to define the `list` part – the element\n   * presenting the list items and handling navigation between them.\n   *\n   * @type {PartDescriptor}\n   * @default List\n   */\n  get listPartType() {\n    return this[state].listPartType;\n  }\n  set listPartType(listPartType) {\n    this[setState]({ listPartType });\n  }\n\n  [render](/** @type {ChangedFlags} */ changed) {\n    super[render](changed);\n\n    renderParts(this[shadowRoot], this[state], changed);\n\n    // Update selection.\n    if (changed.items || changed.selectedIndex) {\n      const { items, selectedIndex } = this[state];\n      const selectedItem = items ? items[selectedIndex] : null;\n\n      // Apply the data from the selected item to the value part.\n      this[applyElementData](selectedItem, this[ids].value);\n\n      // Mark only the selected item as selected.\n      if (items) {\n        items.forEach((/** @type {any} */ item) => {\n          if (\"selected\" in item) {\n            item.selected = item === selectedItem;\n          }\n        });\n      }\n    }\n\n    if (changed.opened) {\n      // Reflect opened state to source for ARIA.\n      const { opened } = this[state];\n      this[ids].source.setAttribute(\"aria-expanded\", opened.toString());\n    }\n\n    if (changed.sourcePartType) {\n      /** @type {any} */ const source = this[ids].source;\n      // HACK — need better way to forward button role to inner button.\n      if (source.inner) {\n        source.inner.setAttribute(\"role\", \"none\");\n      }\n    }\n  }\n\n  [rendered](changed) {\n    super[rendered](changed);\n\n    // Indicate which component is the popup's list.\n    if (changed.listPartType) {\n      this[setState]({\n        popupList: this[ids].list,\n      });\n    }\n  }\n\n  [stateEffects](state, changed) {\n    const effects = super[stateEffects](state, changed);\n\n    // When opening the popup, by default (re)select the current item.\n    if (changed.opened && state.opened) {\n      Object.assign(effects, {\n        currentIndex: state.selectedIndex,\n      });\n    }\n\n    // If closing, make current item the selected item.\n    if (changed.opened) {\n      const { closeResult, currentIndex, opened } = state;\n      const closing = changed.opened && !opened;\n      const canceled = closeResult && closeResult.canceled;\n      if (closing && !canceled && currentIndex >= 0) {\n        Object.assign(effects, {\n          selectedIndex: currentIndex,\n        });\n      }\n    }\n\n    // If we get items while closed and don't have a selection, select the first\n    // item.\n    if (changed.items || changed.selectedIndex) {\n      const { items, opened, selectedIndex } = state;\n      if (!opened && selectedIndex < 0 && items && items.length > 0) {\n        Object.assign(effects, {\n          selectedIndex: 0,\n        });\n      }\n    }\n\n    return effects;\n  }\n\n  get [template]() {\n    const result = super[template];\n\n    // Replace the source slot with an element to show the value.\n    const sourceSlot = result.content.querySelector('slot[name=\"source\"]');\n    if (sourceSlot) {\n      replace(\n        sourceSlot,\n        fragmentFrom.html` <div id=\"value\" part=\"value\"></div> `\n      );\n    }\n\n    // Wrap default slot with a list.\n    const defaultSlot = result.content.querySelector(\"slot:not([name])\");\n    if (defaultSlot) {\n      defaultSlot.replaceWith(fragmentFrom.html`\n        <div id=\"list\" part=\"list\">\n          <slot></slot>\n        </div>\n      `);\n    }\n\n    // Apply combobox semantics to the source button. Because focus moves to the\n    // list itself when the popup opens, the aria-controls attribute has no\n    // effect other than convincing the browser to announce the button as a\n    // combobox.\n    const source = result.content.querySelector('[part~=\"source\"]');\n    if (source) {\n      source.setAttribute(\"aria-activedescendant\", \"value\");\n      source.setAttribute(\"aria-autocomplete\", \"none\");\n      source.setAttribute(\"aria-controls\", \"list\");\n      source.setAttribute(\"role\", \"combobox\");\n    }\n\n    renderParts(result.content, this[state]);\n\n    result.content.append(fragmentFrom.html`\n      <style>\n        [part~=\"list\"] {\n          max-height: 100%;\n        }\n      </style>\n    `);\n\n    return result;\n  }\n\n  /**\n   * The class or tag used to create the `value` part - the region\n   * showing the dropdown list's current value.\n   *\n   * @type {PartDescriptor}\n   * @default 'div'\n   */\n  get valuePartType() {\n    return this[state].valuePartType;\n  }\n  set valuePartType(valuePartType) {\n    this[setState]({ valuePartType });\n  }\n}\n\n/**\n * Render parts for the template or an instance.\n *\n * @private\n * @param {DocumentFragment} root\n * @param {PlainObject} state\n * @param {ChangedFlags} [changed]\n */\nfunction renderParts(root, state, changed) {\n  if (!changed || changed.listPartType) {\n    const { listPartType } = state;\n    const list = root.getElementById(\"list\");\n    if (list) {\n      transmute(list, listPartType);\n    }\n  }\n  if (!changed || changed.valuePartType) {\n    const { valuePartType } = state;\n    const value = root.getElementById(\"value\");\n    if (value) {\n      transmute(value, valuePartType);\n    }\n  }\n}\n\nexport default DropdownList;\n","import { template } from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class SdsPopupToggle extends ReactiveElement {\n  get [template]() {\n    return templateFrom.html`\n      <style>\n        :host {\n          margin-left: auto;\n          display: flex;\n        }\n        svg {\n          fill: var(--sds-g-color-neutral-base-contrast-1);\n          width: 12px;\n          height: 12px;\n        }\n      </style>\n      <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 52 52\"><path d=\"M47.6 17.8L27.1 38.5c-.6.6-1.6.6-2.2 0L4.4 17.8c-.6-.6-.6-1.6 0-2.2l2.2-2.2c.6-.6 1.6-.6 2.2 0l16.1 16.3c.6.6 1.6.6 2.2 0l16.1-16.2c.6-.6 1.6-.6 2.2 0l2.2 2.2c.5.6.5 1.5 0 2.1z\"></path></svg>\n    `;\n  }\n}\n","import DropdownList from \"elix/src/base/DropdownList.js\";\nimport PopupToggleMixin from \"elix/src/base/PopupToggleMixin\";\nimport {\n  defaultState,\n  render,\n  rendered,\n  ids,\n  renderDataToElement,\n  state,\n  stateEffects,\n  setState,\n  template,\n} from \"elix/src/base/internal.js\";\nimport { templateFrom, fragmentFrom } from \"elix/src/core/htmlLiterals\";\nimport SdsPopupToggle from \"./Toggle\";\n\nexport default class SdsSelect extends PopupToggleMixin(DropdownList) {\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      horizontalAlign: \"stretch\",\n      popupTogglePartType: SdsPopupToggle,\n    });\n  }\n\n  get [template]() {\n    const result = super[template];\n\n    result.content.append(fragmentFrom.html`\n      <style>\n        [part~=\"source\"] {\n          width: 220px;\n          background: var(--sds-g-color-neutral-base-1);\n          border: 1px solid var(--sds-g-color-neutral-base-4);\n          border-radius: 4px;\n          padding: 0.25rem;\n        }\n        ::part(frame) {\n          background: var(--sds-g-color-neutral-base-1);\n          width: 100%;\n          border-bottom-left-radius: 4px;\n          border-bottom-right-radius: 4px;\n          box-shadow: 0 3px 12px rgba(53,71,90,.2);\n        }\n        ::slotted([role=\"menuitem\"]) {\n          padding: 0.25rem 1rem;\n        }\n        ::slotted([current]) {\n          background: var(--sds-g-color-brand-base-2);\n        }\n      </style>\n    `);\n\n    return result;\n  }\n}\n\ncustomElements.define(\"sds-select\", SdsSelect);\n","import { templateFrom } from \"../core/htmlLiterals.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\";\nimport AriaRoleMixin from \"./AriaRoleMixin.js\";\nimport CurrentMixin from \"./CurrentMixin.js\";\nimport DisabledMixin from \"./DisabledMixin.js\";\nimport { defaultState, template } from \"./internal.js\";\nimport SelectableMixin from \"./SelectableMixin.js\";\n\n/**\n * An option in a set of choices\n *\n * This is designed for use inside single-select components like\n * [DropdownList](DropdownList) that want to distinguish between an option being\n * the current item (the one the user is navigating with the keyboard, say) and\n * being the selected item (the one chosen by the user as the desired value for\n * a field).\n *\n * @inherits ReactiveElement\n * @mixes CurrentMixin\n * @mixes DisabledMixin\n * @mixes SelectableMixin\n */\nclass Option extends AriaRoleMixin(\n  CurrentMixin(DisabledMixin(SelectableMixin(ReactiveElement)))\n) {\n  // @ts-ignore\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      role: \"option\",\n    });\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <style>\n        :host {\n          display: block;\n        }\n      </style>\n      <slot></slot>\n    `;\n  }\n}\n\nexport default Option;\n","import { booleanAttributeValue, setInternalState } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  nativeInternals,\n  render,\n  rendered,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Tracks whether an item is the current item.\n *\n * @module CurrentMixin\n * @state current\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function CurrentMixin(Base) {\n  // The class prototype added by the mixin.\n  return class Current extends Base {\n    constructor() {\n      super();\n      /** @type {any} */ const cast = this;\n      if (!this[nativeInternals] && cast.attachInternals) {\n        this[nativeInternals] = cast.attachInternals();\n      }\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n      if (name === \"current\") {\n        const value = booleanAttributeValue(name, newValue);\n        if (this.current !== value) {\n          this.current = value;\n        }\n      } else {\n        super.attributeChangedCallback(name, oldValue, newValue);\n      }\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        current: false,\n      });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      super[render](changed);\n      if (changed.current) {\n        const { current } = this[state];\n        setInternalState(this, \"current\", current);\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      // TODO: How do we know whether to raise this if selection is set by Menu? */\n      if (changed.current /* && this[raiseChangeEvents] */) {\n        const { current } = this[state];\n        const oldEvent = new CustomEvent(\"current-changed\", {\n          bubbles: true,\n          detail: { current },\n        });\n        this.dispatchEvent(oldEvent);\n        /**\n         * Raised when the `current` property changes.\n         *\n         * @event currentchange\n         */\n        const event = new CustomEvent(\"currentchange\", {\n          bubbles: true,\n          detail: { current },\n        });\n        this.dispatchEvent(event);\n      }\n    }\n\n    /**\n     * True if the element is currently current.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get current() {\n      return this[state].current;\n    }\n    set current(current) {\n      // Note: AttributeMarshallingMixin will recognize `current` as the name of\n      // attribute that should be parsed as a boolean attribute, and so will\n      // handling parsing it for us.\n      this[setState]({ current });\n    }\n  };\n}\n","import { setInternalState } from \"../core/dom.js\";\nimport ReactiveElement from \"../core/ReactiveElement.js\"; // eslint-disable-line no-unused-vars\nimport {\n  defaultState,\n  nativeInternals,\n  render,\n  rendered,\n  setState,\n  state,\n} from \"./internal.js\";\n\n/**\n * Tracks whether the element is currently selected.\n *\n * @module SelectableMixin\n * @state selected\n * @param {Constructor<ReactiveElement>} Base\n */\nexport default function SelectableMixin(Base) {\n  // The class prototype added by the mixin.\n  return class Selectable extends Base {\n    constructor() {\n      super();\n      /** @type {any} */ const cast = this;\n      if (!this[nativeInternals] && cast.attachInternals) {\n        this[nativeInternals] = cast.attachInternals();\n      }\n    }\n\n    // @ts-ignore\n    get [defaultState]() {\n      return Object.assign(super[defaultState] || {}, {\n        selected: false,\n      });\n    }\n\n    [render](/** @type {ChangedFlags} */ changed) {\n      super[render](changed);\n      if (changed.selected) {\n        const { selected } = this[state];\n        setInternalState(this, \"selected\", selected);\n      }\n    }\n\n    [rendered](/** @type {ChangedFlags} */ changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n\n      // TODO: How do we know whether to raise this if selection is set by Menu? */\n      if (changed.selected /* && this[raiseChangeEvents] */) {\n        const { selected } = this[state];\n        const oldEvent = new CustomEvent(\"selected-changed\", {\n          bubbles: true,\n          detail: { selected },\n        });\n        this.dispatchEvent(oldEvent);\n        /**\n         * Raised when the `selected` property changes.\n         *\n         * @event selectedchange\n         */\n        const event = new CustomEvent(\"selectedchange\", {\n          bubbles: true,\n          detail: { selected },\n        });\n        this.dispatchEvent(event);\n      }\n    }\n\n    /**\n     * True if the element is currently selected.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    get selected() {\n      return this[state].selected;\n    }\n    set selected(selected) {\n      // Note: AttributeMarshallingMixin will recognize `selected` as the name of\n      // attribute that should be parsed as a boolean attribute, and so will\n      // handling parsing it for us.\n      this[setState]({ selected });\n    }\n  };\n}\n","import { template } from \"elix/src/base/internal.js\";\nimport Option from \"elix/src/base/Option.js\";\nimport { fragmentFrom } from \"elix/src/core/htmlLiterals\";\n\nexport default class SdsOption extends Option {\n  get [template]() {\n    const result = super[template];\n\n    result.content.append(fragmentFrom.html`\n\n    `);\n\n    return result;\n  }\n}\n\ncustomElements.define(\"sds-option\", SdsOption);\n"],"names":["defaultState","Symbol","delegatesFocus","firstRender","focusTarget","hasDynamicTemplate","ids","nativeInternals","raiseChangeEvents","render","renderChanges","rendered","rendering","setState","shadowRoot","shadowRootMode","state","stateEffects","template","applyElementData","checkSize","closestAvailableItemIndex","contentSlot","coreInternal.defaultState","defaultTabIndex","coreInternal.delegatesFocus","effectEndTarget","coreInternal.firstRender","coreInternal.focusTarget","getItemText","goDown","goEnd","goFirst","goLast","goLeft","goNext","goPrevious","goRight","goStart","goToItemWithPrefix","goUp","coreInternal.hasDynamicTemplate","coreInternal.ids","inputDelegate","itemsDelegate","keydown","matchText","mouseenter","mouseleave","coreInternal.nativeInternals","coreInternal.raiseChangeEvents","coreInternal.render","coreInternal.renderChanges","renderDataToElement","coreInternal.rendered","coreInternal.rendering","scrollTarget","coreInternal.setState","coreInternal.shadowRoot","coreInternal.shadowRootMode","startEffect","coreInternal.state","coreInternal.stateEffects","swipeDown","swipeDownComplete","swipeLeft","swipeLeftTransitionEnd","swipeRight","swipeRightTransitionEnd","swipeUp","swipeUpComplete","swipeStart","swipeTarget","tap","coreInternal.template","toggleSelectedFlag","URLSearchParams","location","search","get","elix","internal","event","fragmentFrom","strings","substitutions","templateFrom","html","content","[object Object]","document","createElement","innerHTML","String","raw","mousedownListenerKey","booleanAttributeValue","name","value","toLowerCase","closestFocusableNode","node","current","selfAndComposedAncestors","target","cast","HTMLElement","tabIndex","disabled","HTMLSlotElement","deepContains","container","parent","assignedSlot","parentNode","host","firstFocusableElement","root","walker","walkComposedTree","matches","next","forwardFocus","origin","removeEventListener","button","focusableTarget","focus","preventDefault","addEventListener","indexOfItemContainingTarget","items","Array","prototype","findIndex","call","item","ownEvent","eventSource","composedPath","ShadowRoot","composedAncestors","setInternalState","element","toggleAttribute","states","toggle","standardBooleanAttributes","checked","defer","hidden","ismap","multiple","noresize","readonly","selected","updateChildNodes","childNodes","copy","oldLength","length","newLength","Math","max","i","oldChild","newChild","append","removeChild","indexOf","insertBefore","replaceChild","filter","children","assignedNodes","flatten","attributeToPropertyNames","tabindex","propertyNamesToAttributes","attributesForClass","classFn","baseClass","Object","getPrototypeOf","constructor","baseAttributes","observedAttributes","diff","getOwnPropertyNames","propertyName","descriptor","getOwnPropertyDescriptor","set","map","setterName","attribute","replace","propertyNameToAttribute","concat","stateKey","raiseChangeEventsInNextRenderKey","changedSinceLastRenderKey","fieldsChanged","changes","changed","field","value2","value1","Date","getTime","classTemplateMap","Map","shadowIdProxyKey","proxyElementKey","shadowIdProxyHandler","id","getElementById","getTemplate","t","undefined","HTMLTemplateElement","ReactiveElement","Base","attributeName","oldValue","newValue","super","attributeChangedCallback","this","match","toUpperCase","attributeToPropertyName","parsed","AttributeMarshallingMixin","Reactive","connectedCallback","saveRaiseChangeEvents","console","warn","assign","effects","changedByEffects","keys","copyStateWithChanges","freeze","willRender","isConnected","Promise","resolve","defineProperty","ReactiveMixin","Proxy","attachShadow","mode","clone","importNode","ShadowTemplateMixin","WorkletColor","defaultState$1","prop","pickerEl","picker","colorEl","color","nameEl","valueEl","setAttribute","textContent","style","setProperty","_checkContrast","e","nameProp","getAttribute","documentElement","select","el","c","parseInt","substr","template$1","customElements","define","WorkletColors","_getProps","computedStyleMap","forEach","arr","getComputedStyle","getPropertyValue","a","props","push","split","toString","slice","hooks","results","test","hook","insertAdjacentHTML","WorkletCss","css","cb","targetNode","MutationObserver","mutationList","observer","mutation","type","cssText","observe","attributes","WorkletPreview","component","WorkletHeader","page","nav","WorkletRipple","canvas","x","y","start","performance","now","offsetX","offsetY","requestAnimationFrame","raf","count","floor","removeAttribute","SdsButton","mapBaseTagToCount","original","replacement","SVGElement","classList","className","add","key","transmute","Element","localName","baseTag","classNameMatch","letter","offset","tag","registerCustomElement","DelegateInputLabelMixin","ariaLabel","removingAriaAttribute","ariaLabelledby","inputLabel","refreshInputLabel","window","requestIdleCallback","setTimeout","selectedText","getLabelFromElement","option","options","find","innerText","rootNode","getRootNode","elementWithId","join","elementWithFor","querySelector","labelElement","closest","trim","keyboardActive","focusVisibleChangedListenerKey","FocusVisibleMixin","then","newFocusedElement","relatedTarget","activeElement","isFocusedElement","containsFocus","focusVisible","result","updateKeyboardActive","newKeyboardActive","oldEvent","CustomEvent","detail","dispatchEvent","FormElementMixin","attachInternals","checkValidity","validationMessage","valid","internals","formAssociated","form","s","setValidity","customError","setFormValue","reportValidity","validity","willValidate","DelegateFocusMixin","delegatesFocus$1","focusOptions","focusElement","focusTarget$1","capture","extendsKey","delegatedPropertySettersKey","focusableByDefault","area","details","iframe","input","textarea","reraiseEvents","address","blockquote","caption","center","dd","dir","div","dl","dt","fieldset","frame","h1","h2","h3","h4","h5","h6","img","li","link","menu","object","ol","p","script","tbody","tfoot","thead","mouseEventNames","eventBubbles","abort","change","reset","blockElements","attributesWithoutProperties","WrappedStandardElement","innerAttributes","inner","blur","extends","eventName","Event","bubbles","stopImmediatePropagation","applyAttribute","property","display","includes","extendsTag","Wrapped","cls","names","delegate","configurable","enumerable","args","writable","createMethodDelegate","getInnerProperty","setInnerProperty","createPropertyDelegate","createDelegate","defineDelegates","selectionEnd","selectionStart","refreshListener","refreshSelectionState","bind","TrackTextSelectionMixin","wrap","Input","valueCopy","generatedIdKey","generatedIdCount","defaultAriaRole","article","hr","output","progress","table","td","th","ul","ensureId","focusTest","nativeDelegatesFocus","CursorAPIMixin","currentIndex","Number","currentItemRequired","cursorOperationsWrap","isNaN","currentItem","defaultScrollTarget","slot","ancestor","isElementScrollable","getScrollableElement","overflowX","overflowY","CursorInViewMixin","scrollCurrentItemIntoView","scrollTargetRect","getBoundingClientRect","itemRect","bottomDelta","bottom","leftDelta","left","rightDelta","right","topDelta","top","orientation","scrollLeft","ceil","scrollTop","DirectionCursorMixin","canGoDown","canGoLeft","canGoRight","canGoUp","rightToLeft","canGoNext","canGoPrevious","languageDirection","horizontal","vertical","ItemsAPIMixin","ItemsCursorMixin","direction","index","end","availableItemFlags","desiredCurrentIndex","moveToIndex","newIndex","newDesiredIndex","newItemIndex","min","auxiliarycustomTags","getDefaultText","ItemsTextMixin","texts","getText","from","getTextsFromItems","KeyboardDirectionMixin","handled","altKey","metaKey","KeyboardMixin","async","KeyboardPagedCursorMixin","pageDown","pageUp","scrollOnePage","getIndexOfItemAtY","downward","step","itemStyle","itemPaddingTop","paddingTop","parseFloat","itemPaddingBottom","paddingBottom","contentTop","clientHeight","targetRect","indexOfItemAtEdge","currentRect","pageHeight","saveRaiseChangesEvents","typedPrefixKey","prefixTimeoutKey","KeyboardPrefixCursorMixin","resetTypedPrefix","prefix","searchText","text","previousIndex","setPrefixTimeout","handleBackspace","ctrlKey","char","handlePlainCharacter","resetPrefixTimeout","clearTimeout","LanguageDirectionMixin","SelectedTextAPIMixin","selectedIndex","selectedItem","indexOfItemWithText","SelectedValueAPIMixin","indexOfItemWithValue","SingleSelectAPIMixin","SlotContentMixin","SlotItemsMixin","isSubstantiveElement","ContentItemsMixin","TapCursorMixin","touchAction","mozUserSelect","msUserSelect","webkitUserSelect","userSelect","Node","targetIndex","stopPropagation","base","itemRole","role","selectedItemFlags","AriaListMixin","composeFocus","ComposedFocusMixin","CursorSelectMixin","ListBox","flexDirection","AutoCompleteInput","autoCompleteSelect","opened","originalText","textIndex","prefixLowerCase","startsWith","typingAtEnd","userAddedText","autoComplete","accessibleList","list","InputEvent","Hidden","documentMouseupListenerKey","PopupDragSelectMixin","listenIfOpenAndConnected","dragSelect","disconnectedCallback","handleMouseup","hitTargets","elementsFromPoint","clientX","clientY","overSource","source","popup","overPopup","overPopupFrame","close","DisabledMixin","availableSpace","sourceRect","boundsRect","align","sourceOrigin","getSourceOrigin","height","width","closePromiseKey","closeResolveKey","OpenCloseMixin","closeResult","closed","closeFinished","defaults","effect","effectPhase","openCloseEffects","open","openedChangeEvent","oldOpenedEvent","openEvent","oldClosedEvent","closeEvent","closeResolve","AriaRoleMixin","Backdrop","OverlayFrame","appendedToDocumentKey","defaultZIndexKey","restoreFocusToElementKey","bringToFront","defaultZIndex","elements","body","querySelectorAll","zIndices","zIndex","position","maxZIndexInUse","hasZIndex","computedZIndex","isExplicitZIndexNumeric","autoFocus","persistent","OverlayMixin","renderParts","backdropPartType","backdrop","framePartType","implicitCloseListenerKey","blurHandler","canceled","closeHandler","handleEvent","closeOnWindowResize","PopupModalityMixin","Popup","mousedownHandler","resizeListenerKey","PopupSource","ariaHasPopup","popupAlign","popupDirection","popupLayout","popupPartType","sourcePartType","horizontalAlign","popupPosition","positionStyling","layout","rect","bounds","viewportBounds","styling","getPositiongStylingForLayout","opacity","choosePopupLayout","visualViewport","addEventListeners","removeEventListeners","popupRect","normalized","logicalAlign","logicalDirection","physicalDirection","above","below","column","column-reverse","row","row-reverse","crossAxis","stretch","normalizeOptions","layouts","preferredDirection","preferredAlign","flipDirection","flipAlign","possibilties","prioritizedLayouts","sort","layout1","layout2","space1","space2","fitsWidth1","fitsHeight1","fitsEither1","fitsBoth1","fitsWidth2","fitsHeight2","fitsEither2","fitsBoth2","area1","area2","compareLayouts","boundsLeft","boundsTop","boundsBottom","boundsRight","DOMRect","getPositionedRect","layoutPopup","viewport","offsetLeft","offsetTop","innerWidth","innerHeight","UpDownToggle","downIcon","upIcon","PopupToggleMixin","popupTogglePartType","toggleDirection","popupToggle","params","setRangeText","setSelectionRange","DelegateInputSelectionMixin","inputPartType","delegateCursorOperation","operation","itemsChangedListenerKey","previousItemsDelegateKey","currentIndexChangedListenerKey","documentMousemoveListenerKey","PopupListMixin","hasHoveredOverItemSinceOpened","popupList","selectCurrentItemAndClose","handleMousemove","hoverIndex","originalRaiseChangeEvents","cursorDefined","flashCurrentItem","DelegateCursorMixin","delegateItems","delegateCurrentIndex","previousItemsDelegate","DelegateItemsMixin","confirmedValue","focused","placeholder","selectText","probablyMobile","matchMedia","sourceSlot","replaceWith","listPartType","selectedItemValue","currentItemText","popupMeasured","defaultSlot","AutoCompleteComboBox","SdsCombobox","acceptTyping","data","itemPartType","entry","dom","label","AriaMenuMixin","Menu","highlightCurrentItem","currentItemFocused","probablyDesktop","flashDuration","isDefaultFocusableItem","popupHeight","DropdownList","cloneNode","valuePartType","SdsPopupToggle","SdsSelect","Option","CurrentMixin","SelectableMixin","SdsOption"],"mappings":"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"}