{"version":3,"file":"index.modern.js","sources":["../node_modules/elix/src/core/internal.js","../node_modules/elix/src/base/internal.js","../node_modules/elix/src/core/htmlLiterals.js","../node_modules/elix/src/core/dom.js","../node_modules/elix/src/core/AttributeMarshallingMixin.js","../node_modules/elix/src/core/ReactiveMixin.js","../node_modules/elix/src/core/ShadowTemplateMixin.js","../node_modules/elix/src/core/ReactiveElement.js","../src/components/Color.js","../src/lib/utils.js","../src/components/Colors.js","../src/components/Css.js","../src/components/Preview.js","../src/components/Header.js","../src/components/Ripple.js","../src/components/Button.js"],"sourcesContent":["/**\n * Collection of shared Symbol objects for internal component communication.\n *\n * The shared `Symbol` objects in this module let mixins and a component\n * internally communicate without exposing these internal properties and methods\n * in the component's public API. They also help avoid unintentional name\n * collisions, as a component developer must specifically import the `internal`\n * module and reference one of its symbols.\n *\n * To use these `Symbol` objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol. E.g.,\n * [ShadowTemplateMixin](ShadowTemplateMixin) expects a component to define\n * a property called [template](#template):\n *\n *     import { template } from 'elix/src/core/internal.js';\n *     import { templateFrom } from 'elix/src/core/htmlLiterals.js'\n *     import ShadowTemplateMixin from 'elix/src/core/ShadowTemplateMixin.js';\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       [template]() {\n *         return templateFrom.html`Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * The above use of the internal `template` member lets the mixin find the\n * component's template in a way that will not pollute the component's public\n * API or interfere with other component logic. For example, if for some reason\n * the component wants to define a separate property with the plain string name,\n * \"template\", it can do so without affecting the above property setter.\n *\n * @module internal\n */\n\n/**\n * Symbol for the default state for this element.\n */\nexport const defaultState = Symbol(\"defaultState\");\n\n/**\n * Symbol for the `delegatesFocus` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property, returning\n * true to indicate that the focus is being delegated, even in browsers that\n * don't support that natively. Mixins like [KeyboardMixin](KeyboardMixin) use\n * this to accommodate focus delegation.\n */\nexport const delegatesFocus = Symbol(\"delegatesFocus\");\n\n/**\n * Symbol for the `firstRender` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets the property to `true` during the\n * element's first `render` and `rendered` callback, then `false` in subsequent\n * callbacks.\n *\n * You can inspect this property in your own `rendered` callback handler to do\n * work like wiring up events that should only happen once.\n */\nexport const firstRender = Symbol(\"firstRender\");\n\n/**\n * Symbol for the `focusTarget` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property as either:\n * 1) the element itself, in browsers that support native focus delegation or,\n * 2) the shadow root's first focusable element.\n */\nexport const focusTarget = Symbol(\"focusTarget\");\n\n/**\n * Symbol for the `hasDynamicTemplate` property.\n *\n * If your component class does not always use the same template, define a\n * static class property getter with this symbol and have it return `true`.\n * This will disable template caching for your component.\n */\nexport const hasDynamicTemplate = Symbol(\"hasDynamicTemplate\");\n\n/**\n * Symbol for the `ids` property.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) defines a shorthand function\n * `internal.ids` that can be used to obtain a reference to a shadow element with\n * a given ID.\n *\n * Example: if component's template contains a shadow element\n * `<button id=\"foo\">`, you can use the reference `this[ids].foo` to obtain\n * the corresponding button in the component instance's shadow tree.\n * The `ids` function is simply a shorthand for `getElementById`, so\n * `this[ids].foo` is the same as `this.shadowRoot.getElementById('foo')`.\n */\nexport const ids = Symbol(\"ids\");\n\n/**\n * Symbol for access to native HTML element internals.\n */\nexport const nativeInternals = Symbol(\"nativeInternals\");\n\n/**\n * Symbol for the `raiseChangeEvents` property.\n *\n * This property is used by mixins to determine whether they should raise\n * property change events. The standard HTML pattern is to only raise such\n * events in response to direct user interactions. For a detailed discussion\n * of this point, see the Gold Standard checklist item for\n * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n *\n * The above article describes a pattern for using a flag to track whether\n * work is being performed in response to internal component activity, and\n * whether the component should therefore raise property change events.\n * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n * all Elix mixins and components. Sharing this flag ensures that internal\n * activity (e.g., a UI event listener) in one mixin can signal other mixins\n * handling affected properties to raise change events.\n *\n * All UI event listeners (and other forms of internal handlers, such as\n * timeouts and async network handlers) should set `raiseChangeEvents` to\n * `true` at the start of the event handler, then `false` at the end:\n *\n *     this.addEventListener('click', event => {\n *       this[raiseChangeEvents] = true;\n *       // Do work here, possibly setting properties, like:\n *       this.foo = 'Hello';\n *       this[raiseChangeEvents] = false;\n *     });\n *\n * Elsewhere, property setters that raise change events should only do so it\n * this property is `true`:\n *\n *     set foo(value) {\n *       // Save foo value here, do any other work.\n *       if (this[raiseChangeEvents]) {\n *         export const event = new CustomEvent('foochange');\n *         this.dispatchEvent(event);\n *       }\n *     }\n *\n * In this way, programmatic attempts to set the `foo` property will not trigger\n * the `foochange` event, but UI interactions that update that property will\n * cause those events to be raised.\n */\nexport const raiseChangeEvents = Symbol(\"raiseChangeEvents\");\n\n/**\n * Symbol for the `render` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this `internal.render` method to give\n * the component a chance to render recent changes in component state.\n */\nexport const render = Symbol(\"render\");\n\n/**\n * Symbol for the `renderChanges` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this method in response to a\n * `setState` call; you should generally not invoke this method yourself.\n */\nexport const renderChanges = Symbol(\"renderChanges\");\n\n/**\n * Symbol for the `rendered` method.\n *\n * [ReactiveMixin](ReactiveMixin) will invoke this method after your\n * element has completely finished rendering.\n *\n * If you only want to do work the first time rendering happens (for example, if\n * you want to wire up event handlers), your `internal.rendered` implementation\n * can inspect the `internal.firstRender` flag.\n */\nexport const rendered = Symbol(\"rendered\");\n\n/**\n * Symbol for the `rendering` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets this property to true during rendering,\n * at other times it will be false.\n */\nexport const rendering = Symbol(\"rendering\");\n\n/**\n * Symbol for the `setState` method.\n *\n * A component using [ReactiveMixin](ReactiveMixin) can invoke this method to\n * apply changes to the element's current state.\n */\nexport const setState = Symbol(\"setState\");\n\n/**\n * Symbol for the `shadowRoot` property.\n *\n * This property holds a reference to an element's shadow root, like\n * `this.shadowRoot`. This propery exists because `this.shadowRoot` is not\n * available for components with closed shadow roots.\n * [ShadowTemplateMixin](ShadowTemplateMixin) creates open shadow roots by\n * default, but you can opt into creating closed shadow roots; see\n * [shadowRootMode](internal#internal.shadowRootMode).\n */\nexport const shadowRoot = Symbol(\"shadowRoot\");\n\n/**\n * Symbol for the `shadowRootMode` property.\n *\n * If true (the default), then [ShadowTemplateMixin](ShadowTemplateMixin) will\n * create an open shadow root when the component is instantiated. Set this to\n * false if you want to programmatically hide component internals in a closed\n * shadow root.\n */\nexport const shadowRootMode = Symbol(\"shadowRootMode\");\n\n/**\n * Symbol for the element's current state.\n *\n * This is managed by [ReactiveMixin](ReactiveMixin).\n */\nexport const state = Symbol(\"state\");\n\n/**\n * Symbol for the `stateEffects` method.\n *\n * See [stateEffects](ReactiveMixin#stateEffects).\n */\nexport const stateEffects = Symbol(\"stateEffects\");\n\n/**\n * Symbol for the `template` method.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) uses this property to obtain a\n * component's template, which it will clone into a component's shadow root.\n */\nexport const template = Symbol(\"template\");\n","/**\n * Collection of shared Symbol objects for internal component communication.\n *\n * The shared `Symbol` objects in this module let mixins and a component\n * internally communicate without exposing these internal properties and methods\n * in the component's public API. They also help avoid unintentional name\n * collisions, as a component developer must specifically import the `internal`\n * module and reference one of its symbols.\n *\n * To use these `Symbol` objects in your own component, include this module and\n * then create a property or method whose key is the desired Symbol. E.g.,\n * [ShadowTemplateMixin](ShadowTemplateMixin) expects a component to define\n * a property called [template](#template):\n *\n *     import { template } from 'elix/src/core/internal.js';\n *     import { templateFrom } from 'elix/src/core/htmlLiterals.js'\n *     import ShadowTemplateMixin from 'elix/src/core/ShadowTemplateMixin.js';\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       [template]() {\n *         return templateFrom.html`Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * The above use of the internal `template` member lets the mixin find the\n * component's template in a way that will not pollute the component's public\n * API or interfere with other component logic. For example, if for some reason\n * the component wants to define a separate property with the plain string name,\n * \"template\", it can do so without affecting the above property setter.\n *\n * @module internal\n */\n\nimport * as coreInternal from \"../core/internal.js\";\n\n/**\n * Symbol for the `applyElementData` method.\n *\n * Components that want to be able to apply data from one element to another\n * can support this method. E.g., [DropdownList](DropdownList) uses this to\n * apply data from the selected item to the component's value part.\n */\nexport const applyElementData = Symbol(\"applyElementData\");\n\n/**\n * Symbol for the `checkSize` method.\n *\n * If defined, this method will be invoked by [ResizeMixin](ResizeMixin)\n * when an element's size may have changed. The default implementation of\n * this method compares the element's current `clientHeight` and `clientWidth`\n * properties against the last known values of those properties (saved in\n * `state.clienHeight` and `state.clientWidth`).\n *\n * Components should override this method if they contain elements that may need\n * to know about size changes as well. For example, when an [Overlay](Overlay)\n * mixin opens, it invokes this method on any content elements that define it.\n * This gives the contents a chance to resize in response to being displayed.\n */\nexport const checkSize = Symbol(\"checkSize\");\n\n/**\n * Symbol for the `closestAvailableItemIndex` method.\n *\n * This method is defined by [ItemsCursorMixin](ItemsCursorMixin). You can call\n * this if you want to find an item at a particular location, but may need to\n * account for the fact that the item at that position is not available, and\n * would like to find the closest item that is available.\n */\nexport const closestAvailableItemIndex = Symbol(\"closestAvailableItemIndex\");\n\n/**\n * Symbol for the `contentSlot` property.\n *\n * [SlotContentMixin](SlotContentMixin) uses this to identify which slot\n * element in the component's shadow tree that holds the component's content.\n * By default, this is the first slot element with no \"name\" attribute. You\n * can override this to return a different slot.\n */\nexport const contentSlot = Symbol(\"contentSlot\");\n\n/**\n * The default state for this element.\n */\nexport const defaultState = coreInternal.defaultState;\n\n/**\n * Symbol for the `defaultTabIndex` property.\n *\n * [KeyboardMixin](KeyboardMixin) uses this if it is unable to successfully\n * parse a string tabindex attribute.\n */\nexport const defaultTabIndex = Symbol(\"defaultTabIndex\");\n\n/**\n * Symbol for the `delegatesFocus` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property, returning\n * true to indicate that the focus is being delegated, even in browsers that\n * don't support that natively. Mixins like [KeyboardMixin](KeyboardMixin) use\n * this to accommodate focus delegation.\n */\nexport const delegatesFocus = coreInternal.delegatesFocus;\n\n/**\n * Symbol for the `effectEndTarget` property.\n *\n * [TransitionEffectMixin](TransitionEffectMixin) inspects this property to\n * determine which element's `transitionend` event will signal the end of a\n * transition effect.\n */\nexport const effectEndTarget = Symbol(\"effectEndTarget\");\n\n/**\n * Symbol for the `firstRender` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets the property to `true` during the\n * element's first `connectedCallback`, then `false` in subsequent callbacks.\n *\n * You can inspect this property in your own `connectedCallback` handler\n * to do work like wiring up events that should only happen once.\n */\nexport const firstRender = coreInternal.firstRender;\n\n/**\n * Symbol for the `focusTarget` property.\n *\n * [DelegatesFocusMixin](DelegatesFocusMixin) defines this property as either:\n * 1) the element itself, in browsers that support native focus delegation or,\n * 2) the shadow root's first focusable element.\n */\nexport const focusTarget = coreInternal.focusTarget;\n\n/**\n * Symbol for the `getItemText` method.\n *\n * This method can be applied to an item to return its text.\n * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin) uses this to\n * obtain the text for each item in a list, then matches keypresses again that\n * text.\n *\n * This method takes a single parameter: the `HTMLElement` of the item from\n * which text should be extracted.\n */\nexport const getItemText = Symbol(\"getItemText\");\n\n/**\n * Symbol for the `goDown` method.\n *\n * This method is invoked when the user wants to go/navigate down.\n */\nexport const goDown = Symbol(\"goDown\");\n\n/**\n * Symbol for the `goEnd` method.\n *\n * This method is invoked when the user wants to go/navigate to the end (e.g.,\n * of a list).\n */\nexport const goEnd = Symbol(\"goEnd\");\n\n/**\n * Symbol for the `goFirst` method.\n *\n * This method is invoked when the user wants to go to the first item in a list.\n */\nexport const goFirst = Symbol(\"goFirst\");\n\n/**\n * Symbol for the `goLast` method.\n *\n * This method is invoked when the user wants to go to the last item in a list.\n */\nexport const goLast = Symbol(\"goLast\");\n\n/**\n * Symbol for the `goLeft` method.\n *\n * This method is invoked when the user wants to go/navigate left. Mixins that\n * make use of this method include\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) and\n * [SwipeDirectionMixin](SwipeDirectionMixin).\n */\nexport const goLeft = Symbol(\"goLeft\");\n\n/**\n * Symbol for the `goNext` method.\n *\n * This method is invoked when the user wants to go/navigate to the next item.\n */\nexport const goNext = Symbol(\"goNext\");\n\n/**\n * Symbol for the `goPrevious` method.\n *\n * This method is invoked when the user wants to go/navigate to the previous item.\n */\nexport const goPrevious = Symbol(\"goPrevious\");\n\n/**\n * Symbol for the `goRight` method.\n *\n * This method is invoked when the user wants to go/navigate right. Mixins\n * that make use of this method include\n * [KeyboardDirectionMixin](KeyboardDirectionMixin) and\n * [SwipeDirectionMixin](SwipeDirectionMixin).\n */\nexport const goRight = Symbol(\"goRight\");\n\n/**\n * Symbol for the `goStart` method.\n *\n * This method is invoked when the user wants to go/navigate to the start\n * (e.g., of a list).\n */\nexport const goStart = Symbol(\"goStart\");\n\n/**\n * Symbol for the `goToItemWithPrefix` method.\n *\n * This method is invoked by\n * [KeyboardPrefixCursorMixin](KeyboardPrefixCursorMixin) when the user types\n * text characters.\n */\nexport const goToItemWithPrefix = Symbol(\"goToItemWithPrefix\");\n\n/**\n * Symbol for the `goUp` method.\n *\n * This method is invoked when the user wants to go/navigate up.\n */\nexport const goUp = Symbol(\"goUp\");\n\n/**\n * Symbol for the `hasDynamicTemplate` property.\n *\n * If your component class does not always use the same template, define a\n * static class property getter with this symbol and have it return `true`.\n * This will disable template caching for your component.\n */\nexport const hasDynamicTemplate = coreInternal.hasDynamicTemplate;\n\n/**\n * Symbol for the `ids` property.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) defines a shorthand function\n * `internal.ids` that can be used to obtain a reference to a shadow element with\n * a given ID.\n *\n * Example: if component's template contains a shadow element\n * `<button id=\"foo\">`, you can use the reference `this[ids].foo` to obtain\n * the corresponding button in the component instance's shadow tree.\n * The `ids` function is simply a shorthand for `getElementById`, so\n * `this[ids].foo` is the same as `this.shadowRoot.getElementById('foo')`.\n */\nexport const ids = coreInternal.ids;\n\n/**\n * Symbol for the `inputDelegate` property.\n *\n * [DelegateInputSelectionMixin](DelegateInputSelectionMixin) uses this property\n * to indicate which shadow element is the input-type element to which text\n * selection methods and properties should be delegated.\n */\nexport const inputDelegate = Symbol(\"inputDelegate\");\n\n/**\n * Symbol for the `itemsDelegate` property.\n *\n * A component using [DelegateItemsMixin](DelegateItemsMixin) uses this property\n * to indicate which one of its shadow elements is the one whose `items`\n * property will be treated as the component's own `items`.\n */\nexport const itemsDelegate = Symbol(\"itemsDelegate\");\n\n/**\n * Symbol for the `keydown` method.\n *\n * This method is invoked when an element receives a `keydown` event.\n *\n * An implementation of `internal.keydown` should return `true` if it handled\n * the event, and `false` otherwise. If `true` is returned (the event was\n * handled), `KeyboardMixin` invokes the event's `preventDefault` and\n * `stopPropagation` methods to let the browser know the event was handled.\n *\n * The convention for handling `internal.keydown` is that the last mixin\n * applied wins. That is, if an implementation of `internal.keydown` *did*\n * handle the event, it can return immediately. If it did not, it should\n * invoke `super` to let implementations further up the prototype chain have\n * their chance.\n *\n * This method takes a `KeyboardEvent` parameter that contains the event being\n * processed.\n */\nexport const keydown = Symbol(\"keydown\");\n\n/**\n * Symbol for the `matchText` method.\n *\n * [AutoCompleteInput](AutoCompleteInput) invokes this method when trying\n * to find a match for a given input string against its set of texts.\n */\nexport const matchText = Symbol(\"matchText\");\n\n/**\n * Symbol for the `mouseenter` method.\n *\n * [HoverMixin](HoverMixin) invokes this method when the user moves the\n * mouse over a component. That mixin provides a base implementation of this\n * method, but you can extend it to do additional work on `mouseenter`.\n *\n * This method takes a `MouseEvent` parameter that contains the event being\n * processed.\n */\nexport const mouseenter = Symbol(\"mouseenter\");\n\n/**\n * Symbol for the `mouseleave` method.\n *\n * [HoverMixin](HoverMixin) invokes this method when the user moves off a\n * component. That mixin provides a base implementation of this method, but\n * you can extend it to do additional work on `mouseleave`.\n *\n * This method takes a `MouseEvent` parameter that contains the event being\n * processed.\n */\nexport const mouseleave = Symbol(\"mouseleave\");\n\n/**\n * Symbol for access to native HTML element internals.\n */\nexport const nativeInternals = coreInternal.nativeInternals;\n\n/**\n * Symbol for the `raiseChangeEvents` property.\n *\n * This property is used by mixins to determine whether they should raise\n * property change events. The standard HTML pattern is to only raise such\n * events in response to direct user interactions. For a detailed discussion\n * of this point, see the Gold Standard checklist item for\n * [Propery Change Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n *\n * The above article describes a pattern for using a flag to track whether\n * work is being performed in response to internal component activity, and\n * whether the component should therefore raise property change events.\n * This `raiseChangeEvents` symbol is a shared flag used for that purpose by\n * all Elix mixins and components. Sharing this flag ensures that internal\n * activity (e.g., a UI event listener) in one mixin can signal other mixins\n * handling affected properties to raise change events.\n *\n * All UI event listeners (and other forms of internal handlers, such as\n * timeouts and async network handlers) should set `raiseChangeEvents` to\n * `true` at the start of the event handler, then `false` at the end:\n *\n *     this.addEventListener('click', event => {\n *       this[raiseChangeEvents] = true;\n *       // Do work here, possibly setting properties, like:\n *       this.foo = 'Hello';\n *       this[raiseChangeEvents] = false;\n *     });\n *\n * Elsewhere, property setters that raise change events should only do so it\n * this property is `true`:\n *\n *     set foo(value) {\n *       // Save foo value here, do any other work.\n *       if (this[raiseChangeEvents]) {\n *         export const event = new CustomEvent('foochange');\n *         this.dispatchEvent(event);\n *       }\n *     }\n *\n * In this way, programmatic attempts to set the `foo` property will not trigger\n * the `foochange` event, but UI interactions that update that property will\n * cause those events to be raised.\n */\nexport const raiseChangeEvents = coreInternal.raiseChangeEvents;\n\n/**\n * Symbol for the `render` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this `internal.render` method to give\n * the component a chance to render recent changes in component state.\n */\nexport const render = coreInternal.render;\n\n/**\n * Symbol for the `renderChanges` method.\n *\n * [ReactiveMixin](ReactiveMixin) invokes this method in response to a\n * `setState` call; you should generally not invoke this method yourself.\n */\nexport const renderChanges = coreInternal.renderChanges;\n\n/**\n * Symbol for the `renderDataToElement` method.\n *\n * [DataItemsMixin](DataItemsMixin) invokes this method to render data to an\n * element being used as an item in a list.\n */\nexport const renderDataToElement = Symbol(\"renderDataToElement\");\n\n/**\n * Symbol for the `rendered` method.\n *\n * [ReactiveMixin](ReactiveMixin) will invoke this method after your\n * element has completely finished rendering.\n */\nexport const rendered = coreInternal.rendered;\n\n/**\n * Symbol for the `rendering` property.\n *\n * [ReactiveMixin](ReactiveMixin) sets this property to true during rendering,\n * at other times it will be false.\n */\nexport const rendering = coreInternal.rendering;\n\n/**\n * Symbol for the `scrollTarget` property.\n *\n * This property indicates which element in a component's shadow subtree\n * should be scrolled. [CursorInViewMixin](CursorInViewMixin) can use\n * this property to determine which element should be scrolled to keep the\n * selected item in view.\n */\nexport const scrollTarget = Symbol(\"scrollTarget\");\n\n/**\n * Symbol for the `setState` method.\n *\n * A component using [ReactiveMixin](ReactiveMixin) can invoke this method to\n * apply changes to the element's current state.\n */\nexport const setState = coreInternal.setState;\n\n/**\n * Symbol for the `shadowRoot` property.\n *\n * This property holds a reference to an element's shadow root, like\n * `this.shadowRoot`. This propery exists because `this.shadowRoot` is not\n * available for components with closed shadow roots.\n * [ShadowTemplateMixin](ShadowTemplateMixin) creates open shadow roots by\n * default, but you can opt into creating closed shadow roots; see\n * [shadowRootMode](internal#internal.shadowRootMode).\n */\nexport const shadowRoot = coreInternal.shadowRoot;\n\n/**\n * Symbol for the `shadowRootMode` property.\n *\n * If true (the default), then [ShadowTemplateMixin](ShadowTemplateMixin) will\n * create an open shadow root when the component is instantiated. Set this to\n * false if you want to programmatically hide component internals in a closed\n * shadow root.\n */\nexport const shadowRootMode = coreInternal.shadowRootMode;\n\n/**\n * Symbol for the `startEffect` method.\n *\n * A component using [TransitionEffectMixin](TransitionEffectMixin) can invoke\n * this method to trigger the application of a named, asynchronous CSS\n * transition effect.\n *\n * This method takes a single `string` parameter giving the name of the effect\n * to start.\n */\nexport const startEffect = Symbol(\"startEffect\");\n\n/**\n * The element's current state.\n *\n * This is managed by [ReactiveMixin](ReactiveMixin).\n */\nexport const state = coreInternal.state;\n\nexport const stateEffects = coreInternal.stateEffects;\n\n/**\n * Symbol for the `swipeDown` method.\n *\n * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when\n * the user finishes a gesture to swipe down.\n */\nexport const swipeDown = Symbol(\"swipeDown\");\n\n/**\n * Symbol for the `swipeDownComplete` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe down has completed.\n */\nexport const swipeDownComplete = Symbol(\"swipeDownComplete\");\n\n/**\n * Symbol for the `swipeLeft` method.\n *\n * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user\n * finishes a gesture to swipe left.\n */\nexport const swipeLeft = Symbol(\"swipeLeft\");\n\n/**\n * Symbol for the `swipeLeftTransitionEnd` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe left has completed.\n */\nexport const swipeLeftTransitionEnd = Symbol(\"swipeLeftTransitionEnd\");\n\n/**\n * Symbol for the `swipeRight` method.\n *\n * The swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when the user\n * finishes a gesture to swipe right.\n */\nexport const swipeRight = Symbol(\"swipeRight\");\n\n/**\n * Symbol for the `swipeRightTransitionEnd` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe right has completed.\n */\nexport const swipeRightTransitionEnd = Symbol(\"swipeRightTransitionEnd\");\n\n/**\n * Symbol for the `swipeUp` method.\n *\n * The swipe mixin [TouchSwipeMixin](TouchSwipeMixin) invokes this method when\n * the user finishes a gesture to swipe up.\n */\nexport const swipeUp = Symbol(\"swipeUp\");\n\n/**\n * Symbol for the `swipeUpComplete` method.\n *\n * [SwipeCommandsMixin](SwipeCommandsMixin) invokes this method after any\n * animated transition associated with a swipe up has completed.\n */\nexport const swipeUpComplete = Symbol(\"swipeUpComplete\");\n\n/**\n * Symbol for the `swipeStart` method.\n *\n * [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) invoke this method when a swipe\n * is starting, passing in the starting (x, y) client coordinate.\n */\nexport const swipeStart = Symbol(\"swipeStart\");\n\n/**\n * Symbol for the `swipeTarget` property.\n *\n * By default, the swipe mixins [TouchSwipeMixin](TouchSwipeMixin) and\n * [TrackpadSwipeMixin](TrackpadSwipeMixin) assume that the element the user\n * is swiping the top-level element. In some cases (e.g., [Drawer](Drawer)),\n * the component wants to let the user swipe a shadow element. In such cases,\n * this property should return the element that should be swiped.\n *\n * The swipe target's `offsetWidth` is used by the mixin to calculate the\n * `state.swipeFraction` member when the user drags their finger. The\n * `swipeFraction` is the distance the user has dragged in the current drag\n * operation over that `offsetWidth`.\n */\nexport const swipeTarget = Symbol(\"swipeTarget\");\n\n/**\n * Symbol for the `tap` method.\n *\n * This method is invoked when an element receives an operation that should\n * be interpreted as a tap. [TapCursorMixin](TapCursorMixin)\n * invokes this when the element receives a `mousedown` event, for example.\n */\nexport const tap = Symbol(\"tap\");\n\n/**\n * Symbol for the `template` method.\n *\n * [ShadowTemplateMixin](ShadowTemplateMixin) uses this property to obtain a\n * component's template, which it will clone into a component's shadow root.\n */\nexport const template = coreInternal.template;\n\n/**\n * Symbol for the `toggleSelectedFlag` method.\n *\n * [ItemsMultiSelectMixin](ItemsMultiSelectMixin) exposes this method to let\n * other mixins like [MultiSelectAPIMixin](MultiSelectAPIMixin) toggle the\n * selected state of an individual item.\n */\nexport const toggleSelectedFlag = Symbol(\"toggleSelectedFlag\");\n\n// Expose internals as a global when debugging.\nconst elixdebug = new URLSearchParams(location.search).get(\"elixdebug\");\nif (elixdebug === \"true\") {\n  /** @type {any} */ (window).elix = {\n    internal: {\n      checkSize,\n      closestAvailableItemIndex,\n      contentSlot,\n      defaultState,\n      defaultTabIndex,\n      delegatesFocus,\n      effectEndTarget,\n      firstRender,\n      focusTarget,\n      getItemText,\n      goDown,\n      goEnd,\n      goFirst,\n      goLast,\n      goLeft,\n      goNext,\n      goPrevious,\n      goRight,\n      goStart,\n      goToItemWithPrefix,\n      goUp,\n      hasDynamicTemplate,\n      ids,\n      inputDelegate,\n      itemsDelegate,\n      keydown,\n      mouseenter,\n      mouseleave,\n      nativeInternals,\n      event,\n      raiseChangeEvents,\n      render,\n      renderChanges,\n      renderDataToElement,\n      rendered,\n      rendering,\n      scrollTarget,\n      setState,\n      shadowRoot,\n      shadowRootMode,\n      startEffect,\n      state,\n      stateEffects,\n      swipeDown,\n      swipeDownComplete,\n      swipeLeft,\n      swipeLeftTransitionEnd,\n      swipeRight,\n      swipeRightTransitionEnd,\n      swipeUp,\n      swipeUpComplete,\n      swipeStart,\n      swipeTarget,\n      tap,\n      template,\n      toggleSelectedFlag,\n    },\n  };\n}\n","/**\n * JavaScript template literals for constructing DOM nodes from HTML\n *\n * @module html\n */\n\n/**\n * A JavaScript template string literal that returns an HTML document fragment.\n *\n * Example:\n *\n *     const fragment = fragmentFrom.html`Hello, <em>world</em>.`\n *\n * returns a `DocumentFragment` whose `innerHTML` is `Hello, <em>world</em>.`\n *\n * This function is called `html` so that it can be easily used with HTML\n * syntax-highlighting extensions for various popular code editors.\n *\n * See also [templateFrom.html](template#html), which returns a similar result but\n * as an HTMLTemplateElement.\n *\n * @param {TemplateStringsArray} strings - the strings passed to the JavaScript template\n * literal\n * @param {string[]} substitutions - the variable values passed to the\n * JavaScript template literal\n * @returns {DocumentFragment}\n */\nexport const fragmentFrom = {\n  html(strings, ...substitutions) {\n    return templateFrom.html(strings, ...substitutions).content;\n  },\n};\n\n/**\n * A JavaScript template string literal that returns an HTML template.\n *\n * Example:\n *\n *     const myTemplate = templateFrom.html`Hello, <em>world</em>.`\n *\n * returns an `HTMLTemplateElement` whose `innerHTML` is `Hello, <em>world</em>.`\n *\n * This function is called `html` so that it can be easily used with HTML\n * syntax-highlighting extensions for various popular code editors.\n *\n * See also [html](html), a helper which returns a similar result but as an\n * DocumentFragment.\n *\n * @param {TemplateStringsArray} strings - the strings passed to the JavaScript template\n * literal\n * @param {string[]} substitutions - the variable values passed to the\n * JavaScript template literal\n * @returns {HTMLTemplateElement}\n */\nexport const templateFrom = {\n  html(strings, ...substitutions) {\n    const template = document.createElement(\"template\");\n    template.innerHTML = String.raw(strings, ...substitutions);\n    return template;\n  },\n};\n","import { focusTarget, nativeInternals } from \"./internal.js\";\n\n/**\n * Miscellaneous DOM helpers for web components\n *\n * @module dom\n */\n\nconst mousedownListenerKey = Symbol(\"mousedownListener\");\n\n/**\n * Given a string value for a named boolean attribute, return `true` if the\n * value is either: a) the empty string, or b) a case-insensitive match for the\n * name.\n *\n * This is native HTML behavior; see the MDN documentation on [boolean\n * attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes#Boolean_Attributes)\n * for the reasoning.\n *\n * Given a null value, this return `false`.\n * Given a boolean value, this return the value as is.\n *\n * @param {string} name\n * @param {string|boolean|null} value\n */\nexport function booleanAttributeValue(name, value) {\n  return typeof value === \"boolean\"\n    ? value\n    : typeof value === \"string\"\n    ? value === \"\" || name.toLowerCase() === value.toLowerCase()\n    : false;\n}\n\n/**\n * Return the closest focusable node that's either the node itself (if it's\n * focusable), or the closest focusable ancestor in the *composed* tree.\n *\n * If no focusable node is found, this returns null.\n *\n * @param {Node} node\n * @returns {HTMLElement|null}\n */\nexport function closestFocusableNode(node) {\n  for (const current of selfAndComposedAncestors(node)) {\n    // If the current element defines a focusTarget (e.g., via\n    // DelegateFocusMixin), use that, otherwise use the element itself.\n    const target = current[focusTarget] || current;\n    // We want an element that has a tabIndex of 0 or more. We ignore disabled\n    // elements, and slot elements (which oddly have a tabIndex of 0).\n    /** @type {any} */ const cast = target;\n    const focusable =\n      target instanceof HTMLElement &&\n      target.tabIndex >= 0 &&\n      !cast.disabled &&\n      !(target instanceof HTMLSlotElement);\n    if (focusable) {\n      return target;\n    }\n  }\n  return null;\n}\n\n/**\n * Return the ancestors of the given node in the composed tree.\n *\n * In the composed tree, the ancestor of a node assigned to a slot is that slot,\n * not the node's DOM ancestor. The ancestor of a shadow root is its host.\n *\n * @param {Node} node\n * @returns {Iterable<Node>}\n */\nexport function* composedAncestors(node) {\n  /** @type {Node|null} */\n  let current = node;\n  while (true) {\n    current =\n      current instanceof HTMLElement && current.assignedSlot\n        ? current.assignedSlot\n        : current instanceof ShadowRoot\n        ? current.host\n        : current.parentNode;\n    if (current) {\n      yield current;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Returns true if the first node contains the second, even if the second node\n * is in a shadow tree.\n *\n * The standard Node.contains() function does not account for Shadow DOM, and\n * returns false if the supplied target node is sitting inside a shadow tree\n * within the container.\n *\n * @param {Node} container - The container to search within.\n * @param {Node} target - The node that may be inside the container.\n * @returns {boolean} - True if the container contains the target node.\n */\nexport function deepContains(container, target) {\n  /** @type {any} */\n  let current = target;\n  while (current) {\n    const parent = current.assignedSlot || current.parentNode || current.host;\n    if (parent === container) {\n      return true;\n    }\n    current = parent;\n  }\n  return false;\n}\n\n/**\n * Return the first focusable element in the composed tree below the given root.\n * The composed tree includes nodes assigned to slots.\n *\n * This heuristic considers only the document order of the elements below the\n * root and whether a given element is focusable. It currently does not respect\n * the tab sort order defined by tabindex values greater than zero.\n *\n * @param {Node} root - the root of the tree in which to search\n * @returns {HTMLElement|null} - the first focusable element, or null if none\n * was found\n */\nexport function firstFocusableElement(root) {\n  // CSS selectors for focusable elements from\n  // https://stackoverflow.com/a/30753870/76472\n  const focusableQuery =\n    'a[href],area[href],button:not([disabled]),details,iframe,input:not([disabled]),select:not([disabled]),textarea:not([disabled]),[contentEditable=\"true\"],[tabindex]';\n  // Walk the tree looking for nodes that match the above selectors.\n  const walker = walkComposedTree(\n    root,\n    (/** @type {Node} */ node) =>\n      node instanceof HTMLElement &&\n      node.matches(focusableQuery) &&\n      node.tabIndex >= 0\n  );\n  // We only actually need the first matching value.\n  const { value } = walker.next();\n  // value, if defined, will always be an HTMLElement, but we do the following\n  // check to pass static type checking.\n  return value instanceof HTMLElement ? value : null;\n}\n\n/**\n * Trap any `mousedown` events on the `origin` element and prevent the default\n * behavior from setting the focus on that element. Instead, put the focus on\n * the `target` element (or, if the `target` is not focusable, on the target's\n * closest focusable ancestor).\n *\n * If this method is called again with the same `origin` element, the old\n * forwarding is overridden, and focus will now go to the new `target` element.\n *\n * If the `target` parameter is `null`, focus handling will be removed from the\n * indicated `origin`.\n *\n * @param {HTMLElement} origin\n * @param {HTMLElement|null} target\n */\nexport function forwardFocus(origin, target) {\n  if (origin[mousedownListenerKey]) {\n    // Origin was previously forwarding focus, probably to a different target.\n    // Remove the previous event listener.\n    origin.removeEventListener(\"mousedown\", origin[mousedownListenerKey]);\n  }\n  if (target) {\n    origin[mousedownListenerKey] = (/** @type {MouseEvent} */ event) => {\n      // Only process events for the main (usually left) button.\n      if (event.button !== 0) {\n        return;\n      }\n      // What element wants the focus?\n      const desiredTarget = target[focusTarget] || target;\n      // What ancestor can actually take the focus?\n      const focusableTarget = closestFocusableNode(desiredTarget);\n      if (focusableTarget) {\n        focusableTarget.focus();\n        event.preventDefault();\n      }\n    };\n    origin.addEventListener(\"mousedown\", origin[mousedownListenerKey]);\n  }\n}\n\n/**\n * Search a list element for the item that contains the specified target.\n *\n * When dealing with UI events (e.g., mouse clicks) that may occur in\n * subelements inside a list item, you can use this routine to obtain the\n * containing list item.\n *\n * @param {NodeList|Node[]} items - A list element containing a set of items\n * @param {Node} target - A target element that may or may not be an item in the\n * list.\n * @returns {number} - The index of the list child that is or contains the\n * indicated target node. Returns -1 if not found.\n */\nexport function indexOfItemContainingTarget(items, target) {\n  return Array.prototype.findIndex.call(\n    items,\n    (/** @type Node */ item) => item === target || deepContains(item, target)\n  );\n}\n\n/**\n * Return true if the event came from within the node (or from the node itself);\n * false otherwise.\n *\n * @param {Node} node - The node to consider in relation to the event\n * @param {Event} event - The event which may have been raised within/by the\n * node\n * @returns {boolean} - True if the event was raised within or by the node\n */\nexport function ownEvent(node, event) {\n  /** @type {any} */\n  const cast = event;\n  const eventSource = cast.composedPath()[0];\n  return node === eventSource || deepContains(node, eventSource);\n}\n\n/**\n * Returns the set that includes the given node and all of its ancestors in the\n * composed tree. See [composedAncestors](#composedAncestors) for details on the\n * latter.\n *\n * @param {Node} node\n * @returns {Iterable<Node>}\n */\nexport function* selfAndComposedAncestors(node) {\n  if (node) {\n    yield node;\n    yield* composedAncestors(node);\n  }\n}\n\n/**\n * Set an internal state for browsers that support the `:state` selector, as\n * well as an attribute of the same name to permit state-based styling on older\n * browsers.\n *\n * When all browsers support that, we'd like to deprecate use of attributes.\n *\n * @param {Element} element\n * @param {string} name\n * @param {boolean} value\n */\nexport function setInternalState(element, name, value) {\n  element.toggleAttribute(name, value);\n  if (element[nativeInternals] && element[nativeInternals].states) {\n    element[nativeInternals].states.toggle(name, value);\n  }\n}\n\n/** @type {IndexedObject<boolean>} */\nexport const standardBooleanAttributes = {\n  checked: true,\n  defer: true,\n  disabled: true,\n  hidden: true,\n  ismap: true,\n  multiple: true,\n  noresize: true,\n  readonly: true,\n  selected: true,\n};\n\n/**\n * Adds or removes the element's `childNodes` as necessary to match the nodes\n * indicated in the `childNodes` parameter.\n *\n * This operation is useful in cases where you maintain your own set of nodes\n * which should be rendered as the children of some element. When you insert or\n * remove nodes in that set, you can invoke this function to efficiently apply\n * the new set as a delta to the existing children. Only the items in the set\n * that have actually changed will be added or removed.\n *\n * @param {Element} element - the element to update\n * @param {(NodeList|Node[])} childNodes - the set of nodes to apply\n */\nexport function updateChildNodes(element, childNodes) {\n  // If the childNodes parameter is the actual childNodes of an element, then as\n  // we append those nodes to the indicated target element, they'll get removed\n  // from the original set. To keep the list stable, we make a copy.\n  const copy = [...childNodes];\n\n  const oldLength = element.childNodes.length;\n  const newLength = copy.length;\n  const length = Math.max(oldLength, newLength);\n  for (let i = 0; i < length; i++) {\n    const oldChild = element.childNodes[i];\n    const newChild = copy[i];\n    if (i >= oldLength) {\n      // Add new item not in old set.\n      element.append(newChild);\n    } else if (i >= newLength) {\n      // Remove old item past end of new set.\n      element.removeChild(element.childNodes[newLength]);\n    } else if (oldChild !== newChild) {\n      if (copy.indexOf(oldChild, i) >= i) {\n        // Old node comes later in final set. Insert the new node rather than\n        // replacing it so that we don't detach the old node only to have to\n        // reattach it later.\n        element.insertBefore(newChild, oldChild);\n      } else {\n        // Replace old item with new item.\n        element.replaceChild(newChild, oldChild);\n      }\n    }\n  }\n}\n\n/**\n * Walk the composed tree at the root for elements that pass the given filter.\n *\n * Note: the jsDoc types required for the filter function are too complex for\n * the current jsDoc parser to support strong type-checking.\n *\n * @private\n * @param {Node} node\n * @param {function} filter\n * @returns {IterableIterator<Node>}\n */\nfunction* walkComposedTree(node, filter) {\n  if (filter(node)) {\n    yield node;\n  }\n  let children;\n  if (node instanceof HTMLElement && node.shadowRoot) {\n    // Walk the shadow instead of the light DOM.\n    children = node.shadowRoot.children;\n  } else {\n    const assignedNodes =\n      node instanceof HTMLSlotElement\n        ? node.assignedNodes({ flatten: true })\n        : [];\n    children =\n      assignedNodes.length > 0\n        ? // Walk light DOM nodes assigned to this slot.\n          assignedNodes\n        : // Walk light DOM children.\n          node.childNodes;\n  }\n  if (children) {\n    for (let i = 0; i < children.length; i++) {\n      yield* walkComposedTree(children[i], filter);\n    }\n  }\n}\n","import { booleanAttributeValue, standardBooleanAttributes } from \"./dom.js\";\nimport { rendering } from \"./internal.js\";\n\n// Memoized maps of attribute to property names and vice versa.\n// We initialize this with the special case of the tabindex (lowercase \"i\")\n// attribute, which is mapped to the tabIndex (capital \"I\") property.\n/** @type {IndexedObject<string>} */\nconst attributeToPropertyNames = {\n  tabindex: \"tabIndex\",\n};\n/** @type {IndexedObject<string>} */\nconst propertyNamesToAttributes = {\n  tabIndex: \"tabindex\",\n};\n\n/**\n * Sets properties when the corresponding attributes change\n *\n * If your component exposes a setter for a property, it's generally a good\n * idea to let devs using your component be able to set that property in HTML\n * via an element attribute. You can code that yourself by writing an\n * `attributeChangedCallback`, or you can use this mixin to get a degree of\n * automatic support.\n *\n * This mixin implements an `attributeChangedCallback` that will attempt to\n * convert a change in an element attribute into a call to the corresponding\n * property setter. Attributes typically follow hyphenated names (\"foo-bar\"),\n * whereas properties typically use camelCase names (\"fooBar\"). This mixin\n * respects that convention, automatically mapping the hyphenated attribute\n * name to the corresponding camelCase property name.\n *\n * Example: You define a component using this mixin:\n *\n *     class MyElement extends AttributeMarshallingMixin(HTMLElement) {\n *       get fooBar() { return this._fooBar; }\n *       set fooBar(value) { this._fooBar = value; }\n *     }\n *\n * If someone then instantiates your component in HTML:\n *\n *     <my-element foo-bar=\"Hello\"></my-element>\n *\n * Then, after the element has been upgraded, the `fooBar` setter will\n * automatically be invoked with the initial value \"Hello\".\n *\n * Attributes can only have string values. If you'd like to convert string\n * attributes to other types (numbers, booleans), you must implement parsing\n * yourself.\n *\n * @module AttributeMarshallingMixin\n * @param {Constructor<CustomElement>} Base\n */\nexport default function AttributeMarshallingMixin(Base) {\n  // The class prototype added by the mixin.\n  class AttributeMarshalling extends Base {\n    /**\n     * Handle a change to the attribute with the given name.\n     *\n     * @ignore\n     * @param {string} attributeName\n     * @param {string} oldValue\n     * @param {string} newValue\n     */\n    attributeChangedCallback(attributeName, oldValue, newValue) {\n      if (super.attributeChangedCallback) {\n        super.attributeChangedCallback(attributeName, oldValue, newValue);\n      }\n\n      // Sometimes this callback is invoked when there's not actually any\n      // change, in which we skip invoking the property setter.\n      //\n      // We also skip setting properties if we're rendering. A component may\n      // want to reflect property values to attributes during rendering, but\n      // such attribute changes shouldn't trigger property updates.\n      if (newValue !== oldValue && !this[rendering]) {\n        const propertyName = attributeToPropertyName(attributeName);\n        // If the attribute name corresponds to a property name, set the property.\n        if (propertyName in this) {\n          // Parse standard boolean attributes.\n          const parsed = standardBooleanAttributes[attributeName]\n            ? booleanAttributeValue(attributeName, newValue)\n            : newValue;\n          this[propertyName] = parsed;\n        }\n      }\n    }\n\n    // Because maintaining the mapping of attributes to properties is tedious,\n    // this provides a default implementation for `observedAttributes` that\n    // assumes that your component will want to expose all public properties in\n    // your component's API as properties.\n    //\n    // You can override this default implementation of `observedAttributes`. For\n    // example, if you have a system that can statically analyze which\n    // properties are available to your component, you could hand-author or\n    // programmatically generate a definition for `observedAttributes` that\n    // avoids the minor run-time performance cost of inspecting the component\n    // prototype to determine your component's public properties.\n    static get observedAttributes() {\n      return attributesForClass(this);\n    }\n  }\n\n  return AttributeMarshalling;\n}\n\n/**\n * Return the custom attributes for the given class.\n *\n * E.g., if the supplied class defines a `fooBar` property, then the resulting\n * array of attribute names will include the \"foo-bar\" attribute.\n *\n * @private\n * @param {Constructor<HTMLElement>} classFn\n * @returns {string[]}\n */\nfunction attributesForClass(classFn) {\n  // We treat the HTMLElement base class as if it has no attributes, since we\n  // don't want to receive attributeChangedCallback for it (or anything further\n  // up the protoype chain).\n  if (classFn === HTMLElement) {\n    return [];\n  }\n\n  // Get attributes for parent class.\n  const baseClass = Object.getPrototypeOf(classFn.prototype).constructor;\n\n  // See if parent class defines observedAttributes manually.\n  let baseAttributes = baseClass.observedAttributes;\n  if (!baseAttributes) {\n    // Calculate parent class attributes ourselves.\n    baseAttributes = attributesForClass(baseClass);\n  }\n\n  // Get the properties for this particular class.\n  const propertyNames = Object.getOwnPropertyNames(classFn.prototype);\n  const setterNames = propertyNames.filter((propertyName) => {\n    const descriptor = Object.getOwnPropertyDescriptor(\n      classFn.prototype,\n      propertyName\n    );\n    return descriptor && typeof descriptor.set === \"function\";\n  });\n\n  // Map the property names to attribute names.\n  const attributes = setterNames.map((setterName) =>\n    propertyNameToAttribute(setterName)\n  );\n\n  // Merge the attribute for this class and its base class.\n  const diff = attributes.filter(\n    (attribute) => baseAttributes.indexOf(attribute) < 0\n  );\n  const result = baseAttributes.concat(diff);\n\n  return result;\n}\n\n/**\n * Convert hyphenated foo-bar attribute name to camel case fooBar property name.\n *\n * @private\n * @param {string} attributeName\n */\nfunction attributeToPropertyName(attributeName) {\n  let propertyName = attributeToPropertyNames[attributeName];\n  if (!propertyName) {\n    // Convert and memoize.\n    const hyphenRegEx = /-([a-z])/g;\n    propertyName = attributeName.replace(hyphenRegEx, (match) =>\n      match[1].toUpperCase()\n    );\n    attributeToPropertyNames[attributeName] = propertyName;\n  }\n  return propertyName;\n}\n\n/**\n * Convert a camel case fooBar property name to a hyphenated foo-bar attribute.\n *\n * @private\n * @param {string} propertyName\n */\nfunction propertyNameToAttribute(propertyName) {\n  let attribute = propertyNamesToAttributes[propertyName];\n  if (!attribute) {\n    // Convert and memoize.\n    const uppercaseRegEx = /([A-Z])/g;\n    attribute = propertyName.replace(uppercaseRegEx, \"-$1\").toLowerCase();\n    propertyNamesToAttributes[propertyName] = attribute;\n  }\n  return attribute;\n}\n","import {\n  defaultState,\n  firstRender,\n  raiseChangeEvents,\n  render,\n  renderChanges,\n  rendered,\n  rendering,\n  setState,\n  state,\n  stateEffects,\n} from \"./internal.js\";\n\n/** @type {any} */\nconst stateKey = Symbol(\"state\");\n/** @type {any} */\nconst raiseChangeEventsInNextRenderKey = Symbol(\n  \"raiseChangeEventsInNextRender\"\n);\n// Tracks total set of changes made to elements since their last render.\n/** @type {any} */\nconst changedSinceLastRenderKey = Symbol(\"changedSinceLastRender\");\n\n/**\n * Manages component state and renders changes in state\n *\n * This is modeled after React/Preact's state management, and is adapted for\n * use with web components. Applying this mixin to a component will give it\n * FRP behavior comparable to React's.\n *\n * This model is very basic. It's key aspects are:\n * * an immutable `state` property updated via `setState` calls.\n * * a `render` method that will be invoked asynchronously when state changes.\n *\n * @module ReactiveMixin\n * @param {Constructor<CustomElement>} Base\n */\nexport default function ReactiveMixin(Base) {\n  class Reactive extends Base {\n    constructor() {\n      super();\n\n      // Components can inspect `firstRender` during rendering to do special\n      // work the first time (like wire up event handlers). Until the first\n      // render actually happens, we set that flag to be undefined so we have a\n      // way of distinguishing between a component that has never rendered and\n      // one that is being rendered for the nth time.\n      this[firstRender] = undefined;\n\n      // We want to support the standard HTML pattern of only raising events in\n      // response to direct user interactions. For a detailed discussion of this\n      // point, see the Gold Standard checklist item for [Propery Change\n      // Events](https://github.com/webcomponents/gold-standard/wiki/Property%20Change%20Events).\n      //\n      // To support this pattern, we define a flag indicating whether change\n      // events should be raised. By default, we want the flag to be false. In\n      // UI event handlers, a component can temporarily set the flag to true. If\n      // a setState call is made while the flag is true, then that fact will be\n      // remembered and passed the subsequent render/rendered methods. That will\n      // let the methods know whether they should raise property change events.\n      this[raiseChangeEvents] = false;\n\n      // Maintain a change log of all fields which have changed since the\n      // component was last rendered.\n      this[changedSinceLastRenderKey] = null;\n\n      // Set the initial state from the default state defined by the component\n      // and its mixins/base classes.\n      this[setState](this[defaultState]);\n    }\n\n    // When the component is attached to the document (or upgraded), we will\n    // generally render the component for the first time. That operation will\n    // include rendering of the default state and any state changes that\n    // happened between constructor time and this connectedCallback.\n    connectedCallback() {\n      if (super.connectedCallback) {\n        super.connectedCallback();\n      }\n\n      // Render the component.\n      //\n      // If the component was forced to render before this point, and the state\n      // hasn't changed, this call will be a no-op.\n      this[renderChanges]();\n    }\n\n    /**\n     * The default state for the component. This can be extended by mixins and\n     * classes to provide additional default state.\n     *\n     * @type {PlainObject}\n     */\n    // @ts-ignore\n    get [defaultState]() {\n      // Defer to base implementation if defined.\n      return super[defaultState] || {};\n    }\n\n    /**\n     * Render the indicated changes in state to the DOM.\n     *\n     * The default implementation of this method does nothing. Override this\n     * method in your component to update your component's host element and\n     * any shadow elements to reflect the component's new state. See the\n     * [rendering example](ReactiveMixin#rendering).\n     *\n     * Be sure to call `super` in your method implementation so that your\n     * component's base classes and mixins have a chance to perform their own\n     * render work.\n     *\n     * @param {ChangedFlags} changed - dictionary of flags indicating which state\n     * members have changed since the last render\n     */\n    [render](changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n    }\n\n    /**\n     * Render any pending component changes to the DOM.\n     *\n     * This method does nothing if the state has not changed since the last\n     * render call.\n     *\n     * ReactiveMixin will invoke this method following a `setState` call;\n     * you should not need to invoke this method yourself.\n     *\n     * This method invokes the internal `render` method, then invokes the\n     * `rendered` method.\n     */\n    [renderChanges]() {\n      if (this[firstRender] === undefined) {\n        // First render.\n        this[firstRender] = true;\n      }\n\n      // Get the log of which fields have changed since the last render.\n      const changed = this[changedSinceLastRenderKey];\n\n      // We only render if this is the first render, or state has changed since\n      // the last render.\n      if (this[firstRender] || changed) {\n        // If at least one of the[setState] calls was made in response\n        // to user interaction or some other component-internal event, set the\n        // raiseChangeEvents flag so that render/rendered methods know whether\n        // to raise property change events. See the comments in the component\n        // constructor where we initialize this flag for details.\n        const saveRaiseChangeEvents = this[raiseChangeEvents];\n        this[raiseChangeEvents] = this[raiseChangeEventsInNextRenderKey];\n\n        // We set a flag to indicate that rendering is happening. The component\n        // may use this to avoid triggering other updates during the render.\n        this[rendering] = true;\n\n        // Invoke any internal render implementations.\n        this[render](changed);\n\n        this[rendering] = false;\n\n        // Since we've now rendered all changes, clear the change log. If other\n        // async render calls are queued up behind this call, they'll see an\n        // empty change log, and so skip unnecessary render work.\n        this[changedSinceLastRenderKey] = null;\n\n        // Let the component know it was rendered.\n        this[rendered](changed);\n\n        // We've now rendered for the first time.\n        this[firstRender] = false;\n\n        // Restore state of event flags.\n        this[raiseChangeEvents] = saveRaiseChangeEvents;\n        this[raiseChangeEventsInNextRenderKey] = saveRaiseChangeEvents;\n      }\n    }\n\n    /**\n     * Perform any work that must happen after state changes have been rendered\n     * to the DOM.\n     *\n     * The default implementation of this method does nothing. Override this\n     * method in your component to perform work that requires the component to\n     * be fully rendered, such as setting focus on a shadow element or\n     * inspecting the computed style of an element. If such work should result\n     * in a change in component state, you can safely call `setState` during the\n     * `rendered` method.\n     *\n     * Be sure to call `super` in your method implementation so that your\n     * component's base classes and mixins have a chance to perform their own\n     * post-render work.\n     *\n     * @param {ChangedFlags} changed\n     */\n    [rendered](changed) {\n      if (super[rendered]) {\n        super[rendered](changed);\n      }\n    }\n\n    /**\n     * Update the component's state by merging the specified changes on\n     * top of the existing state. If the component is connected to the document,\n     * and the new state has changed, this returns a promise to asynchronously\n     * render the component. Otherwise, this returns a resolved promise.\n     *\n     * @param {PlainObject} changes - the changes to apply to the element's state\n     * @returns {Promise} - resolves when the new state has been rendered\n     */\n    async [setState](changes) {\n      // There's no good reason to have a render method update state.\n      if (this[rendering]) {\n        /* eslint-disable no-console */\n        console.warn(\n          `${this.constructor.name} called [setState] during rendering, which you should avoid.\\nSee https://elix.org/documentation/ReactiveMixin.`\n        );\n      }\n\n      // Apply the changes to a copy of the component's current state to produce\n      // a new, updated state and a dictionary of flags indicating which fields\n      // actually changed.\n      const { state, changed } = copyStateWithChanges(this, changes);\n\n      // We only need to apply the changes to the component state if: a) the\n      // current state is undefined (this is the first time setState has been\n      // called), or b) the supplied changes parameter actually contains\n      // substantive changes.\n      if (this[stateKey] && Object.keys(changed).length === 0) {\n        // No need to update state.\n        return;\n      }\n\n      // Freeze the new state so it's immutable. This prevents accidental\n      // attempts to set state without going through setState.\n      Object.freeze(state);\n\n      // Set this as the component's new state.\n      this[stateKey] = state;\n\n      // If setState was called with the raiseChangeEvents flag set, record that\n      // fact for use in rendering. See the comments in the component\n      // constructor for details.\n      if (this[raiseChangeEvents]) {\n        this[raiseChangeEventsInNextRenderKey] = true;\n      }\n\n      // Look to see whether the component is already set up to render.\n      const willRender =\n        this[firstRender] === undefined ||\n        this[changedSinceLastRenderKey] !== null;\n\n      // Add this round of changed fields to the complete log of fields that\n      // have changed since the component was last rendered.\n      this[changedSinceLastRenderKey] = Object.assign(\n        this[changedSinceLastRenderKey] || {},\n        changed\n      );\n\n      // We only need to queue a render if we're in the document and a render\n      // operation hasn't already been queued for this component. If we're not\n      // in the document yet, when the component is eventually added to the\n      // document, the connectedCallback will ensure we render at that point.\n      const needsRender = this.isConnected && !willRender;\n      if (needsRender) {\n        // Yield with promise timing. This lets any *synchronous* setState calls\n        // that happen after this current setState call complete first. Their\n        // effects on the state will be batched up, and accumulate in the change\n        // log stored under this[changedSinceLastRenderKey].\n        await Promise.resolve();\n\n        // Now that the above promise has resolved, render the component. By the\n        // time this line is reached, the complete log of batched changes can be\n        // applied in a single render call.\n        this[renderChanges]();\n      }\n    }\n\n    /**\n     * The component's current state.\n     *\n     * The returned state object is immutable. To update it, invoke\n     * `internal.setState`.\n     *\n     * It's extremely useful to be able to inspect component state while\n     * debugging. If you append `?elixdebug=true` to a page's URL, then\n     * ReactiveMixin will conditionally expose a public `state` property that\n     * returns the component's state. You can then access the state in your\n     * browser's debug console.\n     *\n     * @type {PlainObject}\n     */\n    get [state]() {\n      return this[stateKey];\n    }\n\n    /**\n     * Ask the component whether a state with a set of recently-changed fields\n     * implies that additional second-order changes should be applied to that\n     * state to make it consistent.\n     *\n     * This method is invoked during a call to `internal.setState` to give all\n     * of a component's mixins and classes a chance to respond to changes in\n     * state. If one mixin/class updates state that it controls, another\n     * mixin/class may want to respond by updating some other state member that\n     * *it* controls.\n     *\n     * This method should return a dictionary of changes that should be applied\n     * to the state. If the dictionary object is not empty, the\n     * `internal.setState` method will apply the changes to the state, and\n     * invoke this `stateEffects` method again to determine whether there are\n     * any third-order effects that should be applied. This process repeats\n     * until all mixins/classes report that they have no additional changes to\n     * make.\n     *\n     * See an example of how `ReactiveMixin` invokes the `stateEffects` to\n     * [ensure state consistency](ReactiveMixin#ensuring-state-consistency).\n     *\n     * @param {PlainObject} state - a proposal for a new state\n     * @param {ChangedFlags} changed - the set of fields changed in this\n     * latest proposal for the new state\n     * @returns {PlainObject}\n     */\n    [stateEffects](state, changed) {\n      return super[stateEffects] ? super[stateEffects](state, changed) : {};\n    }\n  }\n\n  // Expose state when debugging; see note for `[state]` getter.\n  const elixdebug = new URLSearchParams(location.search).get(\"elixdebug\");\n  if (elixdebug === \"true\") {\n    Object.defineProperty(Reactive.prototype, \"state\", {\n      get() {\n        return this[state];\n      },\n    });\n  }\n\n  return Reactive;\n}\n\n/**\n * Create a copy of the component's state with the indicated changes applied.\n * Ask the component whether the new state implies any second-order effects. If\n * so, apply those and loop again until the state has stabilized. Return the new\n * state and a dictionary of flags indicating which fields were actually\n * changed.\n *\n * @private\n * @param {Element} element\n * @param {PlainObject} changes\n */\nexport function copyStateWithChanges(element, changes) {\n  // Start with a copy of the current state.\n  /** @type {PlainObject} */\n  const state = Object.assign({}, element[stateKey]);\n  /** @type {ChangedFlags} */\n  const changed = {};\n  // Take the supplied changes as the first round of effects.\n  let effects = changes;\n  // Loop until there are no effects to apply.\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    // See whether the effects actually changed anything in state.\n    const changedByEffects = fieldsChanged(state, effects);\n    if (Object.keys(changedByEffects).length === 0) {\n      // No more effects to apply; we're done.\n      break;\n    }\n    // Apply the effects.\n    Object.assign(state, effects);\n    Object.assign(changed, changedByEffects);\n    // Ask the component if there are any second- (or third-, etc.) order\n    // effects that should be applied.\n    effects = element[stateEffects](state, changedByEffects);\n  }\n  return { state, changed };\n}\n\n/**\n * Return true if the two values are equal.\n *\n * @private\n * @param {any} value1\n * @param {any} value2\n * @returns {boolean}\n */\nfunction equal(value1, value2) {\n  if (value1 instanceof Date && value2 instanceof Date) {\n    return value1.getTime() === value2.getTime();\n  }\n  return value1 === value2;\n}\n\n/**\n * Return a dictionary of flags indicating which of the indicated changes to the\n * state are actually substantive changes.\n *\n * @private\n * @param {PlainObject} state\n * @param {PlainObject} changes\n */\nfunction fieldsChanged(state, changes) {\n  /** @type {ChangedFlags} */\n  const changed = {};\n  for (const field in changes) {\n    if (!equal(changes[field], state[field])) {\n      changed[field] = true;\n    }\n  }\n  return changed;\n}\n","import {\n  delegatesFocus,\n  hasDynamicTemplate,\n  ids,\n  render,\n  shadowRoot,\n  shadowRootMode,\n  template,\n} from \"./internal.js\";\n\n// A cache of processed templates, indexed by element class.\nconst classTemplateMap = new Map();\n\n// A Proxy that maps shadow element IDs to shadow elements.\n// This will be return as the element's `this[ids]` property;\n// see comments in that property below.\n/** @type {any} */\nconst shadowIdProxyKey = Symbol(\"shadowIdProxy\");\n\n// A reference stored on the shadow element proxy target to get to the actual\n// element. We use a Symbol here instead of a string name to avoid naming\n// conflicts with the element's internal shadow element IDs.\nconst proxyElementKey = Symbol(\"proxyElement\");\n\n// A handler used for the shadow element ID proxy.\nconst shadowIdProxyHandler = {\n  get(target, id) {\n    // From this proxy, obtain a reference to the original component.\n    const element = target[proxyElementKey];\n\n    // Get a reference to the component's open or closed shadow root.\n    const root = element[shadowRoot];\n\n    // Look for a shadow element with the indicated ID.\n    return root && typeof id === \"string\" ? root.getElementById(id) : null;\n  },\n};\n\n/**\n * Stamps a template into a component's Shadow DOM when instantiated\n *\n * To use this mixin, define a `template` method that returns a string or HTML\n * `<template>` element:\n *\n *     import { createElement, replace, transmute } from 'elix/src/template.js';\n *\n *     class MyElement extends ShadowTemplateMixin(HTMLElement) {\n *       get [template]() {\n *         return templateFrom.html`Hello, <em>world</em>.`;\n *       }\n *     }\n *\n * When your component class is instantiated, a shadow root will be created on\n * the instance, and the contents of the template will be cloned into the\n * shadow root. If your component does not define a `template` method, this\n * mixin has no effect.\n *\n * This adds a member on the component called `this[ids]` that can be used to\n * reference shadow elements with IDs. E.g., if component's shadow contains an\n * element `<button id=\"foo\">`, then this mixin will create a member\n * `this[ids].foo` that points to that button.\n *\n * @module ShadowTemplateMixin\n * @param {Constructor<HTMLElement>} Base\n */\nexport default function ShadowTemplateMixin(Base) {\n  // The class prototype added by the mixin.\n  class ShadowTemplate extends Base {\n    /**\n     * A convenient shortcut for looking up an element by ID in the component's\n     * Shadow DOM subtree.\n     *\n     * Example: if component's template contains a shadow element `<button\n     * id=\"foo\">`, you can use the reference `this[ids].foo` to obtain\n     * the corresponding button in the component instance's shadow tree. The\n     * `ids` property is simply a shorthand for `getElementById`, so\n     * `this[ids].foo` is the same as\n     * `this[shadowRoot].getElementById('foo')`.\n     *\n     * @type {object} - a dictionary mapping shadow element IDs to elements\n     */\n    get [ids]() {\n      if (!this[shadowIdProxyKey]) {\n        // Construct a proxy that maps to getElementById.\n        const target = {\n          // Give the proxy a means of refering to this element via the target.\n          [proxyElementKey]: this,\n        };\n        this[shadowIdProxyKey] = new Proxy(target, shadowIdProxyHandler);\n      }\n      return this[shadowIdProxyKey];\n    }\n\n    /*\n     * If the component defines a template, a shadow root will be created on the\n     * component instance, and the template stamped into it.\n     */\n    [render](/** @type {ChangedFlags} */ changed) {\n      if (super[render]) {\n        super[render](changed);\n      }\n\n      // We populate the shadow root if the component doesn't have a shadow;\n      // i.e., the first time the component is rendered. For this check, we use\n      // an internal reference we maintain for the shadow root; see below.\n      if (!this[shadowRoot]) {\n        // If this type of element defines a template, prepare it for use.\n        const template = getTemplate(this);\n\n        if (template) {\n          // Stamp the template into a new shadow root.\n          const root = this.attachShadow({\n            delegatesFocus: this[delegatesFocus],\n            mode: this[shadowRootMode],\n          });\n          const clone = document.importNode(template.content, true);\n          root.append(clone);\n\n          // After this call, we won't be able to rely on being able to access\n          // the shadow root via `this.shadowRoot`, because the component may\n          // have asked for a closed shadow root. We save a reference to the\n          // shadow root now so that the component always has a consistent means\n          // to reference its own shadow root.\n          this[shadowRoot] = root;\n        } else {\n          // No template. Set shadow root to null (instead of undefined) so we\n          // won't try to render shadow on next render.\n          this[shadowRoot] = null;\n        }\n      }\n    }\n\n    /**\n     * @type {ShadowRootMode}\n     * @default \"open\"\n     */\n    get [shadowRootMode]() {\n      return \"open\";\n    }\n  }\n\n  return ShadowTemplate;\n}\n\n/**\n * Return the template for the element being instantiated.\n *\n * If this is the first time we're creating this type of element, or the\n * component has indicated that its template is dynamic (and should be retrieved\n * each time), ask the component class for the template and cache the result.\n * Otherwise, immediately return the cached template.\n *\n * @private\n * @param {HTMLElement} element\n * @returns {HTMLTemplateElement}\n */\nfunction getTemplate(element) {\n  let t = element[hasDynamicTemplate]\n    ? undefined // Always retrieve template\n    : classTemplateMap.get(element.constructor); // See if we've cached it\n  if (t === undefined) {\n    // Ask the component for its template.\n    t = element[template];\n    // A component using this mixin isn't required to supply a template --\n    // if they don't, they simply won't end up with a shadow root.\n    if (t) {\n      // But if the component does supply a template, it needs to be an\n      // HTMLTemplateElement instance.\n      if (!(t instanceof HTMLTemplateElement)) {\n        throw `Warning: the [template] property for ${element.constructor.name} must return an HTMLTemplateElement.`;\n      }\n    }\n    if (!element[hasDynamicTemplate]) {\n      // Store prepared template for next creation of same type of element.\n      // If the component didn't define a template, store null so that we skip\n      // the template retrieval next time.\n      classTemplateMap.set(element.constructor, t || null);\n    }\n  }\n  return t;\n}\n","import AttributeMarshallingMixin from \"./AttributeMarshallingMixin.js\";\nimport ReactiveMixin from \"./ReactiveMixin.js\";\nimport ShadowTemplateMixin from \"./ShadowTemplateMixin.js\";\n\n/**\n * General-purpose base for writing components in functional-reactive style\n *\n * This base class lets you create web components in a functional-reactive\n * programming (FRP) style. It simply bundles a small set of mixins:\n *\n *     const ReactiveElement =\n *       AttributeMarshallingMixin(\n *       ReactiveMixin(\n *       ShadowTemplateMixin(\n *         HTMLElement\n *       )))));\n *\n * `ReactiveElement` is provided as a convenience. You can achieve the same\n * result by applying the mixins yourself to `HTMLElement`.\n *\n * @inherits HTMLElement\n * @mixes AttributeMarshallingMixin\n * @mixes ReactiveMixin\n * @mixes ShadowTemplateMixin\n */\nconst ReactiveElement = AttributeMarshallingMixin(\n  ReactiveMixin(ShadowTemplateMixin(HTMLElement))\n);\n\nexport default ReactiveElement;\n","import {\n  defaultState,\n  ids,\n  render,\n  setState,\n  state,\n  template,\n  raiseChangeEvents\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\nimport * as utils from '../lib/utils';\n\nexport default class WorkletColor extends ReactiveElement {\n\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      prop: null,\n      value: null\n    });\n  }\n\n  get prop() {\n    return this[state].prop;\n  }\n  set prop(prop) {\n    this[setState]({\n      prop: prop,\n    });\n  }\n\n  get value() {\n    return this[state].value;\n  }\n  set value(value) {\n    this[setState]({\n      value: value,\n    });\n  }\n\n  [render](changed) {\n    super[render](changed);\n    if (changed.prop && changed.value) {\n      const pickerEl = this[ids].picker;\n      const colorEl = this[ids].color;\n      const nameEl = this[ids].name;\n      const valueEl = this[ids].value;\n      pickerEl.setAttribute('value', this[state].value);\n      pickerEl.setAttribute('name', this[state].prop);\n      // nameEl.textContent = this[state].prop.replace(/(--sds-g-color-)(\\w+-)/g,'');\n      nameEl.textContent = this[state].prop;\n      valueEl.textContent = this[state].value;\n\n      // Set color styles\n      colorEl.style.setProperty('background-color', this[state].value);\n      this._checkContrast(colorEl, this[state].value);\n\n      // Update based on color picker\n      pickerEl.addEventListener(\"change\", (e) => {\n        const nameProp = pickerEl.getAttribute('name');\n        this[raiseChangeEvents] = true;\n        this[setState]({\n          value: e.target.value,\n        });\n        this[raiseChangeEvents] = false;\n        document.documentElement.style.setProperty(nameProp, e.target.value);\n        colorEl.style.setProperty('background-color', e.target.value);\n        valueEl.textContent = e.target.value;\n        this._checkContrast(colorEl, e.target.value);\n      });\n      pickerEl.select();\n    }\n  }\n\n  _checkContrast(el, value) {\n    if (utils.getContrast(value) === 'black') {\n      el.style.setProperty('color', 'rgba(0,0,0,0.8)');\n    } else {\n      el.style.setProperty('color', 'rgba(255,255,255,0.8)');\n    }\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <div>\n        <label id=\"prop\">\n          <input type=\"color\" id=\"picker\" name=\"\" value=\"#fff\">\n        </label>\n        <div id=\"color\">\n          <p id=\"name\"></p>\n          <p id=\"value\"></p>\n        </div>\n      </div>\n      <style>\n        div {\n          display: flex;\n          flex-direction: column;\n          position: relative;\n        }\n        div:hover #color {\n          transform: scale(1.05);\n          box-shadow: 0 8px 24px rgba(53,71,90,.2);\n          z-index: 1;\n          border-radius: 4px;\n          background-clip: border-box;\n        }\n        div:hover #prop,\n        div:hover #name {\n          visibility: visible;\n          opacity: 1;\n        }\n        div:hover #name {\n          transform: translate3d(-50%,-110%,0);\n        }\n        div:hover #value {\n          transform: translateY(-10px);\n        }\n        #color {\n          display: flex;\n          height: var(--columnSize);\n          width: var(--columnSize);\n          justify-content: center;\n          align-content: center;\n          align-items: center;\n          transition: transform .2s cubic-bezier(0.23, 1, 0.32, 1), box-shadow .2s cubic-bezier(0.23, 1, 0.32, 1);\n        }\n        #prop {\n          position: absolute;\n          bottom: 1rem;\n          left: 50%;\n          transform: translateX(-50%);\n          z-index: 2;\n          transition: visibility .2s ease, opacity .2s ease;\n          visibility: hidden;\n          opacity: 0;\n        }\n        #name {\n          margin: 0;\n          font-size: 0.75rem;\n          position: absolute;\n          top: 0;\n          left: 50%;\n          transform: translate3d(-50%,-80%,0);\n          background: var(--sds-g-color-neutral-base-1);\n          color: var(--sds-g-color-neutral-base-contrast-3);\n          padding: 2px 6px;\n          border-radius: 3px;\n          box-shadow: 0 3px 12px rgba(53,71,90,.2);\n          visibility: hidden;\n          white-space: nowrap;\n          opacity: 0;\n          transition: visibility .2s ease, opacity .2s ease, transform .35s cubic-bezier(0.23, 1, 0.32, 1);\n        }\n        #name:before {\n          width: 0.5rem;\n          height: 0.5rem;\n          position: absolute;\n          transform: rotate(45deg);\n          content: \"\";\n          background-color: var(--sds-g-color-neutral-base-1);\n          z-index: -1;\n          bottom: -0.25rem;\n          left: 50%;\n          margin-left: -0.25rem;\n        }\n        #value {\n          font-size: 0.875rem;\n          font-weight: bold;\n          -webkit-font-smoothing: antialiased;\n          -moz-osx-font-smoothing: grayscale;\n          transition: transform .25s cubic-bezier(0.23, 1, 0.32, 1);\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define('worklet-color', WorkletColor);","const getContrast = (c) => {\n  c = c.replace(\"#\", \"\");\n  var r = parseInt(c.substr(0, 2), 16);\n  var g = parseInt(c.substr(2, 2), 16);\n  var b = parseInt(c.substr(4, 2), 16);\n  var yiq = (r * 299 + g * 587 + b * 114) / 1000;\n  return yiq >= 128 ? \"black\" : \"white\";\n};\n\nconst rgbToHex = (a) => {\n  a = a.replace(/[^\\d,]/g, \"\").split(\",\");\n  return (\n    \"#\" +\n    ((1 << 24) + (+a[0] << 16) + (+a[1] << 8) + +a[2]).toString(16).slice(1)\n  );\n};\n\nexport { getContrast, rgbToHex };\n","import {\n  defaultState,\n  ids,\n  render,\n  state,\n  template,\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\nimport * as utils from \"../lib/utils\";\n\nexport default class WorkletColors extends ReactiveElement {\n  constructor() {\n    super();\n    this._getProps();\n  }\n\n  _getProps() {\n    const targetNode = document.documentElement.computedStyleMap();\n    targetNode.forEach((el, prop, arr) => {\n      const value = getComputedStyle(document.documentElement).getPropertyValue(\n        prop\n      );\n      this[state].props.push({ prop, value: utils.rgbToHex(value) });\n    });\n  }\n\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      props: [],\n      hooks: null,\n    });\n  }\n\n  [render](changed) {\n    super[render](changed);\n    if (changed.props) {\n      const { props } = this[state];\n      const results = this[ids].results;\n      const hooks = props.filter((props) => /(^--.+)/.test(props.prop));\n      for (let hook of hooks) {\n        results.insertAdjacentHTML(\n          \"afterbegin\",\n          `<worklet-color prop=${hook.prop} value=${hook.value}></worklet-color>`\n        );\n      }\n    }\n  }\n  get [template]() {\n    return templateFrom.html`\n      <div id=\"results\"></div>\n      <style>\n        div {\n          display: grid;\n          grid-template-columns: repeat(8, minmax(100px, 150px));\n          margin: 1rem 0;\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"worklet-colors\", WorkletColors);\n","import {\n  defaultState,\n  ids,\n  render,\n  setState,\n  state,\n  template\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletCss extends ReactiveElement {\n  constructor() {\n    super();\n    this._getProps(props => {\n      this[setState]({\n        css: props.replace(/(;)/g, ';\\n')\n      })\n    });\n  }\n\n  _getProps(cb) {\n    const targetNode = document.documentElement;\n    const observerOptions = { attributes: true }\n    const observer = new MutationObserver(callback);\n    observer.observe(targetNode, observerOptions);\n\n    function callback(mutationList, observer) {\n      mutationList.forEach((mutation) => {\n        switch(mutation.type) {\n          case 'attributes':\n            if (mutation.attributeName === 'style') {\n              if (typeof cb === \"function\") cb(targetNode.style.cssText);\n            }\n            break;\n        }\n      });\n    }\n  }\n\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      css: ''\n    });\n  }\n\n  [render](changed) {\n    super[render](changed);\n    if (changed.css) {\n      const textarea = this[ids].css;\n      textarea.innerHTML = `:root {\\n /* SDS overrides below */\\n ${this[state].css}}`;\n    }\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <sds-button variant=\"neutral\">Copy CSS</sds-button>\n      <textarea id=\"css\"></textarea>\n      <style>\n        textarea {\n          background: var(--sds-g-color-neutral-base-1);\n          box-sizing: border-box;\n          height: 250px;\n          width: 100%;\n          padding: 1rem;\n          border: 0;\n          border-radius: 6px;\n          resize: vertical;\n          margin: 1rem 0;\n          min-height: 100px;\n          height: auto;\n        }\n        ::part(button) {\n          position: absolute;\n          top: 10px;\n          right: 50px;\n          z-index: 3;\n          font-size: 0.75rem;\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define('worklet-css', WorkletCss);","import {\n  defaultState,\n  template\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletPreview extends ReactiveElement {\n\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      component: null\n    });\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <div id=\"toolbar\">\n        <label for=\"component-select\">Select a component:</label>\n        <select name=\"components\" id=\"component-select\">\n          <option value=\"accordion\">Accordion</option>\n          <option value=\"badge\">Badge</option>\n          <option value=\"breadcrumb\">Breadcrumb</option>\n          <option value=\"button\" selected>Button</option>\n          <option value=\"card\">Card</option>\n          <option value=\"combobox\">Combobox</option>\n          <option value=\"dialog\">Dialog</option>\n          <option value=\"icon\">Icon</option>\n          <option value=\"input-checkbox\">Input Checkbox</option>\n          <option value=\"input-date\">Input Date</option>\n          <option value=\"input-file\">Input File</option>\n          <option value=\"input-text\">Input Text</option>\n          <option value=\"input-radio\">Input Radio</option>\n          <option value=\"input-range\">Input Range</option>\n          <option value=\"menu\">Menu</option>\n          <option value=\"summary-detail\">Summary Detail</option>\n          <option value=\"listbox\">Listbox</option>\n          <option value=\"tabset\">Tabset</option>\n        </select>\n      </div>\n      <div id=\"preview\">\n        <sds-button>Button</sds-button>\n        <sds-button variant=\"neutral\">Button</sds-button>\n        <sds-button variant=\"brand\">Button</sds-button>\n      </div>\n      <div id=\"component-props\">\n        <h4>Styling Hooks Available</h4>\n        <p><strong>Global</strong></p>\n        <ul>\n          <li><code>--sds-g-color-neutral-base-1</code></li>\n          <li><code>--sds-g-color-neutral-base-contrast-1</code></li>\n          <li><code>--sds-g-color-brand-base-contrast-2</code></li>\n          <li><code>--sds-g-color-brand-base-contrast-3</code></li>\n          <li><code>--sds-g-color-brand-inverse-contrast-4</code></li>\n        </ul>\n        <p><strong>Shared</strong></p>\n        <ul>\n          <li><code>--sds-s-button-color-background</code></li>\n          <li><code>--sds-s-button-text-color</code></li>\n        </ul>\n        <p><strong>Local</strong></p>\n        <ul>\n          <li><code>--sds-c-button-color-background</code></li>\n          <li><code>--sds-c-button-text-color</code></li>\n        </ul>\n      </div>\n      <style>\n        :host {\n          font-size: 0.75rem;\n        }\n        #toolbar {\n          border-top-left-radius: 6px;\n          border-top-right-radius: 6px;\n          background: var(--sds-g-color-neutral-base-1);\n          border-bottom: 1px solid var(--sds-g-color-neutral-base-3);\n          padding: 0.5rem;\n          margin-top: 1rem;\n        }\n        label {\n          color: var(--sds-g-color-neutral-base-contrast-2);\n        }\n        #preview {\n          background: white;\n          padding: 2rem;\n          position: sticky;\n          top: var(--headerHeight);\n        }\n        #component-props {\n          background: var(--sds-g-color-neutral-base-1);\n          border-top: 1px solid var(--sds-g-color-neutral-base-3);\n          padding: 0 0.5rem;\n          border-bottom-left-radius: 6px;\n          border-bottom-right-radius: 6px;\n          max-height: 300px;\n          overflow-y: auto;\n        }\n        h4 {\n          color: var(--sds-g-color-neutral-base-contrast-2);\n        }\n        p {\n          margin: 0;\n        }\n        code {\n          font-size: 1rem;\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define('worklet-preview', WorkletPreview);\n","import {\n  defaultState,\n  render,\n  ids,\n  setState,\n  state,\n  template,\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletHeader extends ReactiveElement {\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      page: null,\n    });\n  }\n  get page() {\n    return this[state].page;\n  }\n  set page(page) {\n    this[setState]({\n      page: page,\n    });\n  }\n  [render](changed) {\n    super[render](changed);\n    if (changed.page) {\n      const nav = this[ids].nav;\n      // console.log(nav);\n      const options = nav.options;\n      // console.log(options);\n      for (let option of options) {\n        // console.log({ option });\n        if (option.value === this[state].page) {\n          option.setAttribute(\"selected\", true);\n        }\n      }\n    }\n  }\n  get [template]() {\n    return templateFrom.html`\n      <header>\n        <h1>Styling Hooks Worklets and APIs</h1>\n        <span>→</span>\n        <select id=\"nav\">\n          <option value=\"api\">Custom Properties & Values API</option>\n          <option value=\"paint\">Paint Worklet API</option>\n          <option value=\"layout\">Layout Worklet API</option>\n          <option value=\"animation\">Animation Worklet API</option>\n        </select>\n        <a rel=\"github\" href=\"https://github.com/brandonferrua/test-houdini-hooks\">\n          <svg version=\"1.1\" viewBox=\"0 0 33 32\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n          <defs>\n            <polygon id=\"a\" points=\"8.1315e-20 -3.5527e-15 8.1315e-20 31.775 32.579 31.775 32.579 3.5527e-15\"/>\n          </defs>\n          <g fill-rule=\"evenodd\">\n          <mask id=\"b\" fill=\"white\"><use xlink:href=\"#a\"/></mask>\n          <path d=\"m16.289-3.5527e-15c-8.995 0-16.289 7.293-16.289 16.291 0 7.196 4.667 13.301 11.141 15.456 0.815 0.149 1.112-0.354 1.112-0.786 0-0.386-0.014-1.411-0.022-2.77-4.531 0.984-5.487-2.184-5.487-2.184-0.741-1.882-1.809-2.382-1.809-2.382-1.479-1.011 0.112-0.991 0.112-0.991 1.635 0.116 2.495 1.679 2.495 1.679 1.453 2.489 3.812 1.77 4.741 1.354 0.148-1.053 0.568-1.771 1.034-2.178-3.617-0.411-7.42-1.809-7.42-8.051 0-1.778 0.635-3.232 1.677-4.371-0.168-0.412-0.727-2.068 0.159-4.311 0 0 1.368-0.438 4.48 1.67 1.299-0.362 2.693-0.542 4.078-0.549 1.383 7e-3 2.777 0.187 4.078 0.549 3.11-2.108 4.475-1.67 4.475-1.67 0.889 2.243 0.33 3.899 0.162 4.311 1.044 1.139 1.675 2.593 1.675 4.371 0 6.258-3.809 7.635-7.438 8.038 0.585 0.503 1.106 1.497 1.106 3.017 0 2.177-0.02 3.934-0.02 4.468 0 0.436 0.293 0.943 1.12 0.784 6.467-2.159 11.131-8.26 11.131-15.454 0-8.998-7.294-16.291-16.291-16.291\" mask=\"url(#b)\"/>\n          </g>\n          </svg>\n        </a>\n      </header>\n      <style>\n        header {\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          display: flex;\n          height: var(--headerHeight);\n          align-items: center;\n          z-index: 2;\n          background: var(--sds-g-color-neutral-base-1);\n          padding: 0 1rem;\n        }\n        h1 {\n          font-size: 0.75rem;\n        }\n        span {\n          padding: 0 0.5rem;\n        }\n        [rel=\"github\"] {\n          margin-left: auto;\n          width: 20px;\n          fill: var(--sds-g-color-brand-base-contrast-2);\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"worklet-header-bar\", WorkletHeader);\n","import { ids, render, template } from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class WorkletRipple extends ReactiveElement {\n  [render](changed) {\n    super[render](changed);\n    const canvas = this[ids].canvas;\n    let start = performance.now();\n    let x, y;\n    canvas.addEventListener(\"click\", (e) => {\n      canvas.setAttribute(\"animating\", true);\n      [x, y] = [e.offsetX, e.offsetY];\n      start = performance.now();\n      requestAnimationFrame(function raf(now) {\n        const count = Math.floor(now - start);\n        canvas.style.cssText = `--ripple-x: ${x}; --ripple-y: ${y}; --animation-tick: ${count}; `;\n        if (count > 1000) {\n          canvas.removeAttribute(\"animating\");\n          canvas.style.cssText = `--animation-tick: 0`;\n          return;\n        }\n        requestAnimationFrame(raf);\n      });\n    });\n  }\n  get [template]() {\n    return templateFrom.html`\n      <div id=\"canvas\"></div>\n      <style>\n        :host {\n          display: block;\n          width: 100%;\n          height: 100%;\n          position: relative;\n        }\n        ::part(button) {\n          background-image: paint(ripple);\n        }\n        #canvas {\n          width: 100%;\n          height: 100%;\n          background-color: var(--sds-g-color-brand-base-contrast-2);\n          display: flex;\n          justify-content: space-around;\n          align-items: center;\n          color: white;\n          text-align: center;\n          cursor: pointer;\n\n          /* Required for animation by the worklet */\n          --ripple-x: 0;\n          --ripple-y: 0;\n          --ripple-color: var(--sds-g-color-brand-inverse-contrast-2);\n          --animation-tick: 0;\n        }\n        #canvas[animating=\"true\"] {\n          background-image: paint(ripple);\n        }\n      </style>\n    `;\n  }\n}\n\ncustomElements.define(\"worklet-ripple\", WorkletRipple);\n","import {\n  defaultState,\n  template\n} from \"elix/src/base/internal.js\";\nimport { templateFrom } from \"elix/src/core/htmlLiterals\";\nimport ReactiveElement from \"elix/src/core/ReactiveElement.js\";\n\nexport default class SdsButton extends ReactiveElement {\n  get [defaultState]() {\n    return Object.assign(super[defaultState], {\n      prop: null\n    });\n  }\n\n  get [template]() {\n    return templateFrom.html`\n      <button part=\"button\">\n        <slot name=\"start\"></slot>\n        <slot></slot>\n        <slot name=\"end\"></slot>\n      </button>\n      <style>\n        @import url('/src/components/Button.css');\n      </style>\n    `;\n  }\n}\n\ncustomElements.define('sds-button', SdsButton);"],"names":["defaultState","Symbol","delegatesFocus","firstRender","focusTarget","hasDynamicTemplate","ids","nativeInternals","raiseChangeEvents","render","renderChanges","rendered","rendering","setState","shadowRoot","shadowRootMode","state","stateEffects","template","checkSize","closestAvailableItemIndex","contentSlot","coreInternal.defaultState","defaultTabIndex","coreInternal.delegatesFocus","effectEndTarget","coreInternal.firstRender","coreInternal.focusTarget","getItemText","goDown","goEnd","goFirst","goLast","goLeft","goNext","goPrevious","goRight","goStart","goToItemWithPrefix","goUp","coreInternal.hasDynamicTemplate","coreInternal.ids","inputDelegate","itemsDelegate","keydown","mouseenter","mouseleave","coreInternal.nativeInternals","coreInternal.raiseChangeEvents","coreInternal.render","coreInternal.renderChanges","renderDataToElement","coreInternal.rendered","coreInternal.rendering","scrollTarget","coreInternal.setState","coreInternal.shadowRoot","coreInternal.shadowRootMode","startEffect","coreInternal.state","coreInternal.stateEffects","swipeDown","swipeDownComplete","swipeLeft","swipeLeftTransitionEnd","swipeRight","swipeRightTransitionEnd","swipeUp","swipeUpComplete","swipeStart","swipeTarget","tap","coreInternal.template","toggleSelectedFlag","URLSearchParams","location","search","get","elix","internal","event","templateFrom","[object Object]","strings","substitutions","document","createElement","innerHTML","String","raw","standardBooleanAttributes","checked","defer","disabled","hidden","ismap","multiple","noresize","readonly","selected","attributeToPropertyNames","tabindex","propertyNamesToAttributes","tabIndex","attributesForClass","classFn","HTMLElement","baseClass","Object","getPrototypeOf","prototype","constructor","baseAttributes","observedAttributes","diff","getOwnPropertyNames","filter","propertyName","descriptor","getOwnPropertyDescriptor","set","map","setterName","attribute","replace","toLowerCase","propertyNameToAttribute","indexOf","concat","stateKey","raiseChangeEventsInNextRenderKey","changedSinceLastRenderKey","fieldsChanged","changes","changed","field","value2","value1","Date","getTime","classTemplateMap","Map","shadowIdProxyKey","proxyElementKey","shadowIdProxyHandler","target","id","root","getElementById","getTemplate","element","t","undefined","HTMLTemplateElement","name","ReactiveElement","Base","attributeName","oldValue","newValue","super","attributeChangedCallback","this","match","toUpperCase","attributeToPropertyName","parsed","value","AttributeMarshallingMixin","Reactive","connectedCallback","saveRaiseChangeEvents","console","warn","assign","effects","changedByEffects","keys","length","copyStateWithChanges","freeze","willRender","isConnected","Promise","resolve","defineProperty","ReactiveMixin","Proxy","attachShadow","mode","clone","importNode","content","append","WorkletColor","defaultState$1","prop","pickerEl","picker","colorEl","color","nameEl","valueEl","setAttribute","textContent","style","setProperty","_checkContrast","addEventListener","e","nameProp","getAttribute","documentElement","select","el","c","parseInt","substr","template$1","html","customElements","define","WorkletColors","_getProps","computedStyleMap","forEach","arr","getComputedStyle","getPropertyValue","a","props","push","split","toString","slice","hooks","results","test","hook","insertAdjacentHTML","WorkletCss","css","cb","targetNode","MutationObserver","mutationList","observer","mutation","type","cssText","observe","attributes","WorkletPreview","component","WorkletHeader","page","options","nav","option","WorkletRipple","canvas","x","y","start","performance","now","offsetX","offsetY","requestAnimationFrame","raf","count","Math","floor","removeAttribute","SdsButton"],"mappings":"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"}